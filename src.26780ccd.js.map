{"version":3,"sources":["node_modules/base64-js/index.js","node_modules/ieee754/index.js","node_modules/isarray/index.js","node_modules/buffer/index.js","../style-spec.js","../../../node_modules/json-stringify-pretty-compact/index.js","../format.js","../../../node_modules/url/node_modules/punycode/punycode.js","../../../node_modules/url/util.js","../../../node_modules/querystring/decode.js","../../../node_modules/querystring/encode.js","../../../node_modules/querystring/index.js","../../../node_modules/url/url.js","../visit.js","../migrate/v8.js","../util/extend.js","../expression/parsing_error.js","../expression/scope.js","../expression/types.js","../../../node_modules/csscolorparser/csscolorparser.js","../util/color.js","../expression/types/collator.js","../expression/types/formatted.js","../expression/types/resolved_image.js","../expression/values.js","../expression/definitions/literal.js","../expression/runtime_error.js","../expression/definitions/assertion.js","../expression/definitions/format.js","../expression/definitions/image.js","../expression/definitions/coercion.js","../expression/evaluation_context.js","../expression/compound_expression.js","../expression/definitions/collator.js","../expression/definitions/within.js","../expression/is_constant.js","../expression/definitions/var.js","../expression/parsing_context.js","../expression/stops.js","../expression/definitions/step.js","../../../node_modules/@mapbox/unitbezier/index.js","../util/interpolate.js","../util/color_spaces.js","../expression/definitions/interpolate.js","../expression/definitions/coalesce.js","../expression/definitions/let.js","../expression/definitions/at.js","../expression/definitions/in.js","../expression/definitions/index_of.js","../expression/definitions/match.js","../expression/definitions/case.js","../expression/definitions/slice.js","../expression/definitions/comparison.js","../expression/definitions/number_format.js","../expression/definitions/length.js","../expression/definitions/index.js","../util/result.js","../util/properties.js","../util/get_type.js","../function/index.js","../expression/index.js","../function/convert.js","../util/unbundle_jsonlint.js","../feature_filter/index.js","../feature_filter/convert.js","../migrate/expressions.js","../migrate.js","../composite.js","../util/ref_properties.js","../deref.js","../util/deep_equal.js","../diff.js","../error/validation_error.js","../error/parsing_error.js","../validate/validate_object.js","../validate/validate_array.js","../validate/validate_number.js","../validate/validate_function.js","../validate/validate_expression.js","../validate/validate_boolean.js","../validate/validate_color.js","../validate/validate_enum.js","../validate/validate_filter.js","../validate/validate_property.js","../validate/validate_paint_property.js","../validate/validate_layout_property.js","../validate/validate_layer.js","../validate/validate_string.js","../validate/validate_source.js","../validate/validate_light.js","../validate/validate_terrain.js","../validate/validate_fog.js","../validate/validate_formatted.js","../validate/validate_image.js","../validate/validate_projection.js","../validate/validate.js","../validate/validate_glyphs_url.js","../validate_style.min.js","../../../node_modules/@mapbox/jsonlint-lines-primitives/lib/jsonlint.js","../read_style.js","../validate_style.js","../validate_mapbox_api_supported.js","../src/index.js","../src/Circle.js","../src/Fill.js","../src/Line.js","../src/Symbol.js","../src/util.js","src/index.js"],"names":["stringOrChar","stringify","passedObj","options","indent","JSON","undefined","slice","maxLength","Infinity","replacer","_stringify","obj","currentIndent","reserved","toJSON","string","length","prettified","replace","match","stringLiteral","parse","nextIndent","items","start","end","index","Array","isArray","push","keys","Object","key","keyPart","value","join","sortKeysBy","reference","result","format","style","space","$root","layers","map","layer","stringifyPretty","root","freeExports","exports","nodeType","freeModule","module","freeGlobal","global","window","self","punycode","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error","type","RangeError","array","fn","mapDomain","parts","split","ucs2decode","extra","output","counter","charCodeAt","ucs2encode","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","out","basic","j","oldi","w","t","baseMinusT","codePoint","inputLength","i","n","bias","lastIndexOf","splice","encode","handledCPCount","basicLength","m","q","currentValue","handledCPCountPlusOne","qMinusT","toASCII","test","toUnicode","toLowerCase","hasOwnProperty","this","isString","arg","isObject","isNull","isNullOrUndefined","prop","prototype","call","qs","sep","eq","regexp","maxKeys","len","kstr","vstr","v","x","idx","indexOf","substr","decodeURIComponent","stringifyPrimitive","isFinite","name","ks","encodeURIComponent","require","querystring","util","Url","protocol","slashes","auth","host","port","hostname","hash","search","query","pathname","path","href","urlParse","urlResolve","urlResolveObject","urlFormat","protocolPattern","portPattern","simplePathPattern","delims","unwise","concat","autoEscape","nonHostChars","hostEndingChars","hostnameMaxLen","hostnamePartPattern","hostnamePartStart","unsafeProtocol","hostlessProtocol","slashedProtocol","url","parseQueryString","slashesDenoteHost","u","source","relative","resolve","resolveObject","getPropertyReference","propertyName","Reference","layout","paint","eachSource","callback","sources","eachLayer","eachProperty","inner","propertyType","properties","forEach","id","set","eachLayout","eachPaint","resolveConstant","constants","isFunction","stops","renameProperty","from","to","version","coordinates","coord","reverse","property","stop","glyphs","inputParsed","URL","inputPathnameParts","assert","decodeURI","predicate","Error","migrateFontstackURL","font","splitAndTrim","s","trim","migrateFontStack","firstSymbolLayer","symbolLayers","inputs","TypeError","queryIndex","splitter","uSplit","rest","simplePath","exec","proto","lowerProto","atSign","hostEnd","hec","parseHost","ipv6Hostname","hostparts","l","part","newpart","validParts","notHost","bit","unshift","p","h","ae","esc","escape","qm","charAt","rel","tkeys","tk","tkey","rkeys","rk","rkey","relPath","shift","isSourceAbs","isRelAbs","mustEndAbs","removeAllDots","srcPath","psychotic","pop","authInHost","last","hasTrailingSlash","up","isAbsolute","ParsingError","constructor","message","Scope","parent","bindings","expression","get","has","NullType","kind","NumberType","StringType","BooleanType","ColorType","ObjectType","ValueType","ErrorType","CollatorType","FormattedType","ResolvedImageType","itemType","N","toString","valueMemberTypes","checkSubtype","expected","memberType","isValidType","provided","allowedTypes","some","isValidNativeType","kCSSColorTable","clamp_css_byte","round","clamp_css_float","f","parse_css_int","str","parseFloat","parseInt","parse_css_float","css_hue_to_rgb","m1","m2","parseCSSColor","css_str","iv","op","ep","fname","params","alpha","e","Color","r","g","b","a","rgba","toArray","toArray01","toArray01PremultipliedAlpha","black","white","transparent","red","blue","Collator","caseSensitive","diacriticSensitive","locale","sensitivity","collator","Intl","usage","compare","lhs","rhs","resolvedLocale","resolvedOptions","FormattedSection","text","image","scale","fontStack","textColor","normalize","Formatted","sections","unformatted","isEmpty","section","fromString","serialize","serialized","ResolvedImage","available","validateRGBA","isValue","mixed","item","typeOf","Literal","args","context","expectedType","evaluate","eachChild","outputDefined","RuntimeError","types","number","boolean","object","Assertion","parsed","ctx","every","FormatExpression","firstArg","nextTokenMayBeObject","lastExpression","content","evaluatedContent","ImageExpression","evaluatedImageName","availableImages","Coercion","Boolean","c","parseColor","num","Number","isNaN","valueToString","child","geometryTypes","EvaluationContext","globals","feature","featureState","formattedSection","_parseColorCache","canonical","featureTileCoord","featureDistanceData","geometryType","geometry","canonicalID","distanceFromCenter","center","y","dX","dY","bearing","cached","CompoundExpression","_evaluate","definition","definitions","availableOverloads","overloads","filter","signature","signatureContext","ParsingContext","registry","scope","parsedArgs","argParseFailed","signatures","stringifySignature","actualTypes","CollatorExpression","EXTENT","updateBBox","bbox","min","max","mercatorXfromLng","lng","mercatorYfromLat","lat","PI","log","tan","boxWithinBox","bbox1","bbox2","getTileCoordinates","tilesAtZoom","pow","z","onBoundary","p1","p2","x1","y1","x2","y2","rayIntersect","pointWithinPolygon","point","rings","inside","ring","len2","pointWithinPolygons","polygons","perp","v1","v2","twoSided","q1","q2","x3","y3","det1","det2","lineIntersectLine","d","vectorP","lineIntersectPolygon","polygon","lineStringWithinPolygon","line","lineStringWithinPolygons","getTilePolygon","getTilePolygons","updatePoint","polyBBox","worldSize","halfWorldSize","resetBBox","getTilePoints","pointBBox","shifts","tilePoints","points","getTileLines","lineBBox","tileLines","tileLine","pointsWithinPolygons","polygonGeometry","tilePolygon","tilePolygons","linesWithinPolygons","Within","geojson","geometries","features","isFeatureConstant","isStateConstant","isGlobalPropertyConstant","Var","boundExpression","expr","_parse","annotate","typeAnnotation","Expr","actual","isConstant","ec","isTypeAnnotation","childrenConstant","findStopLessThanOrEqualTo","lastIndex","nextValue","lowerIndex","upperIndex","currentIndex","Step","labels","outputs","label","outputType","labelKey","valueKey","stopCount","UnitBezier","p1x","p1y","p2x","p2y","cx","bx","ax","cy","by","ay","color","sampleCurveX","sampleCurveY","sampleCurveDerivativeX","solveCurveX","epsilon","abs","d2","t0","t1","solve","Xn","Yn","Zn","t2","t3","deg2rad","rad2deg","xyz2lab","lab2xyz","xyz2rgb","rgb2xyz","rgbToLab","rgbColor","labToRgb","labColor","interpolateLab","interpolateNumber","rgbToHcl","atan2","sqrt","hclToRgb","hclColor","cos","sin","interpolateHue","interpolateHcl","lab","forward","interpolate","hcl","Interpolate","operator","interpolation","lower","upper","exponentialInterpolation","controlPoints","interpolationFactor","outputLower","outputUpper","lowerValue","upperValue","difference","progress","Coalesce","needsAnnotation","firstImage","argCount","Let","binding","At","In","needle","haystack","IndexOf","fromIndex","Match","inputType","cases","otherwise","labelContext","MAX_SAFE_INTEGER","sortedLabels","sort","groupedByOutput","outputLookup","outputIndex","coerceLabel","Case","branches","_","Slice","beginIndex","endIndex","isComparableType","neq","lt","gt","lteq","gteq","eqCollate","neqCollate","ltCollate","gtCollate","lteqCollate","gteqCollate","makeComparison","compareBasic","compareWithCollator","isOrderComparison","Comparison","hasUntypedArgument","rt","Equals","NotEquals","LessThan","GreaterThan","LessThanOrEqual","GreaterThanOrEqual","NumberFormat","currency","unit","minFractionDigits","maxFractionDigits","minimumFractionDigits","maximumFractionDigits","Length","expressions","binarySearch","varargs","register","typeToString","zoom","pitch","heatmapDensity","lineProgress","skyRadialProgress","accumulated","LN2","E","LN10","asin","acos","atan","ceil","isSupportedScript","toUpperCase","success","supportsPropertyExpression","spec","supportsZoomExpression","parameters","supportsInterpolation","interpolated","getType","val","identityFunction","createFunction","propertySpec","isColor","zoomAndFeatureDependent","featureDependent","zoomDependent","extend","default","colorSpace","colorSpaces","innerFun","hashedStops","categoricalKeyType","evaluateExponentialFunction","evaluateIntervalFunction","evaluateCategoricalFunction","create","evaluateIdentityFunction","featureFunctions","zoomStops","featureFunctionStops","interpolationType","bind","coalesce","keyType","interp","colorspace","evaluatedLower","apply","evaluatedUpper","values","StyleExpression","_warningHistory","_evaluator","_defaultValue","getDefaultValue","_enumValues","evaluateWithoutErrorHandling","console","warn","isExpression","createExpression","parser","getExpectedType","ZoomConstantExpression","_styleExpression","isStateDependent","ZoomDependentExpression","createPropertyExpression","isZoomConstant","zoomCurve","findZoomCurve","StylePropertyFunction","specification","_parameters","_specification","normalizePropertyExpression","err","constant","childResult","enum","formatted","resolvedImage","convertLiteral","convertFunction","convertIdentityFunction","tokens","convertTokenString","convertZoomAndPropertyFunction","convertZoomFunction","convertPropertyFunction","getInterpolateOperator","featureFunctionParameters","getFunctionType","appendStopPair","fixupDegenerateStepCurve","getFallback","defaultValue","isStep","curve","re","pos","literal","unbundle","valueOf","deepUnbundle","unbundledValue","isExpressionFilter","createFilter","layerType","needGeometry","needFeature","convertFilter","filterExp","staticFilter","extractStaticFilter","filterSpec","latest","compiledStaticFilter","filterFunc","globalProperties","dynamicFilterFunc","compiledDynamicFilter","dynamicFilter","geometryNeeded","isDynamicFilter","unionDynamicBranches","collapseDynamicBooleanExpressions","collapsed","collapsedExpression","subExpression","isBranchingDynamically","isRootExpressionDynamic","dynamicConditionExpressions","Set","convertComparisonOp","convertNegation","convertDisjunctionOp","convertInOp","convertHasOp","filters","_convertFilter","expectedTypes","converted","children","typechecks","runtimeTypeChecks","conditions","negate","uniformTypes","uniqueValues","migrated","migrateToV8","migrateToExpressions","styleIDs","sourceIDs","compositedSourceLayers","compositeID","deref","refProperties","derefLayers","ref","deepEqual","operations","setStyle","addLayer","removeLayer","setPaintProperty","setLayoutProperty","setFilter","addSource","removeSource","setGeoJSONSourceData","setLayerZoomRange","setLayerProperty","setCenter","setZoom","setBearing","setPitch","setSprite","setGlyphs","setTransition","setLight","setTerrain","setFog","setProjection","sourceId","after","commands","command","sourcesRemoved","updateSource","canUpdateGeoJSON","before","isEqual","diffSources","data","diffLayerPropertyChanges","layerId","klass","pluckId","indexById","group","diffLayers","beforeOrder","afterOrder","beforeIndex","reduce","afterIndex","tracker","clean","beforeLayer","afterLayer","insertBeforeLayerId","minzoom","maxzoom","diffStyles","sprite","transition","light","fog","projection","removeOrAddSourceCommands","beforeLayers","beforeTerrain","terrain","ValidationError","identifier","__line__","validateObject","elementSpecs","valueSpec","elementValidators","objectElementValidators","styleSpec","objectKey","elementSpecKey","elementSpec","validateElement","validateSpec","required","validateArray","arraySpec","validateArrayElement","arrayElementValidator","validate","arrayElementSpec","minimum","maximum","function","$version","arrayIndex","validateNumber","specMin","specMax","validateFunction","functionValueSpec","functionType","stopKeyType","previousStopDomainValue","previousStopDomainZoom","stopDomainValues","isZoomFunction","isPropertyFunction","isZoomAndPropertyFunction","validateFunctionStop","nextStopDomainZoom","validateStopDomainValue","reportValue","validateExpression","expressionContext","expressionObj","propertyKey","disallowedFilterParameters","disallowedParameters","param","delete","size","validateBoolean","validateColor","validateEnum","validateFilter","validateNonExpressionFilter","filter_operator","geometry_type","validateProperty","layerSpec","transitionMatch","tokenMatch","validatePaintProperty","validateLayoutProperty","validateLayer","otherLayer","sourceType","lineMetrics","validateString","promoteId","validatePromoteId","validateSource","source_geojson","cluster","clusterProperties","mapExpr","reduceExpr","source_video","source_image","getSourceTypeValues","memo","validateLight","lightSpec","rootType","validateTerrain","terrainSpec","validateFog","fogSpec","validateFormatted","validateImage","validateProjection","projectionSpec","VALIDATORS","validateStyle","latestStyleSpec","sortErrors","validateGlyphsURL","o","$V0","$V1","$V2","$V3","$V4","$V5","$V6","$V7","$V8","$V9","trace","yy","symbols_","terminals_","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","$","first_line","defineProperty","enumerable","table","defaultActions","parseError","recoverable","stack","vstack","lstack","EOF","arguments","lexer","sharedState","setInput","yylloc","yyloc","ranges","getPrototypeOf","symbol","state","action","newState","token","yyval","lex","errStr","showPosition","loc","last_line","first_column","last_column","range","_input","_more","_backtrack","done","matched","conditionStack","offset","ch","unput","lines","oldLines","more","reject","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","test_match","indexed_rule","backup","matches","tempMatch","rules","_currentRules","flex","begin","condition","popState","topState","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","Parser","readStyle","Buffer","jsonlint","v8","validateStyleMin","SUPPORTED_SPEC_VERSION","MAX_SOURCES_IN_STYLE","isValid","regex","getSourceCount","getAllowedKeyErrors","allowed","acceptedSourceTypes","getSourceErrors","getSourcesErrors","count","sourceErrors","getRootErrors","specKeys","allowedKeyErrors","visibility","protected","validateMapboxApiSupported","styleFunction","visit","Circle","props","radius","strokeWidth","fillColor","fillOpacity","strokeColor","strokeOpacity","innerRadius","element","attributes","viewBox","xmlns","fill","opacity","stroke-width","stroke","Fill","width","height","backgroundImage","backgroundColor","backgroundSize","backgroundPosition","Line","linePatternDataUrl","strokeDasharray","sw","cssStyle","patternUnits","patternTransform","xlinkHref","Symbol","imgKey","dataUrl","backgroundRepeat","textOpacity","stroke-linejoin","PROP_MAP","handler","circle","prefix","find","def","startsWith","specItem","json","dimensions","img","el","document","createElement","getContext","drawImage","toDataURL","_legendSymbol","_interopRequireDefault","__esModule","LegendSymbol"],"mappings":"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","file":"src.26780ccd.js","sourceRoot":"..","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","// @flow\n\ntype ExpressionType = 'data-driven' | 'color-ramp' | 'data-constant' | 'constant';\ntype ExpressionParameters = Array<'zoom' | 'feature' | 'feature-state' | 'heatmap-density' | 'line-progress' | 'sky-radial-progress' | 'pitch' | 'distance-from-center'>;\n\ntype ExpressionSpecification = {\n    interpolated: boolean,\n    parameters: ExpressionParameters\n}\n\nexport type StylePropertySpecification = {\n    type: 'number',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    transition: boolean,\n    default?: number\n} | {\n    type: 'string',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    transition: boolean,\n    default?: string,\n    tokens?: boolean\n} | {\n    type: 'boolean',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    transition: boolean,\n    default?: boolean\n} | {\n    type: 'enum',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    values: {[_: string]: {}},\n    transition: boolean,\n    default?: string\n} | {\n    type: 'color',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    transition: boolean,\n    default?: string,\n    overridable: boolean\n} | {\n    type: 'array',\n    value: 'number',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    length?: number,\n    transition: boolean,\n    default?: Array<number>\n} | {\n    type: 'array',\n    value: 'string',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    length?: number,\n    transition: boolean,\n    default?: Array<string>\n} | {\n    type: 'resolvedImage',\n    'property-type': ExpressionType,\n    expression?: ExpressionSpecification,\n    transition: boolean,\n    default?: string\n};\n\nimport v8 from './reference/v8.json';\nimport latest from './reference/latest.js';\nimport format from './format.js';\nimport migrate from './migrate.js';\nimport composite from './composite.js';\nimport derefLayers from './deref.js';\nimport diff from './diff.js';\nimport ValidationError from './error/validation_error.js';\nimport ParsingError from './error/parsing_error.js';\nimport {StyleExpression, isExpression, createExpression, createPropertyExpression, normalizePropertyExpression, ZoomConstantExpression, ZoomDependentExpression, StylePropertyFunction} from './expression/index.js';\nimport featureFilter, {isExpressionFilter} from './feature_filter/index.js';\n\nimport convertFilter from './feature_filter/convert.js';\nimport Color from './util/color.js';\nimport {createFunction, isFunction} from './function/index.js';\nimport convertFunction from './function/convert.js';\nimport {eachSource, eachLayer, eachProperty} from './visit.js';\n\nimport validate from './validate_style.js';\nimport validateMapboxApiSupported from './validate_mapbox_api_supported.js';\n\nconst expression = {\n    StyleExpression,\n    isExpression,\n    isExpressionFilter,\n    createExpression,\n    createPropertyExpression,\n    normalizePropertyExpression,\n    ZoomConstantExpression,\n    ZoomDependentExpression,\n    StylePropertyFunction\n};\n\nconst styleFunction = {\n    convertFunction,\n    createFunction,\n    isFunction\n};\n\nconst visit = {eachSource, eachLayer, eachProperty};\n\nexport {\n    v8,\n    latest,\n    format,\n    migrate,\n    composite,\n    derefLayers,\n    diff,\n    ValidationError,\n    ParsingError,\n    expression,\n    featureFilter,\n    convertFilter,\n    Color,\n    styleFunction as function,\n    validate,\n    validateMapboxApiSupported,\n    visit\n};\n","// Note: This regex matches even invalid JSON strings, but since we’re\n// working on the output of `JSON.stringify` we know that only valid strings\n// are present (unless the user supplied a weird `options.indent` but in\n// that case we don’t care since the output would be invalid anyway).\nconst stringOrChar = /(\"(?:[^\\\\\"]|\\\\.)*\")|[:,]/g;\n\nexport default function stringify(passedObj, options = {}) {\n  const indent = JSON.stringify(\n    [1],\n    undefined,\n    options.indent === undefined ? 2 : options.indent\n  ).slice(2, -3);\n\n  const maxLength =\n    indent === \"\"\n      ? Infinity\n      : options.maxLength === undefined\n      ? 80\n      : options.maxLength;\n\n  let { replacer } = options;\n\n  return (function _stringify(obj, currentIndent, reserved) {\n    if (obj && typeof obj.toJSON === \"function\") {\n      obj = obj.toJSON();\n    }\n\n    const string = JSON.stringify(obj, replacer);\n\n    if (string === undefined) {\n      return string;\n    }\n\n    const length = maxLength - currentIndent.length - reserved;\n\n    if (string.length <= length) {\n      const prettified = string.replace(\n        stringOrChar,\n        (match, stringLiteral) => {\n          return stringLiteral || `${match} `;\n        }\n      );\n      if (prettified.length <= length) {\n        return prettified;\n      }\n    }\n\n    if (replacer != null) {\n      obj = JSON.parse(string);\n      replacer = undefined;\n    }\n\n    if (typeof obj === \"object\" && obj !== null) {\n      const nextIndent = currentIndent + indent;\n      const items = [];\n      let index = 0;\n      let start;\n      let end;\n\n      if (Array.isArray(obj)) {\n        start = \"[\";\n        end = \"]\";\n        const { length } = obj;\n        for (; index < length; index++) {\n          items.push(\n            _stringify(obj[index], nextIndent, index === length - 1 ? 0 : 1) ||\n              \"null\"\n          );\n        }\n      } else {\n        start = \"{\";\n        end = \"}\";\n        const keys = Object.keys(obj);\n        const { length } = keys;\n        for (; index < length; index++) {\n          const key = keys[index];\n          const keyPart = `${JSON.stringify(key)}: `;\n          const value = _stringify(\n            obj[key],\n            nextIndent,\n            keyPart.length + (index === length - 1 ? 0 : 1)\n          );\n          if (value !== undefined) {\n            items.push(keyPart + value);\n          }\n        }\n      }\n\n      if (items.length > 0) {\n        return [start, indent + items.join(`,\\n${nextIndent}`), end].join(\n          `\\n${currentIndent}`\n        );\n      }\n    }\n\n    return string;\n  })(passedObj, \"\", 0);\n}\n","\nimport reference from './reference/latest.js';\nimport stringifyPretty from 'json-stringify-pretty-compact';\n\nfunction sortKeysBy(obj, reference) {\n    const result = {};\n    for (const key in reference) {\n        if (obj[key] !== undefined) {\n            result[key] = obj[key];\n        }\n    }\n    for (const key in obj) {\n        if (result[key] === undefined) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\n\n/**\n * Format a Mapbox GL Style.  Returns a stringified style with its keys\n * sorted in the same order as the reference style.\n *\n * The optional `space` argument is passed to\n * [`JSON.stringify`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * to generate formatted output.\n *\n * If `space` is unspecified, a default of `2` spaces will be used.\n *\n * @private\n * @param {Object} style a Mapbox GL Style\n * @param {number} [space] space argument to pass to `JSON.stringify`\n * @returns {string} stringified formatted JSON\n * @example\n * var fs = require('fs');\n * var format = require('mapbox-gl-style-spec').format;\n * var style = fs.readFileSync('./source.json', 'utf8');\n * fs.writeFileSync('./dest.json', format(style));\n * fs.writeFileSync('./dest.min.json', format(style, 0));\n */\nfunction format(style, space = 2) {\n    style = sortKeysBy(style, reference.$root);\n\n    if (style.layers) {\n        style.layers = style.layers.map((layer) => sortKeysBy(layer, reference.layer));\n    }\n\n    return stringifyPretty(style, {indent: space});\n}\n\nexport default format;\n","/*! https://mths.be/punycode v1.3.2 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * http://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.3.2',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","// @flow\n\nimport Reference from './reference/v8.json';\nimport type {StylePropertySpecification} from './style-spec.js';\nimport type {\n    StyleSpecification,\n    SourceSpecification,\n    LayerSpecification,\n    PropertyValueSpecification,\n    DataDrivenPropertyValueSpecification\n} from './types.js';\n\nfunction getPropertyReference(propertyName): StylePropertySpecification {\n    for (let i = 0; i < Reference.layout.length; i++) {\n        for (const key in Reference[Reference.layout[i]]) {\n            if (key === propertyName) return (Reference[Reference.layout[i]][key]: any);\n        }\n    }\n    for (let i = 0; i < Reference.paint.length; i++) {\n        for (const key in Reference[Reference.paint[i]]) {\n            if (key === propertyName) return (Reference[Reference.paint[i]][key]: any);\n        }\n    }\n\n    return (null: any);\n}\n\nexport function eachSource(style: StyleSpecification, callback: (_: SourceSpecification) => void) {\n    for (const k in style.sources) {\n        callback(style.sources[k]);\n    }\n}\n\nexport function eachLayer(style: StyleSpecification, callback: (_: LayerSpecification) => void) {\n    for (const layer of style.layers) {\n        callback(layer);\n    }\n}\n\ntype PropertyCallback = ({\n    path: [string, 'paint' | 'layout', string], // [layerid, paint/layout, property key]\n    key: string,\n    value: PropertyValueSpecification<mixed> | DataDrivenPropertyValueSpecification<mixed>,\n    reference: StylePropertySpecification,\n    set: (PropertyValueSpecification<mixed> | DataDrivenPropertyValueSpecification<mixed>) => void\n}) => void;\n\nexport function eachProperty(\n    style: StyleSpecification,\n    options: {paint?: boolean, layout?: boolean},\n    callback: PropertyCallback\n) {\n    function inner(layer, propertyType: 'paint' | 'layout') {\n        const properties = (layer[propertyType]: any);\n        if (!properties) return;\n        Object.keys(properties).forEach((key) => {\n            callback({\n                path: [layer.id, propertyType, key],\n                key,\n                value: properties[key],\n                reference: getPropertyReference(key),\n                set(x) {\n                    properties[key] = x;\n                }\n            });\n        });\n    }\n\n    eachLayer(style, (layer) => {\n        if (options.paint) {\n            inner(layer, 'paint');\n        }\n        if (options.layout) {\n            inner(layer, 'layout');\n        }\n    });\n}\n","\nimport URL from 'url';\nimport {eachSource, eachLayer, eachProperty} from '../visit.js';\n\nfunction eachLayout(layer, callback) {\n    for (const k in layer) {\n        if (k.indexOf('layout') === 0) {\n            callback(layer[k], k);\n        }\n    }\n}\n\nfunction eachPaint(layer, callback) {\n    for (const k in layer) {\n        if (k.indexOf('paint') === 0) {\n            callback(layer[k], k);\n        }\n    }\n}\n\nfunction resolveConstant(style, value) {\n    if (typeof value === 'string' && value[0] === '@') {\n        return resolveConstant(style, style.constants[value]);\n    } else {\n        return value;\n    }\n}\n\nfunction isFunction(value) {\n    return Array.isArray(value.stops);\n}\n\nfunction renameProperty(obj, from, to) {\n    obj[to] = obj[from]; delete obj[from];\n}\n\nexport default function(style) {\n    style.version = 8;\n\n    // Rename properties, reverse coordinates in source and layers\n    eachSource(style, (source) => {\n        if (source.type === 'video' && source.url !== undefined) {\n            renameProperty(source, 'url', 'urls');\n        }\n        if (source.type === 'video') {\n            source.coordinates.forEach((coord) => {\n                return coord.reverse();\n            });\n        }\n    });\n\n    eachLayer(style, (layer) => {\n        eachLayout(layer, (layout) => {\n            if (layout['symbol-min-distance'] !== undefined) {\n                renameProperty(layout, 'symbol-min-distance', 'symbol-spacing');\n            }\n        });\n\n        eachPaint(layer, (paint) => {\n            if (paint['background-image'] !== undefined) {\n                renameProperty(paint, 'background-image', 'background-pattern');\n            }\n            if (paint['line-image'] !== undefined) {\n                renameProperty(paint, 'line-image', 'line-pattern');\n            }\n            if (paint['fill-image'] !== undefined) {\n                renameProperty(paint, 'fill-image', 'fill-pattern');\n            }\n        });\n    });\n\n    // Inline Constants\n    eachProperty(style, {paint: true, layout: true}, (property) => {\n        const value = resolveConstant(style, property.value);\n\n        if (isFunction(value)) {\n            value.stops.forEach((stop) => {\n                stop[1] = resolveConstant(style, stop[1]);\n            });\n        }\n\n        property.set(value);\n    });\n    delete style.constants;\n\n    eachLayer(style, (layer) => {\n        // get rid of text-max-size, icon-max-size\n        // turn text-size, icon-size into layout properties\n        // https://github.com/mapbox/mapbox-gl-style-spec/issues/255\n\n        eachLayout(layer, (layout) => {\n            delete layout['text-max-size'];\n            delete layout['icon-max-size'];\n        });\n\n        eachPaint(layer, (paint) => {\n            if (paint['text-size']) {\n                if (!layer.layout) layer.layout = {};\n                layer.layout['text-size'] = paint['text-size'];\n                delete paint['text-size'];\n            }\n\n            if (paint['icon-size']) {\n                if (!layer.layout) layer.layout = {};\n                layer.layout['icon-size'] = paint['icon-size'];\n                delete paint['icon-size'];\n            }\n        });\n    });\n\n    function migrateFontstackURL(input) {\n        const inputParsed = URL.parse(input);\n        const inputPathnameParts = inputParsed.pathname.split('/');\n\n        if (inputParsed.protocol !== 'mapbox:') {\n            return input;\n\n        } else if (inputParsed.hostname === 'fontstack') {\n            assert(decodeURI(inputParsed.pathname) === '/{fontstack}/{range}.pbf');\n            return 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf';\n\n        } else if (inputParsed.hostname === 'fonts') {\n            assert(inputPathnameParts[1] === 'v1');\n            assert(decodeURI(inputPathnameParts[3]) === '{fontstack}');\n            assert(decodeURI(inputPathnameParts[4]) === '{range}.pbf');\n            return `mapbox://fonts/${inputPathnameParts[2]}/{fontstack}/{range}.pbf`;\n\n        } else {\n            assert(false);\n        }\n\n        function assert(predicate) {\n            if (!predicate) {\n                throw new Error(`Invalid font url: \"${input}\"`);\n            }\n        }\n    }\n\n    if (style.glyphs) {\n        style.glyphs = migrateFontstackURL(style.glyphs);\n    }\n\n    function migrateFontStack(font) {\n        function splitAndTrim(string) {\n            return string.split(',').map((s) => {\n                return s.trim();\n            });\n        }\n\n        if (Array.isArray(font)) {\n            // Assume it's a previously migrated font-array.\n            return font;\n\n        } else if (typeof font === 'string') {\n            return splitAndTrim(font);\n\n        } else if (typeof font === 'object') {\n            font.stops.forEach((stop) => {\n                stop[1] = splitAndTrim(stop[1]);\n            });\n            return font;\n\n        } else {\n            throw new Error(\"unexpected font value\");\n        }\n    }\n\n    eachLayer(style, (layer) => {\n        eachLayout(layer, (layout) => {\n            if (layout['text-font']) {\n                layout['text-font'] = migrateFontStack(layout['text-font']);\n            }\n        });\n    });\n\n    // Reverse order of symbol layers. This is an imperfect migration.\n    //\n    // The order of a symbol layer in the layers list affects two things:\n    // - how it is drawn relative to other layers (like oneway arrows below bridges)\n    // - the placement priority compared to other layers\n    //\n    // It's impossible to reverse the placement priority without breaking the draw order\n    // in some cases. This migration only reverses the order of symbol layers that\n    // are above all other types of layers.\n    //\n    // Symbol layers that are at the top of the map preserve their priority.\n    // Symbol layers that are below another type (line, fill) of layer preserve their draw order.\n\n    let firstSymbolLayer = 0;\n    for (let i = style.layers.length - 1; i >= 0; i--) {\n        const layer = style.layers[i];\n        if (layer.type !== 'symbol') {\n            firstSymbolLayer = i + 1;\n            break;\n        }\n    }\n\n    const symbolLayers = style.layers.splice(firstSymbolLayer);\n    symbolLayers.reverse();\n    style.layers = style.layers.concat(symbolLayers);\n\n    return style;\n}\n","// @flow\n\nexport default function (output: any, ...inputs: Array<any>): any {\n    for (const input of inputs) {\n        for (const k in input) {\n            output[k] = input[k];\n        }\n    }\n    return output;\n}\n","// @flow\n\nclass ParsingError extends Error {\n    key: string;\n    message: string;\n    constructor(key: string, message: string) {\n        super(message);\n        this.message = message;\n        this.key = key;\n    }\n}\n\nexport default ParsingError;\n","// @flow\n\nimport type {Expression} from './expression.js';\n\n/**\n * Tracks `let` bindings during expression parsing.\n * @private\n */\nclass Scope {\n    parent: ?Scope;\n    bindings: {[_: string]: Expression};\n    constructor(parent?: Scope, bindings: Array<[string, Expression]> = []) {\n        this.parent = parent;\n        this.bindings = {};\n        for (const [name, expression] of bindings) {\n            this.bindings[name] = expression;\n        }\n    }\n\n    concat(bindings: Array<[string, Expression]>): Scope {\n        return new Scope(this, bindings);\n    }\n\n    get(name: string): Expression {\n        if (this.bindings[name]) { return this.bindings[name]; }\n        if (this.parent) { return this.parent.get(name); }\n        throw new Error(`${name} not found in scope.`);\n    }\n\n    has(name: string): boolean {\n        if (this.bindings[name]) return true;\n        return this.parent ? this.parent.has(name) : false;\n    }\n}\n\nexport default Scope;\n","// @flow\n\nexport type NullTypeT = { kind: 'null' };\nexport type NumberTypeT = { kind: 'number' };\nexport type StringTypeT = { kind: 'string' };\nexport type BooleanTypeT = { kind: 'boolean' };\nexport type ColorTypeT = { kind: 'color' };\nexport type ObjectTypeT = { kind: 'object' };\nexport type ValueTypeT = { kind: 'value' };\nexport type ErrorTypeT = { kind: 'error' };\nexport type CollatorTypeT = { kind: 'collator' };\nexport type FormattedTypeT = { kind: 'formatted' };\nexport type ResolvedImageTypeT = { kind: 'resolvedImage' };\n\nexport type EvaluationKind = 'constant' | 'source' | 'camera' | 'composite';\n\nexport type Type =\n    NullTypeT |\n    NumberTypeT |\n    StringTypeT |\n    BooleanTypeT |\n    ColorTypeT |\n    ObjectTypeT |\n    ValueTypeT |\n    ArrayType | // eslint-disable-line no-use-before-define\n    ErrorTypeT |\n    CollatorTypeT |\n    FormattedTypeT |\n    ResolvedImageTypeT\n\nexport type ArrayType = {\n    kind: 'array',\n    itemType: Type,\n    N: ?number\n}\n\nexport type NativeType = 'number' | 'string' | 'boolean' | 'null' | 'array' | 'object'\n\nexport const NullType = {kind: 'null'};\nexport const NumberType = {kind: 'number'};\nexport const StringType = {kind: 'string'};\nexport const BooleanType = {kind: 'boolean'};\nexport const ColorType = {kind: 'color'};\nexport const ObjectType = {kind: 'object'};\nexport const ValueType = {kind: 'value'};\nexport const ErrorType = {kind: 'error'};\nexport const CollatorType = {kind: 'collator'};\nexport const FormattedType = {kind: 'formatted'};\nexport const ResolvedImageType = {kind: 'resolvedImage'};\n\nexport function array(itemType: Type, N: ?number): ArrayType {\n    return {\n        kind: 'array',\n        itemType,\n        N\n    };\n}\n\nexport function toString(type: Type): string {\n    if (type.kind === 'array') {\n        const itemType = toString(type.itemType);\n        return typeof type.N === 'number' ?\n            `array<${itemType}, ${type.N}>` :\n            type.itemType.kind === 'value' ? 'array' : `array<${itemType}>`;\n    } else {\n        return type.kind;\n    }\n}\n\nconst valueMemberTypes = [\n    NullType,\n    NumberType,\n    StringType,\n    BooleanType,\n    ColorType,\n    FormattedType,\n    ObjectType,\n    array(ValueType),\n    ResolvedImageType\n];\n\n/**\n * Returns null if `t` is a subtype of `expected`; otherwise returns an\n * error message.\n * @private\n */\nexport function checkSubtype(expected: Type, t: Type): ?string {\n    if (t.kind === 'error') {\n        // Error is a subtype of every type\n        return null;\n    } else if (expected.kind === 'array') {\n        if (t.kind === 'array' &&\n            ((t.N === 0 && t.itemType.kind === 'value') || !checkSubtype(expected.itemType, t.itemType)) &&\n            (typeof expected.N !== 'number' || expected.N === t.N)) {\n            return null;\n        }\n    } else if (expected.kind === t.kind) {\n        return null;\n    } else if (expected.kind === 'value') {\n        for (const memberType of valueMemberTypes) {\n            if (!checkSubtype(memberType, t)) {\n                return null;\n            }\n        }\n    }\n\n    return `Expected ${toString(expected)} but found ${toString(t)} instead.`;\n}\n\nexport function isValidType(provided: Type, allowedTypes: Array<Type>): boolean {\n    return allowedTypes.some(t => t.kind === provided.kind);\n}\n\nexport function isValidNativeType(provided: any, allowedTypes: Array<NativeType>): boolean {\n    return allowedTypes.some(t => {\n        if (t === 'null') {\n            return provided === null;\n        } else if (t === 'array') {\n            return Array.isArray(provided);\n        } else if (t === 'object') {\n            return provided && !Array.isArray(provided) && typeof provided === 'object';\n        } else {\n            return t === typeof provided;\n        }\n    });\n}\n","// (c) Dean McNamee <dean@gmail.com>, 2012.\n//\n// https://github.com/deanm/css-color-parser-js\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n\n// http://www.w3.org/TR/css3-color/\nvar kCSSColorTable = {\n  \"transparent\": [0,0,0,0], \"aliceblue\": [240,248,255,1],\n  \"antiquewhite\": [250,235,215,1], \"aqua\": [0,255,255,1],\n  \"aquamarine\": [127,255,212,1], \"azure\": [240,255,255,1],\n  \"beige\": [245,245,220,1], \"bisque\": [255,228,196,1],\n  \"black\": [0,0,0,1], \"blanchedalmond\": [255,235,205,1],\n  \"blue\": [0,0,255,1], \"blueviolet\": [138,43,226,1],\n  \"brown\": [165,42,42,1], \"burlywood\": [222,184,135,1],\n  \"cadetblue\": [95,158,160,1], \"chartreuse\": [127,255,0,1],\n  \"chocolate\": [210,105,30,1], \"coral\": [255,127,80,1],\n  \"cornflowerblue\": [100,149,237,1], \"cornsilk\": [255,248,220,1],\n  \"crimson\": [220,20,60,1], \"cyan\": [0,255,255,1],\n  \"darkblue\": [0,0,139,1], \"darkcyan\": [0,139,139,1],\n  \"darkgoldenrod\": [184,134,11,1], \"darkgray\": [169,169,169,1],\n  \"darkgreen\": [0,100,0,1], \"darkgrey\": [169,169,169,1],\n  \"darkkhaki\": [189,183,107,1], \"darkmagenta\": [139,0,139,1],\n  \"darkolivegreen\": [85,107,47,1], \"darkorange\": [255,140,0,1],\n  \"darkorchid\": [153,50,204,1], \"darkred\": [139,0,0,1],\n  \"darksalmon\": [233,150,122,1], \"darkseagreen\": [143,188,143,1],\n  \"darkslateblue\": [72,61,139,1], \"darkslategray\": [47,79,79,1],\n  \"darkslategrey\": [47,79,79,1], \"darkturquoise\": [0,206,209,1],\n  \"darkviolet\": [148,0,211,1], \"deeppink\": [255,20,147,1],\n  \"deepskyblue\": [0,191,255,1], \"dimgray\": [105,105,105,1],\n  \"dimgrey\": [105,105,105,1], \"dodgerblue\": [30,144,255,1],\n  \"firebrick\": [178,34,34,1], \"floralwhite\": [255,250,240,1],\n  \"forestgreen\": [34,139,34,1], \"fuchsia\": [255,0,255,1],\n  \"gainsboro\": [220,220,220,1], \"ghostwhite\": [248,248,255,1],\n  \"gold\": [255,215,0,1], \"goldenrod\": [218,165,32,1],\n  \"gray\": [128,128,128,1], \"green\": [0,128,0,1],\n  \"greenyellow\": [173,255,47,1], \"grey\": [128,128,128,1],\n  \"honeydew\": [240,255,240,1], \"hotpink\": [255,105,180,1],\n  \"indianred\": [205,92,92,1], \"indigo\": [75,0,130,1],\n  \"ivory\": [255,255,240,1], \"khaki\": [240,230,140,1],\n  \"lavender\": [230,230,250,1], \"lavenderblush\": [255,240,245,1],\n  \"lawngreen\": [124,252,0,1], \"lemonchiffon\": [255,250,205,1],\n  \"lightblue\": [173,216,230,1], \"lightcoral\": [240,128,128,1],\n  \"lightcyan\": [224,255,255,1], \"lightgoldenrodyellow\": [250,250,210,1],\n  \"lightgray\": [211,211,211,1], \"lightgreen\": [144,238,144,1],\n  \"lightgrey\": [211,211,211,1], \"lightpink\": [255,182,193,1],\n  \"lightsalmon\": [255,160,122,1], \"lightseagreen\": [32,178,170,1],\n  \"lightskyblue\": [135,206,250,1], \"lightslategray\": [119,136,153,1],\n  \"lightslategrey\": [119,136,153,1], \"lightsteelblue\": [176,196,222,1],\n  \"lightyellow\": [255,255,224,1], \"lime\": [0,255,0,1],\n  \"limegreen\": [50,205,50,1], \"linen\": [250,240,230,1],\n  \"magenta\": [255,0,255,1], \"maroon\": [128,0,0,1],\n  \"mediumaquamarine\": [102,205,170,1], \"mediumblue\": [0,0,205,1],\n  \"mediumorchid\": [186,85,211,1], \"mediumpurple\": [147,112,219,1],\n  \"mediumseagreen\": [60,179,113,1], \"mediumslateblue\": [123,104,238,1],\n  \"mediumspringgreen\": [0,250,154,1], \"mediumturquoise\": [72,209,204,1],\n  \"mediumvioletred\": [199,21,133,1], \"midnightblue\": [25,25,112,1],\n  \"mintcream\": [245,255,250,1], \"mistyrose\": [255,228,225,1],\n  \"moccasin\": [255,228,181,1], \"navajowhite\": [255,222,173,1],\n  \"navy\": [0,0,128,1], \"oldlace\": [253,245,230,1],\n  \"olive\": [128,128,0,1], \"olivedrab\": [107,142,35,1],\n  \"orange\": [255,165,0,1], \"orangered\": [255,69,0,1],\n  \"orchid\": [218,112,214,1], \"palegoldenrod\": [238,232,170,1],\n  \"palegreen\": [152,251,152,1], \"paleturquoise\": [175,238,238,1],\n  \"palevioletred\": [219,112,147,1], \"papayawhip\": [255,239,213,1],\n  \"peachpuff\": [255,218,185,1], \"peru\": [205,133,63,1],\n  \"pink\": [255,192,203,1], \"plum\": [221,160,221,1],\n  \"powderblue\": [176,224,230,1], \"purple\": [128,0,128,1],\n  \"rebeccapurple\": [102,51,153,1],\n  \"red\": [255,0,0,1], \"rosybrown\": [188,143,143,1],\n  \"royalblue\": [65,105,225,1], \"saddlebrown\": [139,69,19,1],\n  \"salmon\": [250,128,114,1], \"sandybrown\": [244,164,96,1],\n  \"seagreen\": [46,139,87,1], \"seashell\": [255,245,238,1],\n  \"sienna\": [160,82,45,1], \"silver\": [192,192,192,1],\n  \"skyblue\": [135,206,235,1], \"slateblue\": [106,90,205,1],\n  \"slategray\": [112,128,144,1], \"slategrey\": [112,128,144,1],\n  \"snow\": [255,250,250,1], \"springgreen\": [0,255,127,1],\n  \"steelblue\": [70,130,180,1], \"tan\": [210,180,140,1],\n  \"teal\": [0,128,128,1], \"thistle\": [216,191,216,1],\n  \"tomato\": [255,99,71,1], \"turquoise\": [64,224,208,1],\n  \"violet\": [238,130,238,1], \"wheat\": [245,222,179,1],\n  \"white\": [255,255,255,1], \"whitesmoke\": [245,245,245,1],\n  \"yellow\": [255,255,0,1], \"yellowgreen\": [154,205,50,1]}\n\nfunction clamp_css_byte(i) {  // Clamp to integer 0 .. 255.\n  i = Math.round(i);  // Seems to be what Chrome does (vs truncation).\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clamp_css_float(f) {  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parse_css_int(str) {  // int or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_byte(parseFloat(str) / 100 * 255);\n  return clamp_css_byte(parseInt(str));\n}\n\nfunction parse_css_float(str) {  // float or percentage.\n  if (str[str.length - 1] === '%')\n    return clamp_css_float(parseFloat(str) / 100);\n  return clamp_css_float(parseFloat(str));\n}\n\nfunction css_hue_to_rgb(m1, m2, h) {\n  if (h < 0) h += 1;\n  else if (h > 1) h -= 1;\n\n  if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;\n  if (h * 2 < 1) return m2;\n  if (h * 3 < 2) return m1 + (m2 - m1) * (2/3 - h) * 6;\n  return m1;\n}\n\nfunction parseCSSColor(css_str) {\n  // Remove all whitespace, not compliant, but should just be more accepting.\n  var str = css_str.replace(/ /g, '').toLowerCase();\n\n  // Color keywords (and transparent) lookup.\n  if (str in kCSSColorTable) return kCSSColorTable[str].slice();  // dup.\n\n  // #abc and #abc123 syntax.\n  if (str[0] === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xfff)) return null;  // Covers NaN.\n      return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),\n              (iv & 0xf0) | ((iv & 0xf0) >> 4),\n              (iv & 0xf) | ((iv & 0xf) << 4),\n              1];\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.\n      if (!(iv >= 0 && iv <= 0xffffff)) return null;  // Covers NaN.\n      return [(iv & 0xff0000) >> 16,\n              (iv & 0xff00) >> 8,\n              iv & 0xff,\n              1];\n    }\n\n    return null;\n  }\n\n  var op = str.indexOf('('), ep = str.indexOf(')');\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op+1, ep-(op+1)).split(',');\n    var alpha = 1;  // To allow case fallthrough.\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'rgb':\n        if (params.length !== 3) return null;\n        return [parse_css_int(params[0]),\n                parse_css_int(params[1]),\n                parse_css_int(params[2]),\n                alpha];\n      case 'hsla':\n        if (params.length !== 4) return null;\n        alpha = parse_css_float(params.pop());\n        // Fall through.\n      case 'hsl':\n        if (params.length !== 3) return null;\n        var h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;  // 0 .. 1\n        // NOTE(deanm): According to the CSS spec s/l should only be\n        // percentages, but we don't bother and let float or percentage.\n        var s = parse_css_float(params[1]);\n        var l = parse_css_float(params[2]);\n        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n        var m1 = l * 2 - m2;\n        return [clamp_css_byte(css_hue_to_rgb(m1, m2, h+1/3) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h) * 255),\n                clamp_css_byte(css_hue_to_rgb(m1, m2, h-1/3) * 255),\n                alpha];\n      default:\n        return null;\n    }\n  }\n\n  return null;\n}\n\ntry { exports.parseCSSColor = parseCSSColor } catch(e) { }\n","// @flow\n\nimport {parseCSSColor} from 'csscolorparser';\n\n/**\n * An RGBA color value. Create instances from color strings using the static\n * method `Color.parse`. The constructor accepts RGB channel values in the range\n * `[0, 1]`, premultiplied by A.\n *\n * @param {number} r The red channel.\n * @param {number} g The green channel.\n * @param {number} b The blue channel.\n * @param {number} a The alpha channel.\n * @private\n */\nclass Color {\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n\n    constructor(r: number, g: number, b: number, a: number = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n\n    static black: Color;\n    static white: Color;\n    static transparent: Color;\n    static red: Color;\n    static blue: Color;\n\n    /**\n     * Parses valid CSS color strings and returns a `Color` instance.\n     * @returns A `Color` instance, or `undefined` if the input is not a valid color string.\n     */\n    static parse(input?: string | Color | null): Color | void {\n        if (!input) {\n            return undefined;\n        }\n\n        if (input instanceof Color) {\n            return input;\n        }\n\n        if (typeof input !== 'string') {\n            return undefined;\n        }\n\n        const rgba = parseCSSColor(input);\n        if (!rgba) {\n            return undefined;\n        }\n\n        return new Color(\n            rgba[0] / 255 * rgba[3],\n            rgba[1] / 255 * rgba[3],\n            rgba[2] / 255 * rgba[3],\n            rgba[3]\n        );\n    }\n\n    /**\n     * Returns an RGBA string representing the color value.\n     *\n     * @returns An RGBA string.\n     * @example\n     * var purple = new Color.parse('purple');\n     * purple.toString; // = \"rgba(128,0,128,1)\"\n     * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');\n     * translucentGreen.toString(); // = \"rgba(26,207,26,0.73)\"\n     */\n    toString(): string {\n        const [r, g, b, a] = this.toArray();\n        return `rgba(${Math.round(r)},${Math.round(g)},${Math.round(b)},${a})`;\n    }\n\n    /**\n     * Returns an RGBA array of values representing the color, unpremultiplied by A.\n     *\n     * @returns An array of RGBA color values in the range [0, 255].\n     */\n    toArray(): [number, number, number, number] {\n        const {r, g, b, a} = this;\n        return a === 0 ? [0, 0, 0, 0] : [\n            r * 255 / a,\n            g * 255 / a,\n            b * 255 / a,\n            a\n        ];\n    }\n\n    /**\n     * Returns a RGBA array of float values representing the color, unpremultiplied by A.\n     *\n     * @returns An array of RGBA color values in the range [0, 1].\n     */\n    toArray01(): [number, number, number, number] {\n        const {r, g, b, a} = this;\n        return a === 0 ? [0, 0, 0, 0] : [\n            r / a,\n            g / a,\n            b / a,\n            a\n        ];\n    }\n\n    /**\n     * Returns an RGBA array of values representing the color, premultiplied by A.\n     *\n     * @returns An array of RGBA color values in the range [0, 1].\n     */\n    toArray01PremultipliedAlpha(): [number, number, number, number] {\n        const {r, g, b, a} = this;\n        return [\n            r,\n            g,\n            b,\n            a\n        ];\n    }\n}\n\nColor.black = new Color(0, 0, 0, 1);\nColor.white = new Color(1, 1, 1, 1);\nColor.transparent = new Color(0, 0, 0, 0);\nColor.red = new Color(1, 0, 0, 1);\nColor.blue = new Color(0, 0, 1, 1);\n\nexport default Color;\n","// @flow\n\n// Flow type declarations for Intl cribbed from\n// https://github.com/facebook/flow/issues/1270\n\ndeclare var Intl: {\n    Collator: Class<Intl$Collator>\n};\n\ndeclare class Intl$Collator {\n    constructor (\n        locales?: string | string[],\n        options?: CollatorOptions\n    ): Intl$Collator;\n\n    static (\n        locales?: string | string[],\n        options?: CollatorOptions\n    ): Intl$Collator;\n\n    compare (a: string, b: string): number;\n\n    resolvedOptions(): any;\n}\n\ntype CollatorOptions = {\n    localeMatcher?: 'lookup' | 'best fit',\n    usage?: 'sort' | 'search',\n    sensitivity?: 'base' | 'accent' | 'case' | 'variant',\n    ignorePunctuation?: boolean,\n    numeric?: boolean,\n    caseFirst?: 'upper' | 'lower' | 'false'\n}\n\nexport default class Collator {\n    locale: string | null;\n    sensitivity: 'base' | 'accent' | 'case' | 'variant';\n    collator: Intl$Collator;\n\n    constructor(caseSensitive: boolean, diacriticSensitive: boolean, locale: string | null) {\n        if (caseSensitive)\n            this.sensitivity = diacriticSensitive ? 'variant' : 'case';\n        else\n            this.sensitivity = diacriticSensitive ? 'accent' : 'base';\n\n        this.locale = locale;\n        this.collator = new Intl.Collator(this.locale ? this.locale : [],\n            {sensitivity: this.sensitivity, usage: 'search'});\n    }\n\n    compare(lhs: string, rhs: string): number {\n        return this.collator.compare(lhs, rhs);\n    }\n\n    resolvedLocale(): string {\n        // We create a Collator without \"usage: search\" because we don't want\n        // the search options encoded in our result (e.g. \"en-u-co-search\")\n        return new Intl.Collator(this.locale ? this.locale : [])\n            .resolvedOptions().locale;\n    }\n}\n","// @flow\nimport type Color from '../../util/color.js';\nimport type ResolvedImage from '../types/resolved_image.js';\n\nexport class FormattedSection {\n    text: string;\n    image: ResolvedImage | null;\n    scale: number | null;\n    fontStack: string | null;\n    textColor: Color | null;\n\n    constructor(text: string, image: ResolvedImage | null, scale: number | null, fontStack: string | null, textColor: Color | null) {\n        // combine characters so that diacritic marks are not separate code points\n        this.text = text.normalize ? text.normalize() : text;\n        this.image = image;\n        this.scale = scale;\n        this.fontStack = fontStack;\n        this.textColor = textColor;\n    }\n}\n\nexport default class Formatted {\n    sections: Array<FormattedSection>;\n\n    constructor(sections: Array<FormattedSection>) {\n        this.sections = sections;\n    }\n\n    static fromString(unformatted: string): Formatted {\n        return new Formatted([new FormattedSection(unformatted, null, null, null, null)]);\n    }\n\n    isEmpty(): boolean {\n        if (this.sections.length === 0) return true;\n        return !this.sections.some(section => section.text.length !== 0 ||\n                                             (section.image && section.image.name.length !== 0));\n    }\n\n    static factory(text: Formatted | string): Formatted {\n        if (text instanceof Formatted) {\n            return text;\n        } else {\n            return Formatted.fromString(text);\n        }\n    }\n\n    toString(): string {\n        if (this.sections.length === 0) return '';\n        return this.sections.map(section => section.text).join('');\n    }\n\n    serialize(): Array<mixed> {\n        const serialized: Array<mixed> = [\"format\"];\n        for (const section of this.sections) {\n            if (section.image) {\n                serialized.push([\"image\", section.image.name]);\n                continue;\n            }\n            serialized.push(section.text);\n            const options: { [key: string]: mixed } = {};\n            if (section.fontStack) {\n                options[\"text-font\"] = [\"literal\", section.fontStack.split(',')];\n            }\n            if (section.scale) {\n                options[\"font-scale\"] = section.scale;\n            }\n            if (section.textColor) {\n                options[\"text-color\"] = ([\"rgba\"]: Array<mixed>).concat(section.textColor.toArray());\n            }\n            serialized.push(options);\n        }\n        return serialized;\n    }\n}\n","// @flow\n\nexport type ResolvedImageOptions = {\n    name: string,\n    available: boolean\n};\n\nexport default class ResolvedImage {\n    name: string;\n    available: boolean;\n\n    constructor(options: ResolvedImageOptions) {\n        this.name = options.name;\n        this.available = options.available;\n    }\n\n    toString(): string {\n        return this.name;\n    }\n\n    static fromString(name: string): ResolvedImage | null {\n        if (!name) return null; // treat empty values as no image\n        return new ResolvedImage({name, available: false});\n    }\n\n    serialize(): Array<string> {\n        return [\"image\", this.name];\n    }\n}\n","// @flow\n\nimport assert from 'assert';\n\nimport Color from '../util/color.js';\nimport Collator from './types/collator.js';\nimport Formatted from './types/formatted.js';\nimport ResolvedImage from './types/resolved_image.js';\nimport {NullType, NumberType, StringType, BooleanType, ColorType, ObjectType, ValueType, CollatorType, FormattedType, ResolvedImageType, array} from './types.js';\n\nimport type {Type} from './types.js';\n\nexport function validateRGBA(r: mixed, g: mixed, b: mixed, a?: mixed): string | null {\n    if (!(\n        typeof r === 'number' && r >= 0 && r <= 255 &&\n        typeof g === 'number' && g >= 0 && g <= 255 &&\n        typeof b === 'number' && b >= 0 && b <= 255\n    )) {\n        const value = typeof a === 'number' ? [r, g, b, a] : [r, g, b];\n        return `Invalid rgba value [${value.join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`;\n    }\n\n    if (!(\n        typeof a === 'undefined' || (typeof a === 'number' && a >= 0 && a <= 1)\n    )) {\n        return `Invalid rgba value [${[r, g, b, a].join(', ')}]: 'a' must be between 0 and 1.`;\n    }\n\n    return null;\n}\n\nexport type Value = null | string | boolean | number | Color | Collator | Formatted | ResolvedImage | $ReadOnlyArray<Value> | { +[string]: Value }\n\nexport function isValue(mixed: mixed): boolean {\n    if (mixed === null) {\n        return true;\n    } else if (typeof mixed === 'string') {\n        return true;\n    } else if (typeof mixed === 'boolean') {\n        return true;\n    } else if (typeof mixed === 'number') {\n        return true;\n    } else if (mixed instanceof Color) {\n        return true;\n    } else if (mixed instanceof Collator) {\n        return true;\n    } else if (mixed instanceof Formatted) {\n        return true;\n    } else if (mixed instanceof ResolvedImage) {\n        return true;\n    } else if (Array.isArray(mixed)) {\n        for (const item of mixed) {\n            if (!isValue(item)) {\n                return false;\n            }\n        }\n        return true;\n    } else if (typeof mixed === 'object') {\n        for (const key in mixed) {\n            if (!isValue(mixed[key])) {\n                return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function typeOf(value: Value): Type {\n    if (value === null) {\n        return NullType;\n    } else if (typeof value === 'string') {\n        return StringType;\n    } else if (typeof value === 'boolean') {\n        return BooleanType;\n    } else if (typeof value === 'number') {\n        return NumberType;\n    } else if (value instanceof Color) {\n        return ColorType;\n    } else if (value instanceof Collator) {\n        return CollatorType;\n    } else if (value instanceof Formatted) {\n        return FormattedType;\n    } else if (value instanceof ResolvedImage) {\n        return ResolvedImageType;\n    } else if (Array.isArray(value)) {\n        const length = value.length;\n        let itemType: Type | typeof undefined;\n\n        for (const item of value) {\n            const t = typeOf(item);\n            if (!itemType) {\n                itemType = t;\n            } else if (itemType === t) {\n                continue;\n            } else {\n                itemType = ValueType;\n                break;\n            }\n        }\n\n        return array(itemType || ValueType, length);\n    } else {\n        assert(typeof value === 'object');\n        return ObjectType;\n    }\n}\n\nexport function toString(value: Value): string {\n    const type = typeof value;\n    if (value === null) {\n        return '';\n    } else if (type === 'string' || type === 'number' || type === 'boolean') {\n        return String(value);\n    } else if (value instanceof Color || value instanceof Formatted || value instanceof ResolvedImage) {\n        return value.toString();\n    } else {\n        return JSON.stringify(value);\n    }\n}\n\nexport {Color, Collator};\n","// @flow\n\nimport assert from 'assert';\nimport {isValue, typeOf, Color} from '../values.js';\nimport Formatted from '../types/formatted.js';\n\nimport type {Type} from '../types.js';\nimport type {Value}  from '../values.js';\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\n\nclass Literal implements Expression {\n    type: Type;\n    value: Value;\n\n    constructor(type: Type, value: Value) {\n        this.type = type;\n        this.value = value;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): void | Literal {\n        if (args.length !== 2)\n            return context.error(`'literal' expression requires exactly one argument, but found ${args.length - 1} instead.`);\n\n        if (!isValue(args[1]))\n            return context.error(`invalid value`);\n\n        const value = (args[1]: any);\n        let type = typeOf(value);\n\n        // special case: infer the item type if possible for zero-length arrays\n        const expected = context.expectedType;\n        if (\n            type.kind === 'array' &&\n            type.N === 0 &&\n            expected &&\n            expected.kind === 'array' &&\n            (typeof expected.N !== 'number' || expected.N === 0)\n        ) {\n            type = expected;\n        }\n\n        return new Literal(type, value);\n    }\n\n    evaluate(): Value {\n        return this.value;\n    }\n\n    eachChild() {}\n\n    outputDefined(): boolean {\n        return true;\n    }\n\n    serialize(): SerializedExpression {\n        if (this.type.kind === 'array' || this.type.kind === 'object') {\n            return [\"literal\", this.value];\n        } else if (this.value instanceof Color) {\n            // Constant-folding can generate Literal expressions that you\n            // couldn't actually generate with a \"literal\" expression,\n            // so we have to implement an equivalent serialization here\n            return [\"rgba\"].concat(this.value.toArray());\n        } else if (this.value instanceof Formatted) {\n            // Same as Color\n            return this.value.serialize();\n        } else {\n            assert(this.value === null ||\n                typeof this.value === 'string' ||\n                typeof this.value === 'number' ||\n                typeof this.value === 'boolean');\n            return (this.value: any);\n        }\n    }\n}\n\nexport default Literal;\n","// @flow\n\nclass RuntimeError {\n    name: string;\n    message: string;\n\n    constructor(message: string) {\n        this.name = 'ExpressionEvaluationError';\n        this.message = message;\n    }\n\n    toJSON(): string {\n        return this.message;\n    }\n}\n\nexport default RuntimeError;\n","// @flow\n\nimport assert from 'assert';\n\nimport {\n    ObjectType,\n    ValueType,\n    StringType,\n    NumberType,\n    BooleanType,\n    checkSubtype,\n    toString,\n    array\n} from '../types.js';\nimport RuntimeError from '../runtime_error.js';\nimport {typeOf} from '../values.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nconst types = {\n    string: StringType,\n    number: NumberType,\n    boolean: BooleanType,\n    object: ObjectType\n};\n\nclass Assertion implements Expression {\n    type: Type;\n    args: Array<Expression>;\n\n    constructor(type: Type, args: Array<Expression>) {\n        this.type = type;\n        this.args = args;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        if (args.length < 2)\n            return context.error(`Expected at least one argument.`);\n\n        let i = 1;\n        let type;\n\n        const name: string = (args[0]: any);\n        if (name === 'array') {\n            let itemType;\n            if (args.length > 2) {\n                const type = args[1];\n                if (typeof type !== 'string' || !(type in types) || type === 'object')\n                    return context.error('The item type argument of \"array\" must be one of string, number, boolean', 1);\n                itemType = types[type];\n                i++;\n            } else {\n                itemType = ValueType;\n            }\n\n            let N;\n            if (args.length > 3) {\n                if (args[2] !== null &&\n                    (typeof args[2] !== 'number' ||\n                        args[2] < 0 ||\n                        args[2] !== Math.floor(args[2]))\n                ) {\n                    return context.error('The length argument to \"array\" must be a positive integer literal', 2);\n                }\n                N = args[2];\n                i++;\n            }\n\n            type = array(itemType, N);\n        } else {\n            assert(types[name], name);\n            type = types[name];\n        }\n\n        const parsed = [];\n        for (; i < args.length; i++) {\n            const input = context.parse(args[i], i, ValueType);\n            if (!input) return null;\n            parsed.push(input);\n        }\n\n        return new Assertion(type, parsed);\n    }\n\n    evaluate(ctx: EvaluationContext): any | null {\n        for (let i = 0; i < this.args.length; i++) {\n            const value = this.args[i].evaluate(ctx);\n            const error = checkSubtype(this.type, typeOf(value));\n            if (!error) {\n                return value;\n            } else if (i === this.args.length - 1) {\n                throw new RuntimeError(`Expected value to be of type ${toString(this.type)}, but found ${toString(typeOf(value))} instead.`);\n            }\n        }\n\n        assert(false);\n        return null;\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        this.args.forEach(fn);\n    }\n\n    outputDefined(): boolean {\n        return this.args.every(arg => arg.outputDefined());\n    }\n\n    serialize(): SerializedExpression {\n        const type = this.type;\n        const serialized = [type.kind];\n        if (type.kind === 'array') {\n            const itemType = type.itemType;\n            if (itemType.kind === 'string' ||\n                itemType.kind === 'number' ||\n                itemType.kind === 'boolean') {\n                serialized.push(itemType.kind);\n                const N = type.N;\n                if (typeof N === 'number' || this.args.length > 1) {\n                    serialized.push(N);\n                }\n            }\n        }\n        return serialized.concat(this.args.map(arg => arg.serialize()));\n    }\n}\n\nexport default Assertion;\n","// @flow\n\nimport {NumberType, ValueType, FormattedType, array, StringType, ColorType, ResolvedImageType} from '../types.js';\nimport Formatted, {FormattedSection} from '../types/formatted.js';\nimport {toString, typeOf} from '../values.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type {Type} from '../types.js';\n\ntype FormattedSectionExpression = {\n    // Content of a section may be Image expression or other\n    // type of expression that is coercable to 'string'.\n    content: Expression,\n    scale: Expression | null;\n    font: Expression | null;\n    textColor: Expression | null;\n}\n\nexport default class FormatExpression implements Expression {\n    type: Type;\n    sections: Array<FormattedSectionExpression>;\n\n    constructor(sections: Array<FormattedSectionExpression>) {\n        this.type = FormattedType;\n        this.sections = sections;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        if (args.length < 2) {\n            return context.error(`Expected at least one argument.`);\n        }\n\n        const firstArg = args[1];\n        if (!Array.isArray(firstArg) && typeof firstArg === 'object')  {\n            return context.error(`First argument must be an image or text section.`);\n        }\n\n        const sections: Array<FormattedSectionExpression> = [];\n        let nextTokenMayBeObject = false;\n        for (let i = 1; i <= args.length - 1; ++i) {\n            const arg = (args[i]: any);\n\n            if (nextTokenMayBeObject && typeof arg === \"object\" && !Array.isArray(arg)) {\n                nextTokenMayBeObject = false;\n\n                let scale = null;\n                if (arg['font-scale']) {\n                    scale = context.parse(arg['font-scale'], 1, NumberType);\n                    if (!scale) return null;\n                }\n\n                let font = null;\n                if (arg['text-font']) {\n                    font = context.parse(arg['text-font'], 1, array(StringType));\n                    if (!font) return null;\n                }\n\n                let textColor = null;\n                if (arg['text-color']) {\n                    textColor = context.parse(arg['text-color'], 1, ColorType);\n                    if (!textColor) return null;\n                }\n\n                const lastExpression = sections[sections.length - 1];\n                lastExpression.scale = scale;\n                lastExpression.font = font;\n                lastExpression.textColor = textColor;\n            } else {\n                const content = context.parse(args[i], 1, ValueType);\n                if (!content) return null;\n\n                const kind = content.type.kind;\n                if (kind !== 'string' && kind !== 'value' && kind !== 'null' && kind !== 'resolvedImage')\n                    return context.error(`Formatted text type must be 'string', 'value', 'image' or 'null'.`);\n\n                nextTokenMayBeObject = true;\n                sections.push({content, scale: null, font: null, textColor: null});\n            }\n        }\n\n        return new FormatExpression(sections);\n    }\n\n    evaluate(ctx: EvaluationContext): Formatted {\n        const evaluateSection = section => {\n            const evaluatedContent = section.content.evaluate(ctx);\n            if (typeOf(evaluatedContent) === ResolvedImageType) {\n                return new FormattedSection('', evaluatedContent, null, null, null);\n            }\n\n            return new FormattedSection(\n                    toString(evaluatedContent),\n                    null,\n                    section.scale ? section.scale.evaluate(ctx) : null,\n                    section.font ? section.font.evaluate(ctx).join(',') : null,\n                    section.textColor ? section.textColor.evaluate(ctx) : null\n            );\n        };\n\n        return new Formatted(this.sections.map(evaluateSection));\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        for (const section of this.sections) {\n            fn(section.content);\n            if (section.scale) {\n                fn(section.scale);\n            }\n            if (section.font) {\n                fn(section.font);\n            }\n            if (section.textColor) {\n                fn(section.textColor);\n            }\n        }\n    }\n\n    outputDefined(): boolean {\n        // Technically the combinatoric set of all children\n        // Usually, this.text will be undefined anyway\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"format\"];\n        for (const section of this.sections) {\n            serialized.push(section.content.serialize());\n            const options = {};\n            if (section.scale) {\n                options['font-scale'] = section.scale.serialize();\n            }\n            if (section.font) {\n                options['text-font'] = section.font.serialize();\n            }\n            if (section.textColor) {\n                options['text-color'] = section.textColor.serialize();\n            }\n            serialized.push(options);\n        }\n        return serialized;\n    }\n}\n","// @flow\n\nimport {ResolvedImageType, StringType} from '../types.js';\nimport ResolvedImage from '../types/resolved_image.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type {Type} from '../types.js';\n\nexport default class ImageExpression implements Expression {\n    type: Type;\n    input: Expression;\n\n    constructor(input: Expression) {\n        this.type = ResolvedImageType;\n        this.input = input;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        if (args.length !== 2) {\n            return context.error(`Expected two arguments.`);\n        }\n\n        const name = context.parse(args[1], 1, StringType);\n        if (!name) return context.error(`No image name provided.`);\n\n        return new ImageExpression(name);\n    }\n\n    evaluate(ctx: EvaluationContext): null | ResolvedImage {\n        const evaluatedImageName = this.input.evaluate(ctx);\n\n        const value = ResolvedImage.fromString(evaluatedImageName);\n        if (value && ctx.availableImages) value.available = ctx.availableImages.indexOf(evaluatedImageName) > -1;\n\n        return value;\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.input);\n    }\n\n    outputDefined(): boolean {\n        // The output of image is determined by the list of available images in the evaluation context\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        return [\"image\", this.input.serialize()];\n    }\n}\n","// @flow\n\nimport assert from 'assert';\n\nimport {BooleanType, ColorType, NumberType, StringType, ValueType} from '../types.js';\nimport {Color, toString as valueToString, validateRGBA} from '../values.js';\nimport RuntimeError from '../runtime_error.js';\nimport Formatted from '../types/formatted.js';\nimport FormatExpression from '../definitions/format.js';\nimport ImageExpression from '../definitions/image.js';\nimport ResolvedImage from '../types/resolved_image.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nconst types = {\n    'to-boolean': BooleanType,\n    'to-color': ColorType,\n    'to-number': NumberType,\n    'to-string': StringType\n};\n\n/**\n * Special form for error-coalescing coercion expressions \"to-number\",\n * \"to-color\".  Since these coercions can fail at runtime, they accept multiple\n * arguments, only evaluating one at a time until one succeeds.\n *\n * @private\n */\nclass Coercion implements Expression {\n    type: Type;\n    args: Array<Expression>;\n\n    constructor(type: Type, args: Array<Expression>) {\n        this.type = type;\n        this.args = args;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        if (args.length < 2)\n            return context.error(`Expected at least one argument.`);\n\n        const name: string = (args[0]: any);\n        assert(types[name], name);\n\n        if ((name === 'to-boolean' || name === 'to-string') && args.length !== 2)\n            return context.error(`Expected one argument.`);\n\n        const type = types[name];\n\n        const parsed = [];\n        for (let i = 1; i < args.length; i++) {\n            const input = context.parse(args[i], i, ValueType);\n            if (!input) return null;\n            parsed.push(input);\n        }\n\n        return new Coercion(type, parsed);\n    }\n\n    evaluate(ctx: EvaluationContext): null | boolean | number | string | Color | Formatted | ResolvedImage {\n        if (this.type.kind === 'boolean') {\n            return Boolean(this.args[0].evaluate(ctx));\n        } else if (this.type.kind === 'color') {\n            let input;\n            let error;\n            for (const arg of this.args) {\n                input = arg.evaluate(ctx);\n                error = null;\n                if (input instanceof Color) {\n                    return input;\n                } else if (typeof input === 'string') {\n                    const c = ctx.parseColor(input);\n                    if (c) return c;\n                } else if (Array.isArray(input)) {\n                    if (input.length < 3 || input.length > 4) {\n                        error = `Invalid rbga value ${JSON.stringify(input)}: expected an array containing either three or four numeric values.`;\n                    } else {\n                        error = validateRGBA(input[0], input[1], input[2], input[3]);\n                    }\n                    if (!error) {\n                        return new Color((input[0]: any) / 255, (input[1]: any) / 255, (input[2]: any) / 255, (input[3]: any));\n                    }\n                }\n            }\n            throw new RuntimeError(error || `Could not parse color from value '${typeof input === 'string' ? input : String(JSON.stringify(input))}'`);\n        } else if (this.type.kind === 'number') {\n            let value = null;\n            for (const arg of this.args) {\n                value = arg.evaluate(ctx);\n                if (value === null) return 0;\n                const num = Number(value);\n                if (isNaN(num)) continue;\n                return num;\n            }\n            throw new RuntimeError(`Could not convert ${JSON.stringify(value)} to number.`);\n        } else if (this.type.kind === 'formatted') {\n            // There is no explicit 'to-formatted' but this coercion can be implicitly\n            // created by properties that expect the 'formatted' type.\n            return Formatted.fromString(valueToString(this.args[0].evaluate(ctx)));\n        } else if (this.type.kind === 'resolvedImage') {\n            return ResolvedImage.fromString(valueToString(this.args[0].evaluate(ctx)));\n        } else {\n            return valueToString(this.args[0].evaluate(ctx));\n        }\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        this.args.forEach(fn);\n    }\n\n    outputDefined(): boolean {\n        return this.args.every(arg => arg.outputDefined());\n    }\n\n    serialize(): SerializedExpression {\n        if (this.type.kind === 'formatted') {\n            return new FormatExpression([{content: this.args[0], scale: null, font: null, textColor: null}]).serialize();\n        }\n\n        if (this.type.kind === 'resolvedImage') {\n            return new ImageExpression(this.args[0]).serialize();\n        }\n\n        const serialized = [`to-${this.type.kind}`];\n        this.eachChild(child => { serialized.push(child.serialize()); });\n        return serialized;\n    }\n}\n\nexport default Coercion;\n","// @flow\n\nimport {Color} from './values.js';\n\nimport type Point from '@mapbox/point-geometry';\nimport type {FormattedSection} from './types/formatted.js';\nimport type {GlobalProperties, Feature, FeatureState} from './index.js';\nimport type {CanonicalTileID} from '../../source/tile_id.js';\nimport type {FeatureDistanceData} from '../feature_filter/index.js';\n\nconst geometryTypes = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nclass EvaluationContext {\n    globals: GlobalProperties;\n    feature: ?Feature;\n    featureState: ?FeatureState;\n    formattedSection: ?FormattedSection;\n    availableImages: ?Array<string>;\n    canonical: null | CanonicalTileID;\n    featureTileCoord: ?Point;\n    featureDistanceData: ?FeatureDistanceData;\n\n    _parseColorCache: {[_: string]: ?Color};\n\n    constructor() {\n        this.globals = (null: any);\n        this.feature = null;\n        this.featureState = null;\n        this.formattedSection = null;\n        this._parseColorCache = {};\n        this.availableImages = null;\n        this.canonical = null;\n        this.featureTileCoord = null;\n        this.featureDistanceData = null;\n    }\n\n    id(): number | null {\n        return this.feature && this.feature.id !== undefined ? this.feature.id : null;\n    }\n\n    geometryType(): null | string {\n        return this.feature ? typeof this.feature.type === 'number' ? geometryTypes[this.feature.type] : this.feature.type : null;\n    }\n\n    geometry(): ?Array<Array<Point>> {\n        return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;\n    }\n\n    canonicalID(): null | CanonicalTileID {\n        return this.canonical;\n    }\n\n    properties(): {[string]: any} {\n        return (this.feature && this.feature.properties) || {};\n    }\n\n    distanceFromCenter(): number {\n        if (this.featureTileCoord && this.featureDistanceData) {\n\n            const c = this.featureDistanceData.center;\n            const scale = this.featureDistanceData.scale;\n            const {x, y} = this.featureTileCoord;\n\n            // Calculate the distance vector `d` (left handed)\n            const dX = x * scale - c[0];\n            const dY = y * scale - c[1];\n\n            // The bearing vector `b` (left handed)\n            const bX = this.featureDistanceData.bearing[0];\n            const bY = this.featureDistanceData.bearing[1];\n\n            // Distance is calculated as `dot(d, v)`\n            const dist = (bX * dX + bY * dY);\n            return dist;\n        }\n\n        return 0;\n    }\n\n    parseColor(input: string): ?Color {\n        let cached = this._parseColorCache[input];\n        if (!cached) {\n            cached = this._parseColorCache[input] = Color.parse(input);\n        }\n        return cached;\n    }\n}\n\nexport default EvaluationContext;\n","// @flow\n\nimport {toString} from './types.js';\n\nimport ParsingContext from './parsing_context.js';\nimport EvaluationContext from './evaluation_context.js';\nimport assert from 'assert';\n\nimport type {Expression, ExpressionRegistry} from './expression.js';\nimport type {Type} from './types.js';\nimport type {Value} from './values.js';\n\nexport type Varargs = {| type: Type |};\ntype Signature = Array<Type> | Varargs;\ntype Evaluate = (EvaluationContext, Array<Expression>) => Value;\ntype Definition = [Type, Signature, Evaluate] |\n    {|type: Type, overloads: Array<[Signature, Evaluate]>|};\n\nclass CompoundExpression implements Expression {\n    name: string;\n    type: Type;\n    _evaluate: Evaluate;\n    args: Array<Expression>;\n\n    static definitions: {[_: string]: Definition };\n\n    constructor(name: string, type: Type, evaluate: Evaluate, args: Array<Expression>) {\n        this.name = name;\n        this.type = type;\n        this._evaluate = evaluate;\n        this.args = args;\n    }\n\n    evaluate(ctx: EvaluationContext): Value {\n        return this._evaluate(ctx, this.args);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        this.args.forEach(fn);\n    }\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): Array<mixed> {\n        return [this.name].concat(this.args.map(arg => arg.serialize()));\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        const op: string = (args[0]: any);\n        const definition = CompoundExpression.definitions[op];\n        if (!definition) {\n            return context.error(`Unknown expression \"${op}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        }\n\n        // Now check argument types against each signature\n        const type = Array.isArray(definition) ?\n            definition[0] : definition.type;\n\n        const availableOverloads = Array.isArray(definition) ?\n            [[definition[1], definition[2]]] :\n            definition.overloads;\n\n        const overloads = availableOverloads.filter(([signature]) => (\n            !Array.isArray(signature) || // varags\n            signature.length === args.length - 1 // correct param count\n        ));\n\n        let signatureContext: ParsingContext = (null: any);\n\n        for (const [params, evaluate] of overloads) {\n            // Use a fresh context for each attempted signature so that, if\n            // we eventually succeed, we haven't polluted `context.errors`.\n            signatureContext = new ParsingContext(context.registry, context.path, null, context.scope);\n\n            // First parse all the args, potentially coercing to the\n            // types expected by this overload.\n            const parsedArgs: Array<Expression> = [];\n            let argParseFailed = false;\n            for (let i = 1; i < args.length; i++) {\n                const arg = args[i];\n                const expectedType = Array.isArray(params) ?\n                    params[i - 1] :\n                    params.type;\n\n                const parsed = signatureContext.parse(arg, 1 + parsedArgs.length, expectedType);\n                if (!parsed) {\n                    argParseFailed = true;\n                    break;\n                }\n                parsedArgs.push(parsed);\n            }\n            if (argParseFailed) {\n                // Couldn't coerce args of this overload to expected type, move\n                // on to next one.\n                continue;\n            }\n\n            if (Array.isArray(params)) {\n                if (params.length !== parsedArgs.length) {\n                    signatureContext.error(`Expected ${params.length} arguments, but found ${parsedArgs.length} instead.`);\n                    continue;\n                }\n            }\n\n            for (let i = 0; i < parsedArgs.length; i++) {\n                const expected = Array.isArray(params) ? params[i] : params.type;\n                const arg = parsedArgs[i];\n                signatureContext.concat(i + 1).checkSubtype(expected, arg.type);\n            }\n\n            if (signatureContext.errors.length === 0) {\n                return new CompoundExpression(op, type, evaluate, parsedArgs);\n            }\n        }\n\n        assert(!signatureContext || signatureContext.errors.length > 0);\n\n        if (overloads.length === 1) {\n            context.errors.push(...signatureContext.errors);\n        } else {\n            const expected = overloads.length ? overloads : availableOverloads;\n            const signatures = expected\n                .map(([params]) => stringifySignature(params))\n                .join(' | ');\n\n            const actualTypes = [];\n            // For error message, re-parse arguments without trying to\n            // apply any coercions\n            for (let i = 1; i < args.length; i++) {\n                const parsed = context.parse(args[i], 1 + actualTypes.length);\n                if (!parsed) return null;\n                actualTypes.push(toString(parsed.type));\n            }\n            context.error(`Expected arguments of type ${signatures}, but found (${actualTypes.join(', ')}) instead.`);\n        }\n\n        return null;\n    }\n\n    static register(\n        registry: ExpressionRegistry,\n        definitions: {[_: string]: Definition }\n    ) {\n        assert(!CompoundExpression.definitions);\n        CompoundExpression.definitions = definitions;\n        for (const name in definitions) {\n            registry[name] = CompoundExpression;\n        }\n    }\n}\n\nfunction stringifySignature(signature: Signature): string {\n    if (Array.isArray(signature)) {\n        return `(${signature.map(toString).join(', ')})`;\n    } else {\n        return `(${toString(signature.type)}...)`;\n    }\n}\n\nexport default CompoundExpression;\n","// @flow\n\nimport {StringType, BooleanType, CollatorType} from '../types.js';\nimport Collator from '../types/collator.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type {Type} from '../types.js';\n\nexport default class CollatorExpression implements Expression {\n    type: Type;\n    caseSensitive: Expression;\n    diacriticSensitive: Expression;\n    locale: Expression | null;\n\n    constructor(caseSensitive: Expression, diacriticSensitive: Expression, locale: Expression | null) {\n        this.type = CollatorType;\n        this.locale = locale;\n        this.caseSensitive = caseSensitive;\n        this.diacriticSensitive = diacriticSensitive;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        if (args.length !== 2)\n            return context.error(`Expected one argument.`);\n\n        const options = (args[1]: any);\n        if (typeof options !== \"object\" || Array.isArray(options))\n            return context.error(`Collator options argument must be an object.`);\n\n        const caseSensitive = context.parse(\n            options['case-sensitive'] === undefined ? false : options['case-sensitive'], 1, BooleanType);\n        if (!caseSensitive) return null;\n\n        const diacriticSensitive = context.parse(\n            options['diacritic-sensitive'] === undefined ? false : options['diacritic-sensitive'], 1, BooleanType);\n        if (!diacriticSensitive) return null;\n\n        let locale = null;\n        if (options['locale']) {\n            locale = context.parse(options['locale'], 1, StringType);\n            if (!locale) return null;\n        }\n\n        return new CollatorExpression(caseSensitive, diacriticSensitive, locale);\n    }\n\n    evaluate(ctx: EvaluationContext): Collator {\n        return new Collator(this.caseSensitive.evaluate(ctx), this.diacriticSensitive.evaluate(ctx), this.locale ? this.locale.evaluate(ctx) : null);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.caseSensitive);\n        fn(this.diacriticSensitive);\n        if (this.locale) {\n            fn(this.locale);\n        }\n    }\n\n    outputDefined(): boolean {\n        // Technically the set of possible outputs is the combinatoric set of Collators produced\n        // by all possible outputs of locale/caseSensitive/diacriticSensitive\n        // But for the primary use of Collators in comparison operators, we ignore the Collator's\n        // possible outputs anyway, so we can get away with leaving this false for now.\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        const options = {};\n        options['case-sensitive'] = this.caseSensitive.serialize();\n        options['diacritic-sensitive'] = this.diacriticSensitive.serialize();\n        if (this.locale) {\n            options['locale'] = this.locale.serialize();\n        }\n        return [\"collator\", options];\n    }\n}\n","// @flow\n\nimport {isValue} from '../values.js';\nimport type {Type} from '../types.js';\nimport {BooleanType} from '../types.js';\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {GeoJSON, GeoJSONPolygon, GeoJSONMultiPolygon} from '@mapbox/geojson-types';\nimport type {CanonicalTileID} from '../../../source/tile_id.js';\n\ntype GeoJSONPolygons =| GeoJSONPolygon | GeoJSONMultiPolygon;\n\n// minX, minY, maxX, maxY\ntype BBox = [number, number, number, number];\nconst EXTENT = 8192;\n\nfunction updateBBox(bbox: BBox, coord: [number, number]) {\n    bbox[0] = Math.min(bbox[0], coord[0]);\n    bbox[1] = Math.min(bbox[1], coord[1]);\n    bbox[2] = Math.max(bbox[2], coord[0]);\n    bbox[3] = Math.max(bbox[3], coord[1]);\n}\n\nfunction mercatorXfromLng(lng: number) {\n    return (180 + lng) / 360;\n}\n\nfunction mercatorYfromLat(lat: number) {\n    return (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360)))) / 360;\n}\n\nfunction boxWithinBox(bbox1: BBox, bbox2: BBox) {\n    if (bbox1[0] <= bbox2[0]) return false;\n    if (bbox1[2] >= bbox2[2]) return false;\n    if (bbox1[1] <= bbox2[1]) return false;\n    if (bbox1[3] >= bbox2[3]) return false;\n    return true;\n}\n\nfunction getTileCoordinates(p, canonical: CanonicalTileID) {\n    const x = mercatorXfromLng(p[0]);\n    const y = mercatorYfromLat(p[1]);\n    const tilesAtZoom = Math.pow(2, canonical.z);\n    return [Math.round(x * tilesAtZoom * EXTENT), Math.round(y * tilesAtZoom * EXTENT)];\n}\n\nfunction onBoundary(p, p1, p2) {\n    const x1 = p[0] - p1[0];\n    const y1 = p[1] - p1[1];\n    const x2 = p[0] - p2[0];\n    const y2 = p[1] - p2[1];\n    return (x1 * y2 - x2 * y1 === 0) && (x1 * x2 <= 0) && (y1 * y2 <= 0);\n}\n\nfunction rayIntersect(p, p1, p2) {\n    return ((p1[1] > p[1]) !== (p2[1] > p[1])) && (p[0] < (p2[0] - p1[0]) * (p[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]);\n}\n\n// ray casting algorithm for detecting if point is in polygon\nfunction pointWithinPolygon(point, rings) {\n    let inside = false;\n    for (let i = 0, len = rings.length; i < len; i++) {\n        const ring = rings[i];\n        for (let j = 0, len2 = ring.length; j < len2 - 1; j++) {\n            if (onBoundary(point, ring[j], ring[j + 1])) return false;\n            if (rayIntersect(point, ring[j], ring[j + 1])) inside = !inside;\n        }\n    }\n    return inside;\n}\n\nfunction pointWithinPolygons(point, polygons) {\n    for (let i = 0; i < polygons.length; i++) {\n        if (pointWithinPolygon(point, polygons[i])) return true;\n    }\n    return false;\n}\n\nfunction perp(v1, v2) {\n    return (v1[0] * v2[1] - v1[1] * v2[0]);\n}\n\n// check if p1 and p2 are in different sides of line segment q1->q2\nfunction  twoSided(p1, p2, q1, q2) {\n    // q1->p1 (x1, y1), q1->p2 (x2, y2), q1->q2 (x3, y3)\n    const x1 = p1[0] - q1[0];\n    const y1 = p1[1] - q1[1];\n    const x2 = p2[0] - q1[0];\n    const y2 = p2[1] - q1[1];\n    const x3 = q2[0] - q1[0];\n    const y3 = q2[1] - q1[1];\n    const det1 = (x1 * y3 - x3 * y1);\n    const det2 =  (x2 * y3 - x3 * y2);\n    if ((det1 > 0 && det2 < 0) || (det1 < 0 && det2 > 0)) return true;\n    return false;\n}\n// a, b are end points for line segment1, c and d are end points for line segment2\nfunction lineIntersectLine(a, b, c, d) {\n    // check if two segments are parallel or not\n    // precondition is end point a, b is inside polygon, if line a->b is\n    // parallel to polygon edge c->d, then a->b won't intersect with c->d\n    const vectorP = [b[0] - a[0], b[1] - a[1]];\n    const vectorQ = [d[0] - c[0], d[1] - c[1]];\n    if (perp(vectorQ, vectorP) === 0) return false;\n\n    // If lines are intersecting with each other, the relative location should be:\n    // a and b lie in different sides of segment c->d\n    // c and d lie in different sides of segment a->b\n    if (twoSided(a, b, c, d) && twoSided(c, d, a, b)) return true;\n    return false;\n}\n\nfunction lineIntersectPolygon(p1, p2, polygon) {\n    for (const ring of polygon) {\n        // loop through every edge of the ring\n        for (let j = 0; j < ring.length - 1; ++j) {\n            if (lineIntersectLine(p1, p2, ring[j], ring[j + 1])) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction lineStringWithinPolygon(line, polygon) {\n    // First, check if geometry points of line segments are all inside polygon\n    for (let i = 0; i < line.length; ++i) {\n        if (!pointWithinPolygon(line[i], polygon)) {\n            return false;\n        }\n    }\n\n    // Second, check if there is line segment intersecting polygon edge\n    for (let i = 0; i < line.length - 1; ++i) {\n        if (lineIntersectPolygon(line[i], line[i + 1], polygon)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction lineStringWithinPolygons(line, polygons) {\n    for (let i = 0; i < polygons.length; i++) {\n        if (lineStringWithinPolygon(line, polygons[i])) return true;\n    }\n    return false;\n}\n\nfunction getTilePolygon(coordinates, bbox: BBox, canonical: CanonicalTileID) {\n    const polygon = [];\n    for (let i = 0; i < coordinates.length; i++) {\n        const ring = [];\n        for (let j = 0; j < coordinates[i].length; j++) {\n            const coord = getTileCoordinates(coordinates[i][j], canonical);\n            updateBBox(bbox, coord);\n            ring.push(coord);\n        }\n        polygon.push(ring);\n    }\n    return polygon;\n}\n\nfunction getTilePolygons(coordinates, bbox, canonical: CanonicalTileID) {\n    const polygons = [];\n    for (let i = 0; i < coordinates.length; i++) {\n        const polygon = getTilePolygon(coordinates[i], bbox, canonical);\n        polygons.push(polygon);\n    }\n    return polygons;\n}\n\nfunction updatePoint(p, bbox, polyBBox, worldSize) {\n    if (p[0] < polyBBox[0] || p[0] > polyBBox[2]) {\n        const halfWorldSize = worldSize * 0.5;\n        let shift = (p[0] - polyBBox[0] > halfWorldSize) ? -worldSize : (polyBBox[0] - p[0] > halfWorldSize) ? worldSize : 0;\n        if (shift === 0) {\n            shift = (p[0] - polyBBox[2] > halfWorldSize) ? -worldSize : (polyBBox[2] - p[0] > halfWorldSize) ? worldSize : 0;\n        }\n        p[0] += shift;\n    }\n    updateBBox(bbox, p);\n}\n\nfunction resetBBox(bbox) {\n    bbox[0] = bbox[1] = Infinity;\n    bbox[2] = bbox[3] = -Infinity;\n}\n\nfunction getTilePoints(geometry, pointBBox, polyBBox, canonical: CanonicalTileID) {\n    const worldSize = Math.pow(2, canonical.z) * EXTENT;\n    const shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n    const tilePoints = [];\n    if (!geometry) return tilePoints;\n    for (const points of geometry) {\n        for (const point of points) {\n            const p = [point.x + shifts[0], point.y + shifts[1]];\n            updatePoint(p, pointBBox, polyBBox, worldSize);\n            tilePoints.push(p);\n        }\n    }\n    return tilePoints;\n}\n\nfunction getTileLines(geometry, lineBBox, polyBBox, canonical: CanonicalTileID) {\n    const worldSize = Math.pow(2, canonical.z) * EXTENT;\n    const shifts = [canonical.x * EXTENT, canonical.y * EXTENT];\n    const tileLines = [];\n    if (!geometry) return tileLines;\n    for (const line of geometry) {\n        const tileLine = [];\n        for (const point of line) {\n            const p = [point.x + shifts[0], point.y + shifts[1]];\n            updateBBox(lineBBox, p);\n            tileLine.push(p);\n        }\n        tileLines.push(tileLine);\n    }\n    if (lineBBox[2] - lineBBox[0] <= worldSize / 2) {\n        resetBBox(lineBBox);\n        for (const line of tileLines) {\n            for (const p of line) {\n                updatePoint(p, lineBBox, polyBBox, worldSize);\n            }\n        }\n    }\n    return tileLines;\n}\n\nfunction pointsWithinPolygons(ctx: EvaluationContext, polygonGeometry: GeoJSONPolygons) {\n    const pointBBox = [Infinity, Infinity, -Infinity, -Infinity];\n    const polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    const canonical = ctx.canonicalID();\n    if (!canonical) {\n        return false;\n    }\n\n    if (polygonGeometry.type === 'Polygon') {\n        const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n        const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n        if (!boxWithinBox(pointBBox, polyBBox)) return false;\n\n        for (const point of tilePoints) {\n            if (!pointWithinPolygon(point, tilePolygon)) return false;\n        }\n    }\n    if (polygonGeometry.type === 'MultiPolygon') {\n        const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n        const tilePoints = getTilePoints(ctx.geometry(), pointBBox, polyBBox, canonical);\n        if (!boxWithinBox(pointBBox, polyBBox)) return false;\n\n        for (const point of tilePoints) {\n            if (!pointWithinPolygons(point, tilePolygons)) return false;\n        }\n    }\n\n    return true;\n}\n\nfunction linesWithinPolygons(ctx: EvaluationContext, polygonGeometry: GeoJSONPolygons) {\n    const lineBBox = [Infinity, Infinity, -Infinity, -Infinity];\n    const polyBBox = [Infinity, Infinity, -Infinity, -Infinity];\n\n    const canonical = ctx.canonicalID();\n    if (!canonical) {\n        return false;\n    }\n\n    if (polygonGeometry.type === 'Polygon') {\n        const tilePolygon = getTilePolygon(polygonGeometry.coordinates, polyBBox, canonical);\n        const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n        if (!boxWithinBox(lineBBox, polyBBox)) return false;\n\n        for (const line of tileLines) {\n            if (!lineStringWithinPolygon(line, tilePolygon)) return false;\n        }\n    }\n    if (polygonGeometry.type === 'MultiPolygon') {\n        const tilePolygons = getTilePolygons(polygonGeometry.coordinates, polyBBox, canonical);\n        const tileLines = getTileLines(ctx.geometry(), lineBBox, polyBBox, canonical);\n        if (!boxWithinBox(lineBBox, polyBBox)) return false;\n\n        for (const line of tileLines) {\n            if (!lineStringWithinPolygons(line, tilePolygons)) return false;\n        }\n    }\n    return true;\n}\n\nclass Within implements Expression {\n    type: Type;\n    geojson: GeoJSON\n    geometries: GeoJSONPolygons;\n\n    constructor(geojson: GeoJSON, geometries: GeoJSONPolygons) {\n        this.type = BooleanType;\n        this.geojson = geojson;\n        this.geometries = geometries;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Within {\n        if (args.length !== 2)\n            return context.error(`'within' expression requires exactly one argument, but found ${args.length - 1} instead.`);\n        if (isValue(args[1])) {\n            const geojson = (args[1]: Object);\n            if (geojson.type === 'FeatureCollection') {\n                for (let i = 0; i < geojson.features.length; ++i) {\n                    const type = geojson.features[i].geometry.type;\n                    if (type === 'Polygon' || type === 'MultiPolygon') {\n                        return new Within(geojson, geojson.features[i].geometry);\n                    }\n                }\n            } else if (geojson.type === 'Feature') {\n                const type = geojson.geometry.type;\n                if (type === 'Polygon' || type === 'MultiPolygon') {\n                    return new Within(geojson, geojson.geometry);\n                }\n            } else if (geojson.type  === 'Polygon' || geojson.type === 'MultiPolygon') {\n                return new Within(geojson, geojson);\n            }\n        }\n        return context.error(`'within' expression requires valid geojson object that contains polygon geometry type.`);\n    }\n\n    evaluate(ctx: EvaluationContext): boolean {\n        if (ctx.geometry() != null && ctx.canonicalID() != null) {\n            if (ctx.geometryType() === 'Point') {\n                return pointsWithinPolygons(ctx, this.geometries);\n            } else if (ctx.geometryType() === 'LineString') {\n                return linesWithinPolygons(ctx, this.geometries);\n            }\n        }\n        return false;\n    }\n\n    eachChild() {}\n\n    outputDefined(): boolean {\n        return true;\n    }\n\n    serialize(): SerializedExpression {\n        return [\"within\", this.geojson];\n    }\n\n}\n\nexport default Within;\n","// @flow\n\nimport CompoundExpression from './compound_expression.js';\nimport Within from './definitions/within.js';\nimport type {Expression} from './expression.js';\n\nfunction isFeatureConstant(e: Expression): boolean {\n    if (e instanceof CompoundExpression) {\n        if (e.name === 'get' && e.args.length === 1) {\n            return false;\n        } else if (e.name === 'feature-state') {\n            return false;\n        } else if (e.name === 'has' && e.args.length === 1) {\n            return false;\n        } else if (\n            e.name === 'properties' ||\n            e.name === 'geometry-type' ||\n            e.name === 'id'\n        ) {\n            return false;\n        } else if (/^filter-/.test(e.name)) {\n            return false;\n        }\n    }\n\n    if (e instanceof Within) {\n        return false;\n    }\n\n    let result = true;\n    e.eachChild(arg => {\n        if (result && !isFeatureConstant(arg)) { result = false; }\n    });\n    return result;\n}\n\nfunction isStateConstant(e: Expression): boolean {\n    if (e instanceof CompoundExpression) {\n        if (e.name === 'feature-state') {\n            return false;\n        }\n    }\n    let result = true;\n    e.eachChild(arg => {\n        if (result && !isStateConstant(arg)) { result = false; }\n    });\n    return result;\n}\n\nfunction isGlobalPropertyConstant(e: Expression, properties: Array<string>): boolean {\n    if (e instanceof CompoundExpression && properties.indexOf(e.name) >= 0) { return false; }\n    let result = true;\n    e.eachChild((arg) => {\n        if (result && !isGlobalPropertyConstant(arg, properties)) { result = false; }\n    });\n    return result;\n}\n\nexport {isFeatureConstant, isGlobalPropertyConstant, isStateConstant};\n","// @flow\n\nimport type {Type} from '../types.js';\nimport type {Expression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext  from '../evaluation_context.js';\n\nclass Var implements Expression {\n    type: Type;\n    name: string;\n    boundExpression: Expression;\n\n    constructor(name: string, boundExpression: Expression) {\n        this.type = boundExpression.type;\n        this.name = name;\n        this.boundExpression = boundExpression;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): void | Var {\n        if (args.length !== 2 || typeof args[1] !== 'string')\n            return context.error(`'var' expression requires exactly one string literal argument.`);\n\n        const name = args[1];\n        if (!context.scope.has(name)) {\n            return context.error(`Unknown variable \"${name}\". Make sure \"${name}\" has been bound in an enclosing \"let\" expression before using it.`, 1);\n        }\n\n        return new Var(name, context.scope.get(name));\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        return this.boundExpression.evaluate(ctx);\n    }\n\n    eachChild() {}\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): Array<string> {\n        return [\"var\", this.name];\n    }\n}\n\nexport default Var;\n","// @flow\n\nimport Scope from './scope.js';\nimport {checkSubtype} from './types.js';\nimport ParsingError from './parsing_error.js';\nimport Literal from './definitions/literal.js';\nimport Assertion from './definitions/assertion.js';\nimport Coercion from './definitions/coercion.js';\nimport EvaluationContext from './evaluation_context.js';\nimport CompoundExpression from './compound_expression.js';\nimport CollatorExpression from './definitions/collator.js';\nimport Within from './definitions/within.js';\nimport {isGlobalPropertyConstant, isFeatureConstant} from './is_constant.js';\nimport Var from './definitions/var.js';\n\nimport type {Expression, ExpressionRegistry} from './expression.js';\nimport type {Type} from './types.js';\n\n/**\n * State associated parsing at a given point in an expression tree.\n * @private\n */\nclass ParsingContext {\n    registry: ExpressionRegistry;\n    path: Array<number>;\n    key: string;\n    scope: Scope;\n    errors: Array<ParsingError>;\n\n    // The expected type of this expression. Provided only to allow Expression\n    // implementations to infer argument types: Expression#parse() need not\n    // check that the output type of the parsed expression matches\n    // `expectedType`.\n    expectedType: ?Type;\n\n    constructor(\n        registry: ExpressionRegistry,\n        path: Array<number> = [],\n        expectedType: ?Type,\n        scope: Scope = new Scope(),\n        errors: Array<ParsingError> = []\n    ) {\n        this.registry = registry;\n        this.path = path;\n        this.key = path.map(part => `[${part}]`).join('');\n        this.scope = scope;\n        this.errors = errors;\n        this.expectedType = expectedType;\n    }\n\n    /**\n     * @param expr the JSON expression to parse\n     * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed\n     * @param options\n     * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.\n     * @private\n     */\n    parse(\n        expr: mixed,\n        index?: number,\n        expectedType?: ?Type,\n        bindings?: Array<[string, Expression]>,\n        options: {typeAnnotation?: 'assert' | 'coerce' | 'omit'} = {}\n    ): ?Expression {\n        if (index) {\n            return this.concat(index, expectedType, bindings)._parse(expr, options);\n        }\n        return this._parse(expr, options);\n    }\n\n    _parse(expr: mixed, options: {typeAnnotation?: 'assert' | 'coerce' | 'omit'}): ?Expression {\n        if (expr === null || typeof expr === 'string' || typeof expr === 'boolean' || typeof expr === 'number') {\n            expr = ['literal', expr];\n        }\n\n        function annotate(parsed, type, typeAnnotation: 'assert' | 'coerce' | 'omit') {\n            if (typeAnnotation === 'assert') {\n                return new Assertion(type, [parsed]);\n            } else if (typeAnnotation === 'coerce') {\n                return new Coercion(type, [parsed]);\n            } else {\n                return parsed;\n            }\n        }\n\n        if (Array.isArray(expr)) {\n            if (expr.length === 0) {\n                return this.error(`Expected an array with at least one element. If you wanted a literal array, use [\"literal\", []].`);\n            }\n\n            const op = expr[0];\n            if (typeof op !== 'string') {\n                this.error(`Expression name must be a string, but found ${typeof op} instead. If you wanted a literal array, use [\"literal\", [...]].`, 0);\n                return null;\n            }\n\n            const Expr = this.registry[op];\n            if (Expr) {\n                let parsed = Expr.parse(expr, this);\n                if (!parsed) return null;\n\n                if (this.expectedType) {\n                    const expected = this.expectedType;\n                    const actual = parsed.type;\n\n                    // When we expect a number, string, boolean, or array but have a value, wrap it in an assertion.\n                    // When we expect a color or formatted string, but have a string or value, wrap it in a coercion.\n                    // Otherwise, we do static type-checking.\n                    //\n                    // These behaviors are overridable for:\n                    //   * The \"coalesce\" operator, which needs to omit type annotations.\n                    //   * String-valued properties (e.g. `text-field`), where coercion is more convenient than assertion.\n                    //\n                    if ((expected.kind === 'string' || expected.kind === 'number' || expected.kind === 'boolean' || expected.kind === 'object' || expected.kind === 'array') && actual.kind === 'value') {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'assert');\n                    } else if ((expected.kind === 'color' || expected.kind === 'formatted' || expected.kind === 'resolvedImage') && (actual.kind === 'value' || actual.kind === 'string')) {\n                        parsed = annotate(parsed, expected, options.typeAnnotation || 'coerce');\n                    } else if (this.checkSubtype(expected, actual)) {\n                        return null;\n                    }\n                }\n\n                // If an expression's arguments are all literals, we can evaluate\n                // it immediately and replace it with a literal value in the\n                // parsed/compiled result. Expressions that expect an image should\n                // not be resolved here so we can later get the available images.\n                if (!(parsed instanceof Literal) && (parsed.type.kind !== 'resolvedImage') && isConstant(parsed)) {\n                    const ec = new EvaluationContext();\n                    try {\n                        parsed = new Literal(parsed.type, parsed.evaluate(ec));\n                    } catch (e) {\n                        this.error(e.message);\n                        return null;\n                    }\n                }\n\n                return parsed;\n            }\n\n            return this.error(`Unknown expression \"${op}\". If you wanted a literal array, use [\"literal\", [...]].`, 0);\n        } else if (typeof expr === 'undefined') {\n            return this.error(`'undefined' value invalid. Use null instead.`);\n        } else if (typeof expr === 'object') {\n            return this.error(`Bare objects invalid. Use [\"literal\", {...}] instead.`);\n        } else {\n            return this.error(`Expected an array, but found ${typeof expr} instead.`);\n        }\n    }\n\n    /**\n     * Returns a copy of this context suitable for parsing the subexpression at\n     * index `index`, optionally appending to 'let' binding map.\n     *\n     * Note that `errors` property, intended for collecting errors while\n     * parsing, is copied by reference rather than cloned.\n     * @private\n     */\n    concat(index: number, expectedType?: ?Type, bindings?: Array<[string, Expression]>): ParsingContext {\n        const path = typeof index === 'number' ? this.path.concat(index) : this.path;\n        const scope = bindings ? this.scope.concat(bindings) : this.scope;\n        return new ParsingContext(\n            this.registry,\n            path,\n            expectedType || null,\n            scope,\n            this.errors\n        );\n    }\n\n    /**\n     * Push a parsing (or type checking) error into the `this.errors`\n     * @param error The message\n     * @param keys Optionally specify the source of the error at a child\n     * of the current expression at `this.key`.\n     * @private\n     */\n    error(error: string, ...keys: Array<number>) {\n        const key = `${this.key}${keys.map(k => `[${k}]`).join('')}`;\n        this.errors.push(new ParsingError(key, error));\n    }\n\n    /**\n     * Returns null if `t` is a subtype of `expected`; otherwise returns an\n     * error message and also pushes it to `this.errors`.\n     */\n    checkSubtype(expected: Type, t: Type): ?string {\n        const error = checkSubtype(expected, t);\n        if (error) this.error(error);\n        return error;\n    }\n}\n\nexport default ParsingContext;\n\nfunction isConstant(expression: Expression) {\n    if (expression instanceof Var) {\n        return isConstant(expression.boundExpression);\n    } else if (expression instanceof CompoundExpression && expression.name === 'error') {\n        return false;\n    } else if (expression instanceof CollatorExpression) {\n        // Although the results of a Collator expression with fixed arguments\n        // generally shouldn't change between executions, we can't serialize them\n        // as constant expressions because results change based on environment.\n        return false;\n    } else if (expression instanceof Within) {\n        return false;\n    }\n\n    const isTypeAnnotation = expression instanceof Coercion ||\n        expression instanceof Assertion;\n\n    let childrenConstant = true;\n    expression.eachChild(child => {\n        // We can _almost_ assume that if `expressions` children are constant,\n        // they would already have been evaluated to Literal values when they\n        // were parsed.  Type annotations are the exception, because they might\n        // have been inferred and added after a child was parsed.\n\n        // So we recurse into isConstant() for the children of type annotations,\n        // but otherwise simply check whether they are Literals.\n        if (isTypeAnnotation) {\n            childrenConstant = childrenConstant && isConstant(child);\n        } else {\n            childrenConstant = childrenConstant && child instanceof Literal;\n        }\n    });\n    if (!childrenConstant) {\n        return false;\n    }\n\n    return isFeatureConstant(expression) &&\n        isGlobalPropertyConstant(expression, ['zoom', 'heatmap-density', 'line-progress', 'sky-radial-progress', 'accumulated', 'is-supported-script', 'pitch', 'distance-from-center']);\n}\n","// @flow\n\nimport RuntimeError from './runtime_error.js';\n\nimport type {Expression} from './expression.js';\n\nexport type Stops = Array<[number, Expression]>;\n\n/**\n * Returns the index of the last stop <= input, or 0 if it doesn't exist.\n * @private\n */\nexport function findStopLessThanOrEqualTo(stops: Array<number>, input: number): number {\n    const lastIndex = stops.length - 1;\n    let lowerIndex = 0;\n    let upperIndex = lastIndex;\n    let currentIndex = 0;\n    let currentValue, nextValue;\n\n    while (lowerIndex <= upperIndex) {\n        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);\n        currentValue = stops[currentIndex];\n        nextValue = stops[currentIndex + 1];\n\n        if (currentValue <= input) {\n            if (currentIndex === lastIndex || input < nextValue) { // Search complete\n                return currentIndex;\n            }\n\n            lowerIndex = currentIndex + 1;\n        } else if (currentValue > input) {\n            upperIndex = currentIndex - 1;\n        } else {\n            throw new RuntimeError('Input is not a number.');\n        }\n    }\n\n    return 0;\n}\n","// @flow\n\nimport {NumberType} from '../types.js';\n\nimport {findStopLessThanOrEqualTo} from '../stops.js';\n\nimport type {Stops} from '../stops.js';\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nclass Step implements Expression {\n    type: Type;\n\n    input: Expression;\n    labels: Array<number>;\n    outputs: Array<Expression>;\n\n    constructor(type: Type, input: Expression, stops: Stops) {\n        this.type = type;\n        this.input = input;\n\n        this.labels = [];\n        this.outputs = [];\n        for (const [label, expression] of stops) {\n            this.labels.push(label);\n            this.outputs.push(expression);\n        }\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Step {\n        if (args.length - 1 < 4) {\n            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);\n        }\n\n        if ((args.length - 1) % 2 !== 0) {\n            return context.error(`Expected an even number of arguments.`);\n        }\n\n        const input = context.parse(args[1], 1, NumberType);\n        if (!input) return null;\n\n        const stops: Stops = [];\n\n        let outputType: Type = (null: any);\n        if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n\n        for (let i = 1; i < args.length; i += 2) {\n            const label = i === 1 ? -Infinity : args[i];\n            const value = args[i + 1];\n\n            const labelKey = i;\n            const valueKey = i + 1;\n\n            if (typeof label !== 'number') {\n                return context.error('Input/output pairs for \"step\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n            }\n\n            if (stops.length && stops[stops.length - 1][0] >= label) {\n                return context.error('Input/output pairs for \"step\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n            }\n\n            const parsed = context.parse(value, valueKey, outputType);\n            if (!parsed) return null;\n            outputType = outputType || parsed.type;\n            stops.push([label, parsed]);\n        }\n\n        return new Step(outputType, input, stops);\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        const labels = this.labels;\n        const outputs = this.outputs;\n\n        if (labels.length === 1) {\n            return outputs[0].evaluate(ctx);\n        }\n\n        const value = ((this.input.evaluate(ctx): any): number);\n        if (value <= labels[0]) {\n            return outputs[0].evaluate(ctx);\n        }\n\n        const stopCount = labels.length;\n        if (value >= labels[stopCount - 1]) {\n            return outputs[stopCount - 1].evaluate(ctx);\n        }\n\n        const index = findStopLessThanOrEqualTo(labels, value);\n        return outputs[index].evaluate(ctx);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.input);\n        for (const expression of this.outputs) {\n            fn(expression);\n        }\n    }\n\n    outputDefined(): boolean {\n        return this.outputs.every(out => out.outputDefined());\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"step\", this.input.serialize()];\n        for (let i = 0; i < this.labels.length; i++) {\n            if (i > 0) {\n                serialized.push(this.labels[i]);\n            }\n            serialized.push(this.outputs[i].serialize());\n        }\n        return serialized;\n    }\n}\n\nexport default Step;\n","'use strict';\n\nmodule.exports = UnitBezier;\n\nfunction UnitBezier(p1x, p1y, p2x, p2y) {\n    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).\n    this.cx = 3.0 * p1x;\n    this.bx = 3.0 * (p2x - p1x) - this.cx;\n    this.ax = 1.0 - this.cx - this.bx;\n\n    this.cy = 3.0 * p1y;\n    this.by = 3.0 * (p2y - p1y) - this.cy;\n    this.ay = 1.0 - this.cy - this.by;\n\n    this.p1x = p1x;\n    this.p1y = p1y;\n    this.p2x = p2x;\n    this.p2y = p2y;\n}\n\nUnitBezier.prototype = {\n    sampleCurveX: function (t) {\n        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.\n        return ((this.ax * t + this.bx) * t + this.cx) * t;\n    },\n\n    sampleCurveY: function (t) {\n        return ((this.ay * t + this.by) * t + this.cy) * t;\n    },\n\n    sampleCurveDerivativeX: function (t) {\n        return (3.0 * this.ax * t + 2.0 * this.bx) * t + this.cx;\n    },\n\n    solveCurveX: function (x, epsilon) {\n        if (epsilon === undefined) epsilon = 1e-6;\n\n        if (x < 0.0) return 0.0;\n        if (x > 1.0) return 1.0;\n\n        var t = x;\n\n        // First try a few iterations of Newton's method - normally very fast.\n        for (var i = 0; i < 8; i++) {\n            var x2 = this.sampleCurveX(t) - x;\n            if (Math.abs(x2) < epsilon) return t;\n\n            var d2 = this.sampleCurveDerivativeX(t);\n            if (Math.abs(d2) < 1e-6) break;\n\n            t = t - x2 / d2;\n        }\n\n        // Fall back to the bisection method for reliability.\n        var t0 = 0.0;\n        var t1 = 1.0;\n        t = x;\n\n        for (i = 0; i < 20; i++) {\n            x2 = this.sampleCurveX(t);\n            if (Math.abs(x2 - x) < epsilon) break;\n\n            if (x > x2) {\n                t0 = t;\n            } else {\n                t1 = t;\n            }\n\n            t = (t1 - t0) * 0.5 + t0;\n        }\n\n        return t;\n    },\n\n    solve: function (x, epsilon) {\n        return this.sampleCurveY(this.solveCurveX(x, epsilon));\n    }\n};\n","// @flow\n\nimport Color from './color.js';\n\nexport function number(a: number, b: number, t: number): number {\n    return (a * (1 - t)) + (b * t);\n}\n\nexport function color(from: Color, to: Color, t: number): Color {\n    return new Color(\n        number(from.r, to.r, t),\n        number(from.g, to.g, t),\n        number(from.b, to.b, t),\n        number(from.a, to.a, t)\n    );\n}\n\nexport function array(from: Array<number>, to: Array<number>, t: number): Array<number> {\n    return from.map((d, i) => {\n        return number(d, to[i], t);\n    });\n}\n","// @flow\n\nimport Color from './color.js';\n\nimport {number as interpolateNumber} from './interpolate.js';\n\ntype LABColor = {\n    l: number,\n    a: number,\n    b: number,\n    alpha: number\n};\n\ntype HCLColor = {\n    h: number,\n    c: number,\n    l: number,\n    alpha: number\n};\n\n// Constants\nconst Xn = 0.950470, // D65 standard referent\n    Yn = 1,\n    Zn = 1.088830,\n    t0 = 4 / 29,\n    t1 = 6 / 29,\n    t2 = 3 * t1 * t1,\n    t3 = t1 * t1 * t1,\n    deg2rad = Math.PI / 180,\n    rad2deg = 180 / Math.PI;\n\n// Utilities\nfunction xyz2lab(t: number) {\n    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;\n}\n\nfunction lab2xyz(t: number) {\n    return t > t1 ? t * t * t : t2 * (t - t0);\n}\n\nfunction xyz2rgb(x: number) {\n    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);\n}\n\nfunction rgb2xyz(x: number) {\n    x /= 255;\n    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n\n// LAB\nfunction rgbToLab(rgbColor: Color): LABColor {\n    const b = rgb2xyz(rgbColor.r),\n        a = rgb2xyz(rgbColor.g),\n        l = rgb2xyz(rgbColor.b),\n        x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),\n        y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),\n        z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);\n\n    return {\n        l: 116 * y - 16,\n        a: 500 * (x - y),\n        b: 200 * (y - z),\n        alpha: rgbColor.a\n    };\n}\n\nfunction labToRgb(labColor: LABColor): Color {\n    let y = (labColor.l + 16) / 116,\n        x = isNaN(labColor.a) ? y : y + labColor.a / 500,\n        z = isNaN(labColor.b) ? y : y - labColor.b / 200;\n    y = Yn * lab2xyz(y);\n    x = Xn * lab2xyz(x);\n    z = Zn * lab2xyz(z);\n    return new Color(\n        xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB\n        xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),\n        xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z),\n        labColor.alpha\n    );\n}\n\nfunction interpolateLab(from: LABColor, to: LABColor, t: number): LABColor {\n    return {\n        l: interpolateNumber(from.l, to.l, t),\n        a: interpolateNumber(from.a, to.a, t),\n        b: interpolateNumber(from.b, to.b, t),\n        alpha: interpolateNumber(from.alpha, to.alpha, t)\n    };\n}\n\n// HCL\nfunction rgbToHcl(rgbColor: Color): HCLColor {\n    const {l, a, b} = rgbToLab(rgbColor);\n    const h = Math.atan2(b, a) * rad2deg;\n    return {\n        h: h < 0 ? h + 360 : h,\n        c: Math.sqrt(a * a + b * b),\n        l,\n        alpha: rgbColor.a\n    };\n}\n\nfunction hclToRgb(hclColor: HCLColor): Color {\n    const h = hclColor.h * deg2rad,\n        c = hclColor.c,\n        l = hclColor.l;\n    return labToRgb({\n        l,\n        a: Math.cos(h) * c,\n        b: Math.sin(h) * c,\n        alpha: hclColor.alpha\n    });\n}\n\nfunction interpolateHue(a: number, b: number, t: number) {\n    const d = b - a;\n    return a + t * (d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d);\n}\n\nfunction interpolateHcl(from: HCLColor, to: HCLColor, t: number): HCLColor {\n    return {\n        h: interpolateHue(from.h, to.h, t),\n        c: interpolateNumber(from.c, to.c, t),\n        l: interpolateNumber(from.l, to.l, t),\n        alpha: interpolateNumber(from.alpha, to.alpha, t)\n    };\n}\n\nexport const lab = {\n    forward: rgbToLab,\n    reverse: labToRgb,\n    interpolate: interpolateLab\n};\n\nexport const hcl = {\n    forward: rgbToHcl,\n    reverse: hclToRgb,\n    interpolate: interpolateHcl\n};\n","// @flow\n\nimport UnitBezier from '@mapbox/unitbezier';\n\nimport * as interpolate from '../../util/interpolate.js';\nimport {toString, NumberType, ColorType} from '../types.js';\nimport {findStopLessThanOrEqualTo} from '../stops.js';\nimport {hcl, lab} from '../../util/color_spaces.js';\nimport Color from '../../util/color.js';\n\nimport type {Stops} from '../stops.js';\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nexport type InterpolationType =\n    { name: 'linear' } |\n    { name: 'exponential', base: number } |\n    { name: 'cubic-bezier', controlPoints: [number, number, number, number] };\n\nclass Interpolate implements Expression {\n    type: Type;\n\n    operator: 'interpolate' | 'interpolate-hcl' | 'interpolate-lab';\n    interpolation: InterpolationType;\n    input: Expression;\n    labels: Array<number>;\n    outputs: Array<Expression>;\n\n    constructor(type: Type, operator: 'interpolate' | 'interpolate-hcl' | 'interpolate-lab', interpolation: InterpolationType, input: Expression, stops: Stops) {\n        this.type = type;\n        this.operator = operator;\n        this.interpolation = interpolation;\n        this.input = input;\n\n        this.labels = [];\n        this.outputs = [];\n        for (const [label, expression] of stops) {\n            this.labels.push(label);\n            this.outputs.push(expression);\n        }\n    }\n\n    static interpolationFactor(interpolation: InterpolationType, input: number, lower: number, upper: number): number {\n        let t = 0;\n        if (interpolation.name === 'exponential') {\n            t = exponentialInterpolation(input, interpolation.base, lower, upper);\n        } else if (interpolation.name === 'linear') {\n            t = exponentialInterpolation(input, 1, lower, upper);\n        } else if (interpolation.name === 'cubic-bezier') {\n            const c = interpolation.controlPoints;\n            const ub = new UnitBezier(c[0], c[1], c[2], c[3]);\n            t = ub.solve(exponentialInterpolation(input, 1, lower, upper));\n        }\n        return t;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Interpolate {\n        let [operator, interpolation, input, ...rest] = args;\n\n        if (!Array.isArray(interpolation) || interpolation.length === 0) {\n            return context.error(`Expected an interpolation type expression.`, 1);\n        }\n\n        if (interpolation[0] === 'linear') {\n            interpolation = {name: 'linear'};\n        } else if (interpolation[0] === 'exponential') {\n            const base = interpolation[1];\n            if (typeof base !== 'number')\n                return context.error(`Exponential interpolation requires a numeric base.`, 1, 1);\n            interpolation = {\n                name: 'exponential',\n                base\n            };\n        } else if (interpolation[0] === 'cubic-bezier') {\n            const controlPoints = interpolation.slice(1);\n            if (\n                controlPoints.length !== 4 ||\n                controlPoints.some(t => typeof t !== 'number' || t < 0 || t > 1)\n            ) {\n                return context.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);\n            }\n\n            interpolation = {\n                name: 'cubic-bezier',\n                controlPoints: (controlPoints: any)\n            };\n        } else {\n            return context.error(`Unknown interpolation type ${String(interpolation[0])}`, 1, 0);\n        }\n\n        if (args.length - 1 < 4) {\n            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);\n        }\n\n        if ((args.length - 1) % 2 !== 0) {\n            return context.error(`Expected an even number of arguments.`);\n        }\n\n        input = context.parse(input, 2, NumberType);\n        if (!input) return null;\n\n        const stops: Stops = [];\n\n        let outputType: Type = (null: any);\n        if (operator === 'interpolate-hcl' || operator === 'interpolate-lab') {\n            outputType = ColorType;\n        } else if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n\n        for (let i = 0; i < rest.length; i += 2) {\n            const label = rest[i];\n            const value = rest[i + 1];\n\n            const labelKey = i + 3;\n            const valueKey = i + 4;\n\n            if (typeof label !== 'number') {\n                return context.error('Input/output pairs for \"interpolate\" expressions must be defined using literal numeric values (not computed expressions) for the input values.', labelKey);\n            }\n\n            if (stops.length && stops[stops.length - 1][0] >= label) {\n                return context.error('Input/output pairs for \"interpolate\" expressions must be arranged with input values in strictly ascending order.', labelKey);\n            }\n\n            const parsed = context.parse(value, valueKey, outputType);\n            if (!parsed) return null;\n            outputType = outputType || parsed.type;\n            stops.push([label, parsed]);\n        }\n\n        if (outputType.kind !== 'number' &&\n            outputType.kind !== 'color' &&\n            !(\n                outputType.kind === 'array' &&\n                outputType.itemType.kind === 'number' &&\n                typeof outputType.N === 'number'\n            )\n        ) {\n            return context.error(`Type ${toString(outputType)} is not interpolatable.`);\n        }\n\n        return new Interpolate(outputType, (operator: any), interpolation, input, stops);\n    }\n\n    evaluate(ctx: EvaluationContext): Color {\n        const labels = this.labels;\n        const outputs = this.outputs;\n\n        if (labels.length === 1) {\n            return outputs[0].evaluate(ctx);\n        }\n\n        const value = ((this.input.evaluate(ctx): any): number);\n        if (value <= labels[0]) {\n            return outputs[0].evaluate(ctx);\n        }\n\n        const stopCount = labels.length;\n        if (value >= labels[stopCount - 1]) {\n            return outputs[stopCount - 1].evaluate(ctx);\n        }\n\n        const index = findStopLessThanOrEqualTo(labels, value);\n        const lower = labels[index];\n        const upper = labels[index + 1];\n        const t = Interpolate.interpolationFactor(this.interpolation, value, lower, upper);\n\n        const outputLower = outputs[index].evaluate(ctx);\n        const outputUpper = outputs[index + 1].evaluate(ctx);\n\n        if (this.operator === 'interpolate') {\n            return (interpolate[this.type.kind.toLowerCase()]: any)(outputLower, outputUpper, t); // eslint-disable-line import/namespace\n        } else if (this.operator === 'interpolate-hcl') {\n            return hcl.reverse(hcl.interpolate(hcl.forward(outputLower), hcl.forward(outputUpper), t));\n        } else {\n            return lab.reverse(lab.interpolate(lab.forward(outputLower), lab.forward(outputUpper), t));\n        }\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.input);\n        for (const expression of this.outputs) {\n            fn(expression);\n        }\n    }\n\n    outputDefined(): boolean {\n        return this.outputs.every(out => out.outputDefined());\n    }\n\n    serialize(): SerializedExpression {\n        let interpolation;\n        if (this.interpolation.name === 'linear') {\n            interpolation = [\"linear\"];\n        } else if (this.interpolation.name === 'exponential') {\n            if  (this.interpolation.base === 1) {\n                interpolation = [\"linear\"];\n            } else {\n                interpolation = [\"exponential\", this.interpolation.base];\n            }\n        } else {\n            interpolation = [\"cubic-bezier\" ].concat(this.interpolation.controlPoints);\n        }\n\n        const serialized = [this.operator, interpolation, this.input.serialize()];\n\n        for (let i = 0; i < this.labels.length; i++) {\n            serialized.push(\n                this.labels[i],\n                this.outputs[i].serialize()\n            );\n        }\n        return serialized;\n    }\n}\n\n/**\n * Returns a ratio that can be used to interpolate between exponential function\n * stops.\n * How it works: Two consecutive stop values define a (scaled and shifted) exponential function `f(x) = a * base^x + b`, where `base` is the user-specified base,\n * and `a` and `b` are constants affording sufficient degrees of freedom to fit\n * the function to the given stops.\n *\n * Here's a bit of algebra that lets us compute `f(x)` directly from the stop\n * values without explicitly solving for `a` and `b`:\n *\n * First stop value: `f(x0) = y0 = a * base^x0 + b`\n * Second stop value: `f(x1) = y1 = a * base^x1 + b`\n * => `y1 - y0 = a(base^x1 - base^x0)`\n * => `a = (y1 - y0)/(base^x1 - base^x0)`\n *\n * Desired value: `f(x) = y = a * base^x + b`\n * => `f(x) = y0 + a * (base^x - base^x0)`\n *\n * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a\n * little algebra:\n * ```\n * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)\n *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)\n * ```\n *\n * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have\n * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as\n * an interpolation factor between the two stops' output values.\n *\n * (Note: a slightly different form for `ratio`,\n * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer\n * expensive `Math.pow()` operations.)\n *\n * @private\n*/\nfunction exponentialInterpolation(input, base, lowerValue, upperValue) {\n    const difference = upperValue - lowerValue;\n    const progress = input - lowerValue;\n\n    if (difference === 0) {\n        return 0;\n    } else if (base === 1) {\n        return progress / difference;\n    } else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\n\nexport default Interpolate;\n","// @flow\n\nimport assert from 'assert';\n\nimport {checkSubtype, ValueType} from '../types.js';\nimport ResolvedImage from '../types/resolved_image.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nclass Coalesce implements Expression {\n    type: Type;\n    args: Array<Expression>;\n\n    constructor(type: Type, args: Array<Expression>) {\n        this.type = type;\n        this.args = args;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Coalesce {\n        if (args.length < 2) {\n            return context.error(\"Expectected at least one argument.\");\n        }\n        let outputType: Type = (null: any);\n        const expectedType = context.expectedType;\n        if (expectedType && expectedType.kind !== 'value') {\n            outputType = expectedType;\n        }\n        const parsedArgs = [];\n\n        for (const arg of args.slice(1)) {\n            const parsed = context.parse(arg, 1 + parsedArgs.length, outputType, undefined, {typeAnnotation: 'omit'});\n            if (!parsed) return null;\n            outputType = outputType || parsed.type;\n            parsedArgs.push(parsed);\n        }\n        assert(outputType);\n\n        // Above, we parse arguments without inferred type annotation so that\n        // they don't produce a runtime error for `null` input, which would\n        // preempt the desired null-coalescing behavior.\n        // Thus, if any of our arguments would have needed an annotation, we\n        // need to wrap the enclosing coalesce expression with it instead.\n        const needsAnnotation = expectedType &&\n            parsedArgs.some(arg => checkSubtype(expectedType, arg.type));\n\n        return needsAnnotation ?\n            new Coalesce(ValueType, parsedArgs) :\n            new Coalesce((outputType: any), parsedArgs);\n    }\n\n    evaluate(ctx: EvaluationContext): any | null {\n        let result = null;\n        let argCount = 0;\n        let firstImage;\n        for (const arg of this.args) {\n            argCount++;\n            result = arg.evaluate(ctx);\n            // we need to keep track of the first requested image in a coalesce statement\n            // if coalesce can't find a valid image, we return the first image so styleimagemissing can fire\n            if (result && result instanceof ResolvedImage && !result.available) {\n                // set to first image\n                if (!firstImage) {\n                    firstImage = result;\n                }\n                result = null;\n                // if we reach the end, return the first image\n                if (argCount === this.args.length) {\n                    return firstImage;\n                }\n            }\n\n            if (result !== null) break;\n        }\n        return result;\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        this.args.forEach(fn);\n    }\n\n    outputDefined(): boolean {\n        return this.args.every(arg => arg.outputDefined());\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"coalesce\"];\n        this.eachChild(child => { serialized.push(child.serialize()); });\n        return serialized;\n    }\n}\n\nexport default Coalesce;\n","// @flow\n\nimport type {Type} from '../types.js';\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext  from '../evaluation_context.js';\n\nclass Let implements Expression {\n    type: Type;\n    bindings: Array<[string, Expression]>;\n    result: Expression;\n\n    constructor(bindings: Array<[string, Expression]>, result: Expression) {\n        this.type = result.type;\n        this.bindings = [].concat(bindings);\n        this.result = result;\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        return this.result.evaluate(ctx);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        for (const binding of this.bindings) {\n            fn(binding[1]);\n        }\n        fn(this.result);\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Let {\n        if (args.length < 4)\n            return context.error(`Expected at least 3 arguments, but found ${args.length - 1} instead.`);\n\n        const bindings: Array<[string, Expression]> = [];\n        for (let i = 1; i < args.length - 1; i += 2) {\n            const name = args[i];\n\n            if (typeof name !== 'string') {\n                return context.error(`Expected string, but found ${typeof name} instead.`, i);\n            }\n\n            if (/[^a-zA-Z0-9_]/.test(name)) {\n                return context.error(`Variable names must contain only alphanumeric characters or '_'.`, i);\n            }\n\n            const value = context.parse(args[i + 1], i + 1);\n            if (!value) return null;\n\n            bindings.push([name, value]);\n        }\n\n        const result = context.parse(args[args.length - 1], args.length - 1, context.expectedType, bindings);\n        if (!result) return null;\n\n        return new Let(bindings, result);\n    }\n\n    outputDefined(): boolean {\n        return this.result.outputDefined();\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"let\"];\n        for (const [name, expr] of this.bindings) {\n            serialized.push(name, expr.serialize());\n        }\n        serialized.push(this.result.serialize());\n        return serialized;\n    }\n}\n\nexport default Let;\n","// @flow\n\nimport {array, ValueType, NumberType} from '../types.js';\n\nimport RuntimeError from '../runtime_error.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type, ArrayType} from '../types.js';\nimport type {Value} from '../values.js';\n\nclass At implements Expression {\n    type: Type;\n    index: Expression;\n    input: Expression;\n\n    constructor(type: Type, index: Expression, input: Expression) {\n        this.type = type;\n        this.index = index;\n        this.input = input;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?At {\n        if (args.length !== 3)\n            return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);\n\n        const index = context.parse(args[1], 1, NumberType);\n        const input = context.parse(args[2], 2, array(context.expectedType || ValueType));\n\n        if (!index || !input) return null;\n\n        const t: ArrayType = (input.type: any);\n        return new At(t.itemType, index, input);\n    }\n\n    evaluate(ctx: EvaluationContext): Value {\n        const index = ((this.index.evaluate(ctx): any): number);\n        const array = ((this.input.evaluate(ctx): any): Array<Value>);\n\n        if (index < 0) {\n            throw new RuntimeError(`Array index out of bounds: ${index} < 0.`);\n        }\n\n        if (index >= array.length) {\n            throw new RuntimeError(`Array index out of bounds: ${index} > ${array.length - 1}.`);\n        }\n\n        if (index !== Math.floor(index)) {\n            throw new RuntimeError(`Array index must be an integer, but found ${index} instead.`);\n        }\n\n        return array[index];\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.index);\n        fn(this.input);\n    }\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        return [\"at\", this.index.serialize(), this.input.serialize()];\n    }\n}\n\nexport default At;\n","// @flow\n\nimport {BooleanType, StringType, ValueType, NullType, toString, NumberType, isValidType, isValidNativeType} from '../types.js';\nimport RuntimeError from '../runtime_error.js';\nimport {typeOf} from '../values.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nclass In implements Expression {\n    type: Type;\n    needle: Expression;\n    haystack: Expression;\n\n    constructor(needle: Expression, haystack: Expression) {\n        this.type = BooleanType;\n        this.needle = needle;\n        this.haystack = haystack;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?In {\n        if (args.length !== 3) {\n            return context.error(`Expected 2 arguments, but found ${args.length - 1} instead.`);\n        }\n\n        const needle = context.parse(args[1], 1, ValueType);\n\n        const haystack = context.parse(args[2], 2, ValueType);\n\n        if (!needle || !haystack) return null;\n\n        if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n            return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${toString(needle.type)} instead`);\n        }\n\n        return new In(needle, haystack);\n    }\n\n    evaluate(ctx: EvaluationContext): boolean {\n        const needle = (this.needle.evaluate(ctx): any);\n        const haystack = (this.haystack.evaluate(ctx): any);\n\n        if (haystack == null) return false;\n\n        if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {\n            throw new RuntimeError(`Expected first argument to be of type boolean, string, number or null, but found ${toString(typeOf(needle))} instead.`);\n        }\n\n        if (!isValidNativeType(haystack, ['string', 'array'])) {\n            throw new RuntimeError(`Expected second argument to be of type array or string, but found ${toString(typeOf(haystack))} instead.`);\n        }\n\n        return haystack.indexOf(needle) >= 0;\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.needle);\n        fn(this.haystack);\n    }\n\n    outputDefined(): boolean {\n        return true;\n    }\n\n    serialize(): SerializedExpression {\n        return [\"in\", this.needle.serialize(), this.haystack.serialize()];\n    }\n}\n\nexport default In;\n","// @flow\n\nimport {BooleanType, StringType, ValueType, NullType, toString, NumberType, isValidType, isValidNativeType} from '../types.js';\nimport RuntimeError from '../runtime_error.js';\nimport {typeOf} from '../values.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nclass IndexOf implements Expression {\n    type: Type;\n    needle: Expression;\n    haystack: Expression;\n    fromIndex: ?Expression;\n\n    constructor(needle: Expression, haystack: Expression, fromIndex?: Expression) {\n        this.type = NumberType;\n        this.needle = needle;\n        this.haystack = haystack;\n        this.fromIndex = fromIndex;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?IndexOf {\n        if (args.length <= 2 ||  args.length >= 5) {\n            return context.error(`Expected 3 or 4 arguments, but found ${args.length - 1} instead.`);\n        }\n\n        const needle = context.parse(args[1], 1, ValueType);\n\n        const haystack = context.parse(args[2], 2, ValueType);\n\n        if (!needle || !haystack) return null;\n        if (!isValidType(needle.type, [BooleanType, StringType, NumberType, NullType, ValueType])) {\n            return context.error(`Expected first argument to be of type boolean, string, number or null, but found ${toString(needle.type)} instead`);\n        }\n\n        if (args.length === 4) {\n            const fromIndex = context.parse(args[3], 3, NumberType);\n            if (!fromIndex) return null;\n            return new IndexOf(needle, haystack, fromIndex);\n        } else {\n            return new IndexOf(needle, haystack);\n        }\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        const needle = (this.needle.evaluate(ctx): any);\n        const haystack = (this.haystack.evaluate(ctx): any);\n\n        if (!isValidNativeType(needle, ['boolean', 'string', 'number', 'null'])) {\n            throw new RuntimeError(`Expected first argument to be of type boolean, string, number or null, but found ${toString(typeOf(needle))} instead.`);\n        }\n\n        if (!isValidNativeType(haystack, ['string', 'array'])) {\n            throw new RuntimeError(`Expected second argument to be of type array or string, but found ${toString(typeOf(haystack))} instead.`);\n        }\n\n        if (this.fromIndex) {\n            const fromIndex = (this.fromIndex.evaluate(ctx): number);\n            return haystack.indexOf(needle, fromIndex);\n        }\n\n        return haystack.indexOf(needle);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.needle);\n        fn(this.haystack);\n        if (this.fromIndex) {\n            fn(this.fromIndex);\n        }\n    }\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        if (this.fromIndex != null && this.fromIndex !== undefined) {\n            const fromIndex = this.fromIndex.serialize();\n            return [\"index-of\", this.needle.serialize(), this.haystack.serialize(), fromIndex];\n        }\n        return [\"index-of\", this.needle.serialize(), this.haystack.serialize()];\n    }\n}\n\nexport default IndexOf;\n","// @flow\n\nimport assert from 'assert';\n\nimport {typeOf} from '../values.js';\nimport {ValueType, type Type} from '../types.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\n\n// Map input label values to output expression index\ntype Cases = {[number | string]: number};\n\nclass Match implements Expression {\n    type: Type;\n    inputType: Type;\n\n    input: Expression;\n    cases: Cases;\n    outputs: Array<Expression>;\n    otherwise: Expression;\n\n    constructor(inputType: Type, outputType: Type, input: Expression, cases: Cases, outputs: Array<Expression>, otherwise: Expression) {\n        this.inputType = inputType;\n        this.type = outputType;\n        this.input = input;\n        this.cases = cases;\n        this.outputs = outputs;\n        this.otherwise = otherwise;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Match {\n        if (args.length < 5)\n            return context.error(`Expected at least 4 arguments, but found only ${args.length - 1}.`);\n        if (args.length % 2 !== 1)\n            return context.error(`Expected an even number of arguments.`);\n\n        let inputType;\n        let outputType;\n        if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n        const cases = {};\n        const outputs = [];\n        for (let i = 2; i < args.length - 1; i += 2) {\n            let labels = args[i];\n            const value = args[i + 1];\n\n            if (!Array.isArray(labels)) {\n                labels = [labels];\n            }\n\n            const labelContext = context.concat(i);\n            if (labels.length === 0) {\n                return labelContext.error('Expected at least one branch label.');\n            }\n\n            for (const label of labels) {\n                if (typeof label !== 'number' && typeof label !== 'string') {\n                    return labelContext.error(`Branch labels must be numbers or strings.`);\n                } else if (typeof label === 'number' && Math.abs(label) > Number.MAX_SAFE_INTEGER) {\n                    return labelContext.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);\n\n                } else if (typeof label === 'number' && Math.floor(label) !== label) {\n                    return labelContext.error(`Numeric branch labels must be integer values.`);\n\n                } else if (!inputType) {\n                    inputType = typeOf(label);\n                } else if (labelContext.checkSubtype(inputType, typeOf(label))) {\n                    return null;\n                }\n\n                if (typeof cases[String(label)] !== 'undefined') {\n                    return labelContext.error('Branch labels must be unique.');\n                }\n\n                cases[String(label)] = outputs.length;\n            }\n\n            const result = context.parse(value, i, outputType);\n            if (!result) return null;\n            outputType = outputType || result.type;\n            outputs.push(result);\n        }\n\n        const input = context.parse(args[1], 1, ValueType);\n        if (!input) return null;\n\n        const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n        if (!otherwise) return null;\n\n        assert(inputType && outputType);\n\n        if (input.type.kind !== 'value' && context.concat(1).checkSubtype((inputType: any), input.type)) {\n            return null;\n        }\n\n        return new Match((inputType: any), (outputType: any), input, cases, outputs, otherwise);\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        const input = (this.input.evaluate(ctx): any);\n        const output = (typeOf(input) === this.inputType && this.outputs[this.cases[input]]) || this.otherwise;\n        return output.evaluate(ctx);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.input);\n        this.outputs.forEach(fn);\n        fn(this.otherwise);\n    }\n\n    outputDefined(): boolean {\n        return this.outputs.every(out => out.outputDefined()) && this.otherwise.outputDefined();\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"match\", this.input.serialize()];\n\n        // Sort so serialization has an arbitrary defined order, even though\n        // branch order doesn't affect evaluation\n        const sortedLabels = Object.keys(this.cases).sort();\n\n        // Group branches by unique match expression to support condensed\n        // serializations of the form [case1, case2, ...] -> matchExpression\n        const groupedByOutput: Array<[number, Array<number | string>]> = [];\n        const outputLookup: {[index: number]: number} = {}; // lookup index into groupedByOutput for a given output expression\n        for (const label of sortedLabels) {\n            const outputIndex = outputLookup[this.cases[label]];\n            if (outputIndex === undefined) {\n                // First time seeing this output, add it to the end of the grouped list\n                outputLookup[this.cases[label]] = groupedByOutput.length;\n                groupedByOutput.push([this.cases[label], [label]]);\n            } else {\n                // We've seen this expression before, add the label to that output's group\n                groupedByOutput[outputIndex][1].push(label);\n            }\n        }\n\n        const coerceLabel = (label) => this.inputType.kind === 'number' ? Number(label) : label;\n\n        for (const [outputIndex, labels] of groupedByOutput) {\n            if (labels.length === 1) {\n                // Only a single label matches this output expression\n                serialized.push(coerceLabel(labels[0]));\n            } else {\n                // Array of literal labels pointing to this output expression\n                serialized.push(labels.map(coerceLabel));\n            }\n            serialized.push(this.outputs[outputIndex].serialize());\n        }\n        serialized.push(this.otherwise.serialize());\n        return serialized;\n    }\n}\n\nexport default Match;\n","// @flow\n\nimport assert from 'assert';\n\nimport {BooleanType} from '../types.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\ntype Branches = Array<[Expression, Expression]>;\n\nclass Case implements Expression {\n    type: Type;\n\n    branches: Branches;\n    otherwise: Expression;\n\n    constructor(type: Type, branches: Branches, otherwise: Expression) {\n        this.type = type;\n        this.branches = branches;\n        this.otherwise = otherwise;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Case {\n        if (args.length < 4)\n            return context.error(`Expected at least 3 arguments, but found only ${args.length - 1}.`);\n        if (args.length % 2 !== 0)\n            return context.error(`Expected an odd number of arguments.`);\n\n        let outputType: ?Type;\n        if (context.expectedType && context.expectedType.kind !== 'value') {\n            outputType = context.expectedType;\n        }\n\n        const branches = [];\n        for (let i = 1; i < args.length - 1; i += 2) {\n            const test = context.parse(args[i], i, BooleanType);\n            if (!test) return null;\n\n            const result = context.parse(args[i + 1], i + 1, outputType);\n            if (!result) return null;\n\n            branches.push([test, result]);\n\n            outputType = outputType || result.type;\n        }\n\n        const otherwise = context.parse(args[args.length - 1], args.length - 1, outputType);\n        if (!otherwise) return null;\n\n        assert(outputType);\n        return new Case((outputType: any), branches, otherwise);\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        for (const [test, expression] of this.branches) {\n            if (test.evaluate(ctx)) {\n                return expression.evaluate(ctx);\n            }\n        }\n        return this.otherwise.evaluate(ctx);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        for (const [test, expression] of this.branches) {\n            fn(test);\n            fn(expression);\n        }\n        fn(this.otherwise);\n    }\n\n    outputDefined(): boolean {\n        return this.branches.every(([_, out]) => out.outputDefined()) && this.otherwise.outputDefined();\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"case\"];\n        this.eachChild(child => { serialized.push(child.serialize()); });\n        return serialized;\n    }\n}\n\nexport default Case;\n","// @flow\n\nimport {ValueType, NumberType, StringType, array, toString, isValidType, isValidNativeType} from '../types.js';\nimport RuntimeError from '../runtime_error.js';\nimport {typeOf} from '../values.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nclass Slice implements Expression {\n    type: Type;\n    input: Expression;\n    beginIndex: Expression;\n    endIndex: ?Expression;\n\n    constructor(type: Type, input: Expression, beginIndex: Expression, endIndex?: Expression) {\n        this.type = type;\n        this.input = input;\n        this.beginIndex = beginIndex;\n        this.endIndex = endIndex;\n\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Slice {\n        if (args.length <= 2 ||  args.length >= 5) {\n            return context.error(`Expected 3 or 4 arguments, but found ${args.length - 1} instead.`);\n        }\n\n        const input = context.parse(args[1], 1, ValueType);\n        const beginIndex = context.parse(args[2], 2, NumberType);\n\n        if (!input || !beginIndex) return null;\n\n        if (!isValidType(input.type, [array(ValueType), StringType, ValueType])) {\n            return context.error(`Expected first argument to be of type array or string, but found ${toString(input.type)} instead`);\n        }\n\n        if (args.length === 4) {\n            const endIndex = context.parse(args[3], 3, NumberType);\n            if (!endIndex) return null;\n            return new Slice(input.type, input, beginIndex, endIndex);\n        } else {\n            return new Slice(input.type, input, beginIndex);\n        }\n    }\n\n    evaluate(ctx: EvaluationContext): any {\n        const input = (this.input.evaluate(ctx): any);\n        const beginIndex = (this.beginIndex.evaluate(ctx): number);\n\n        if (!isValidNativeType(input, ['string', 'array'])) {\n            throw new RuntimeError(`Expected first argument to be of type array or string, but found ${toString(typeOf(input))} instead.`);\n        }\n\n        if (this.endIndex) {\n            const endIndex = (this.endIndex.evaluate(ctx): number);\n            return input.slice(beginIndex, endIndex);\n        }\n\n        return input.slice(beginIndex);\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.input);\n        fn(this.beginIndex);\n        if (this.endIndex) {\n            fn(this.endIndex);\n        }\n    }\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        if (this.endIndex != null && this.endIndex !== undefined) {\n            const endIndex = this.endIndex.serialize();\n            return [\"slice\", this.input.serialize(), this.beginIndex.serialize(), endIndex];\n        }\n        return [\"slice\", this.input.serialize(), this.beginIndex.serialize()];\n    }\n}\n\nexport default Slice;\n","// @flow\n\nimport {toString, ValueType, BooleanType, CollatorType} from '../types.js';\nimport Assertion from './assertion.js';\nimport {typeOf} from '../values.js';\nimport RuntimeError from '../runtime_error.js';\n\nimport type {Expression, SerializedExpression, ExpressionRegistration} from '../expression.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type {Type} from '../types.js';\n\ntype ComparisonOperator = '==' | '!=' | '<' | '>' | '<=' | '>=' ;\n\nfunction isComparableType(op: ComparisonOperator, type: Type) {\n    if (op === '==' || op === '!=') {\n        // equality operator\n        return type.kind === 'boolean' ||\n            type.kind === 'string' ||\n            type.kind === 'number' ||\n            type.kind === 'null' ||\n            type.kind === 'value';\n    } else {\n        // ordering operator\n        return type.kind === 'string' ||\n            type.kind === 'number' ||\n            type.kind === 'value';\n    }\n}\n\nfunction eq(ctx: EvaluationContext, a: any, b: any): boolean { return a === b; }\nfunction neq(ctx: EvaluationContext, a: any, b: any): boolean { return a !== b; }\nfunction lt(ctx: EvaluationContext, a: any, b: any): boolean { return a < b; }\nfunction gt(ctx: EvaluationContext, a: any, b: any): boolean { return a > b; }\nfunction lteq(ctx: EvaluationContext, a: any, b: any): boolean { return a <= b; }\nfunction gteq(ctx: EvaluationContext, a: any, b: any): boolean { return a >= b; }\n\nfunction eqCollate(ctx: EvaluationContext, a: any, b: any, c: any): boolean { return c.compare(a, b) === 0; }\nfunction neqCollate(ctx: EvaluationContext, a: any, b: any, c: any): boolean { return !eqCollate(ctx, a, b, c); }\nfunction ltCollate(ctx: EvaluationContext, a: any, b: any, c: any): boolean { return c.compare(a, b) < 0; }\nfunction gtCollate(ctx: EvaluationContext, a: any, b: any, c: any): boolean { return c.compare(a, b) > 0; }\nfunction lteqCollate(ctx: EvaluationContext, a: any, b: any, c: any): boolean { return c.compare(a, b) <= 0; }\nfunction gteqCollate(ctx: EvaluationContext, a: any, b: any, c: any): boolean { return c.compare(a, b) >= 0; }\n\n/**\n * Special form for comparison operators, implementing the signatures:\n * - (T, T, ?Collator) => boolean\n * - (T, value, ?Collator) => boolean\n * - (value, T, ?Collator) => boolean\n *\n * For inequalities, T must be either value, string, or number. For ==/!=, it\n * can also be boolean or null.\n *\n * Equality semantics are equivalent to Javascript's strict equality (===/!==)\n * -- i.e., when the arguments' types don't match, == evaluates to false, != to\n * true.\n *\n * When types don't match in an ordering comparison, a runtime error is thrown.\n *\n * @private\n */\nfunction makeComparison(op: ComparisonOperator, compareBasic: (EvaluationContext, any, any) => boolean, compareWithCollator: (EvaluationContext, any, any, any) => boolean): ExpressionRegistration {\n    const isOrderComparison = op !== '==' && op !== '!=';\n\n    return class Comparison implements Expression {\n        type: Type;\n        lhs: Expression;\n        rhs: Expression;\n        collator: ?Expression;\n        hasUntypedArgument: boolean;\n\n        constructor(lhs: Expression, rhs: Expression, collator: ?Expression) {\n            this.type = BooleanType;\n            this.lhs = lhs;\n            this.rhs = rhs;\n            this.collator = collator;\n            this.hasUntypedArgument = lhs.type.kind === 'value' || rhs.type.kind === 'value';\n        }\n\n        static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n            if (args.length !== 3 && args.length !== 4)\n                return context.error(`Expected two or three arguments.`);\n\n            const op: ComparisonOperator = (args[0]: any);\n\n            let lhs = context.parse(args[1], 1, ValueType);\n            if (!lhs) return null;\n            if (!isComparableType(op, lhs.type)) {\n                return context.concat(1).error(`\"${op}\" comparisons are not supported for type '${toString(lhs.type)}'.`);\n            }\n            let rhs = context.parse(args[2], 2, ValueType);\n            if (!rhs) return null;\n            if (!isComparableType(op, rhs.type)) {\n                return context.concat(2).error(`\"${op}\" comparisons are not supported for type '${toString(rhs.type)}'.`);\n            }\n\n            if (\n                lhs.type.kind !== rhs.type.kind &&\n                lhs.type.kind !== 'value' &&\n                rhs.type.kind !== 'value'\n            ) {\n                return context.error(`Cannot compare types '${toString(lhs.type)}' and '${toString(rhs.type)}'.`);\n            }\n\n            if (isOrderComparison) {\n                // typing rules specific to less/greater than operators\n                if (lhs.type.kind === 'value' && rhs.type.kind !== 'value') {\n                    // (value, T)\n                    lhs = new Assertion(rhs.type, [lhs]);\n                } else if (lhs.type.kind !== 'value' && rhs.type.kind === 'value') {\n                    // (T, value)\n                    rhs = new Assertion(lhs.type, [rhs]);\n                }\n            }\n\n            let collator = null;\n            if (args.length === 4) {\n                if (\n                    lhs.type.kind !== 'string' &&\n                    rhs.type.kind !== 'string' &&\n                    lhs.type.kind !== 'value' &&\n                    rhs.type.kind !== 'value'\n                ) {\n                    return context.error(`Cannot use collator to compare non-string types.`);\n                }\n                collator = context.parse(args[3], 3, CollatorType);\n                if (!collator) return null;\n            }\n\n            return new Comparison(lhs, rhs, collator);\n        }\n\n        evaluate(ctx: EvaluationContext): boolean {\n            const lhs = this.lhs.evaluate(ctx);\n            const rhs = this.rhs.evaluate(ctx);\n\n            if (isOrderComparison && this.hasUntypedArgument) {\n                const lt = typeOf(lhs);\n                const rt = typeOf(rhs);\n                // check that type is string or number, and equal\n                if (lt.kind !== rt.kind || !(lt.kind === 'string' || lt.kind === 'number')) {\n                    throw new RuntimeError(`Expected arguments for \"${op}\" to be (string, string) or (number, number), but found (${lt.kind}, ${rt.kind}) instead.`);\n                }\n            }\n\n            if (this.collator && !isOrderComparison && this.hasUntypedArgument) {\n                const lt = typeOf(lhs);\n                const rt = typeOf(rhs);\n                if (lt.kind !== 'string' || rt.kind !== 'string') {\n                    return compareBasic(ctx, lhs, rhs);\n                }\n            }\n\n            return this.collator ?\n                compareWithCollator(ctx, lhs, rhs, this.collator.evaluate(ctx)) :\n                compareBasic(ctx, lhs, rhs);\n        }\n\n        eachChild(fn: (_: Expression) => void) {\n            fn(this.lhs);\n            fn(this.rhs);\n            if (this.collator) {\n                fn(this.collator);\n            }\n        }\n\n        outputDefined(): boolean {\n            return true;\n        }\n\n        serialize(): SerializedExpression {\n            const serialized = [op];\n            this.eachChild(child => { serialized.push(child.serialize()); });\n            return serialized;\n        }\n    };\n}\n\nexport const Equals: $Call<typeof makeComparison, '==', typeof eq, typeof eqCollate> = makeComparison('==', eq, eqCollate);\nexport const NotEquals: $Call<typeof makeComparison, '!=', typeof neq, typeof neqCollate> = makeComparison('!=', neq, neqCollate);\nexport const LessThan: $Call<typeof makeComparison, '<', typeof lt, typeof ltCollate> = makeComparison('<', lt, ltCollate);\nexport const GreaterThan: $Call<typeof makeComparison, '>', typeof gt, typeof gtCollate> = makeComparison('>', gt, gtCollate);\nexport const LessThanOrEqual: $Call<typeof makeComparison, '<=', typeof lteq, typeof lteqCollate> = makeComparison('<=', lteq, lteqCollate);\nexport const GreaterThanOrEqual: $Call<typeof makeComparison, '>=', typeof gteq, typeof gteqCollate> = makeComparison('>=', gteq, gteqCollate);\n","// @flow\n\nimport {StringType, NumberType} from '../types.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type {Type} from '../types.js';\n\ndeclare var Intl: {\n    NumberFormat: Class<Intl$NumberFormat>\n};\n\ndeclare class Intl$NumberFormat {\n    constructor (\n        locales?: string | string[],\n        options?: NumberFormatOptions\n    ): Intl$NumberFormat;\n\n    static (\n        locales?: string | string[],\n        options?: NumberFormatOptions\n    ): Intl$NumberFormat;\n\n    format(a: number): string;\n\n    resolvedOptions(): any;\n}\n\ntype NumberFormatOptions = {\n    style?: 'decimal' | 'currency' | 'percent' | 'unit';\n    currency?: null | string;\n    unit?: null | string;\n    minimumFractionDigits?: null | string;\n    maximumFractionDigits?: null | string;\n};\n\nexport default class NumberFormat implements Expression {\n    type: Type;\n    number: Expression;\n    locale: Expression | null;   // BCP 47 language tag\n    currency: Expression | null; // ISO 4217 currency code, required if style=currency\n    unit: Expression | null;     // Simple units sanctioned for use in ECMAScript, required if style=unit. https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-issanctionedsimpleunitidentifier\n    minFractionDigits: Expression | null; // Default 0\n    maxFractionDigits: Expression | null; // Default 3\n\n    constructor(number: Expression,\n                locale: Expression | null,\n                currency: Expression | null,\n                unit: Expression | null,\n                minFractionDigits: Expression | null,\n                maxFractionDigits: Expression | null) {\n        this.type = StringType;\n        this.number = number;\n        this.locale = locale;\n        this.currency = currency;\n        this.unit = unit;\n        this.minFractionDigits = minFractionDigits;\n        this.maxFractionDigits = maxFractionDigits;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Expression {\n        if (args.length !== 3)\n            return context.error(`Expected two arguments.`);\n\n        const number = context.parse(args[1], 1, NumberType);\n        if (!number) return null;\n\n        const options = (args[2]: any);\n        if (typeof options !== \"object\" || Array.isArray(options))\n            return context.error(`NumberFormat options argument must be an object.`);\n\n        let locale = null;\n        if (options['locale']) {\n            locale = context.parse(options['locale'], 1, StringType);\n            if (!locale) return null;\n        }\n\n        let currency = null;\n        if (options['currency']) {\n            currency = context.parse(options['currency'], 1, StringType);\n            if (!currency) return null;\n        }\n\n        let unit = null;\n        if (options['unit']) {\n            unit = context.parse(options['unit'], 1, StringType);\n            if (!unit) return null;\n        }\n\n        let minFractionDigits = null;\n        if (options['min-fraction-digits']) {\n            minFractionDigits = context.parse(options['min-fraction-digits'], 1, NumberType);\n            if (!minFractionDigits) return null;\n        }\n\n        let maxFractionDigits = null;\n        if (options['max-fraction-digits']) {\n            maxFractionDigits = context.parse(options['max-fraction-digits'], 1, NumberType);\n            if (!maxFractionDigits) return null;\n        }\n\n        return new NumberFormat(number, locale, currency, unit, minFractionDigits, maxFractionDigits);\n    }\n\n    evaluate(ctx: EvaluationContext): string {\n        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(ctx) : [],\n            {\n                style:\n                    (this.currency && \"currency\") ||\n                    (this.unit && \"unit\") ||\n                    \"decimal\",\n                currency: this.currency ? this.currency.evaluate(ctx) : undefined,\n                unit: this.unit ? this.unit.evaluate(ctx) : undefined,\n                minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(ctx) : undefined,\n                maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(ctx) : undefined,\n            }).format(this.number.evaluate(ctx));\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.number);\n        if (this.locale) {\n            fn(this.locale);\n        }\n        if (this.currency) {\n            fn(this.currency);\n        }\n        if (this.unit) {\n            fn(this.unit);\n        }\n        if (this.minFractionDigits) {\n            fn(this.minFractionDigits);\n        }\n        if (this.maxFractionDigits) {\n            fn(this.maxFractionDigits);\n        }\n    }\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        const options = {};\n        if (this.locale) {\n            options['locale'] = this.locale.serialize();\n        }\n        if (this.currency) {\n            options['currency'] = this.currency.serialize();\n        }\n        if (this.unit) {\n            options['unit'] = this.unit.serialize();\n        }\n        if (this.minFractionDigits) {\n            options['min-fraction-digits'] = this.minFractionDigits.serialize();\n        }\n        if (this.maxFractionDigits) {\n            options['max-fraction-digits'] = this.maxFractionDigits.serialize();\n        }\n        return [\"number-format\", this.number.serialize(), options];\n    }\n}\n","// @flow\n\nimport {NumberType, toString} from '../types.js';\n\nimport {typeOf} from '../values.js';\nimport RuntimeError from '../runtime_error.js';\n\nimport type {Expression, SerializedExpression} from '../expression.js';\nimport type ParsingContext from '../parsing_context.js';\nimport type EvaluationContext from '../evaluation_context.js';\nimport type {Type} from '../types.js';\n\nclass Length implements Expression {\n    type: Type;\n    input: Expression;\n\n    constructor(input: Expression) {\n        this.type = NumberType;\n        this.input = input;\n    }\n\n    static parse(args: $ReadOnlyArray<mixed>, context: ParsingContext): ?Length {\n        if (args.length !== 2)\n            return context.error(`Expected 1 argument, but found ${args.length - 1} instead.`);\n\n        const input = context.parse(args[1], 1);\n        if (!input) return null;\n\n        if (input.type.kind !== 'array' && input.type.kind !== 'string' && input.type.kind !== 'value')\n            return context.error(`Expected argument of type string or array, but found ${toString(input.type)} instead.`);\n\n        return new Length(input);\n    }\n\n    evaluate(ctx: EvaluationContext): any | number {\n        const input = this.input.evaluate(ctx);\n        if (typeof input === 'string') {\n            return input.length;\n        } else if (Array.isArray(input)) {\n            return input.length;\n        } else {\n            throw new RuntimeError(`Expected value to be of type string or array, but found ${toString(typeOf(input))} instead.`);\n        }\n    }\n\n    eachChild(fn: (_: Expression) => void) {\n        fn(this.input);\n    }\n\n    outputDefined(): boolean {\n        return false;\n    }\n\n    serialize(): SerializedExpression {\n        const serialized = [\"length\"];\n        this.eachChild(child => { serialized.push(child.serialize()); });\n        return serialized;\n    }\n}\n\nexport default Length;\n","// @flow\n\nimport {\n    type Type,\n    NumberType,\n    StringType,\n    BooleanType,\n    ColorType,\n    ObjectType,\n    ValueType,\n    ErrorType,\n    CollatorType,\n    array,\n    toString as typeToString\n} from '../types.js';\n\nimport {typeOf, Color, validateRGBA, toString as valueToString} from '../values.js';\nimport CompoundExpression from '../compound_expression.js';\nimport RuntimeError from '../runtime_error.js';\nimport Let from './let.js';\nimport Var from './var.js';\nimport Literal from './literal.js';\nimport Assertion from './assertion.js';\nimport Coercion from './coercion.js';\nimport At from './at.js';\nimport In from './in.js';\nimport IndexOf from './index_of.js';\nimport Match from './match.js';\nimport Case from './case.js';\nimport Slice from './slice.js';\nimport Step from './step.js';\nimport Interpolate from './interpolate.js';\nimport Coalesce from './coalesce.js';\nimport {\n    Equals,\n    NotEquals,\n    LessThan,\n    GreaterThan,\n    LessThanOrEqual,\n    GreaterThanOrEqual\n} from './comparison.js';\nimport CollatorExpression from './collator.js';\nimport NumberFormat from './number_format.js';\nimport FormatExpression from './format.js';\nimport ImageExpression from './image.js';\nimport Length from './length.js';\nimport Within from './within.js';\n\nimport type {Varargs} from '../compound_expression.js';\nimport type {ExpressionRegistry} from '../expression.js';\n\nconst expressions: ExpressionRegistry = {\n    // special forms\n    '==': Equals,\n    '!=': NotEquals,\n    '>': GreaterThan,\n    '<': LessThan,\n    '>=': GreaterThanOrEqual,\n    '<=': LessThanOrEqual,\n    'array': Assertion,\n    'at': At,\n    'boolean': Assertion,\n    'case': Case,\n    'coalesce': Coalesce,\n    'collator': CollatorExpression,\n    'format': FormatExpression,\n    'image': ImageExpression,\n    'in': In,\n    'index-of': IndexOf,\n    'interpolate': Interpolate,\n    'interpolate-hcl': Interpolate,\n    'interpolate-lab': Interpolate,\n    'length': Length,\n    'let': Let,\n    'literal': Literal,\n    'match': Match,\n    'number': Assertion,\n    'number-format': NumberFormat,\n    'object': Assertion,\n    'slice': Slice,\n    'step': Step,\n    'string': Assertion,\n    'to-boolean': Coercion,\n    'to-color': Coercion,\n    'to-number': Coercion,\n    'to-string': Coercion,\n    'var': Var,\n    'within': Within\n};\n\nfunction rgba(ctx, [r, g, b, a]) {\n    r = r.evaluate(ctx);\n    g = g.evaluate(ctx);\n    b = b.evaluate(ctx);\n    const alpha = a ? a.evaluate(ctx) : 1;\n    const error = validateRGBA(r, g, b, alpha);\n    if (error) throw new RuntimeError(error);\n    return new Color(r / 255 * alpha, g / 255 * alpha, b / 255 * alpha, alpha);\n}\n\nfunction has(key, obj) {\n    return key in obj;\n}\n\nfunction get(key, obj) {\n    const v = obj[key];\n    return typeof v === 'undefined' ? null : v;\n}\n\nfunction binarySearch(v, a, i, j) {\n    while (i <= j) {\n        const m = (i + j) >> 1;\n        if (a[m] === v)\n            return true;\n        if (a[m] > v)\n            j = m - 1;\n        else\n            i = m + 1;\n    }\n    return false;\n}\n\nfunction varargs(type: Type): Varargs {\n    return {type};\n}\n\nCompoundExpression.register(expressions, {\n    'error': [\n        ErrorType,\n        [StringType],\n        (ctx, [v]) => { throw new RuntimeError(v.evaluate(ctx)); }\n    ],\n    'typeof': [\n        StringType,\n        [ValueType],\n        (ctx, [v]) => typeToString(typeOf(v.evaluate(ctx)))\n    ],\n    'to-rgba': [\n        array(NumberType, 4),\n        [ColorType],\n        (ctx, [v]) => {\n            return v.evaluate(ctx).toArray();\n        }\n    ],\n    'rgb': [\n        ColorType,\n        [NumberType, NumberType, NumberType],\n        rgba\n    ],\n    'rgba': [\n        ColorType,\n        [NumberType, NumberType, NumberType, NumberType],\n        rgba\n    ],\n    'has': {\n        type: BooleanType,\n        overloads: [\n            [\n                [StringType],\n                (ctx, [key]) => has(key.evaluate(ctx), ctx.properties())\n            ], [\n                [StringType, ObjectType],\n                (ctx, [key, obj]) => has(key.evaluate(ctx), obj.evaluate(ctx))\n            ]\n        ]\n    },\n    'get': {\n        type: ValueType,\n        overloads: [\n            [\n                [StringType],\n                (ctx, [key]) => get(key.evaluate(ctx), ctx.properties())\n            ], [\n                [StringType, ObjectType],\n                (ctx, [key, obj]) => get(key.evaluate(ctx), obj.evaluate(ctx))\n            ]\n        ]\n    },\n    'feature-state': [\n        ValueType,\n        [StringType],\n        (ctx, [key]) => get(key.evaluate(ctx), ctx.featureState || {})\n    ],\n    'properties': [\n        ObjectType,\n        [],\n        (ctx) => ctx.properties()\n    ],\n    'geometry-type': [\n        StringType,\n        [],\n        (ctx) => ctx.geometryType()\n    ],\n    'id': [\n        ValueType,\n        [],\n        (ctx) => ctx.id()\n    ],\n    'zoom': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.zoom\n    ],\n    'pitch': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.pitch || 0\n    ],\n    'distance-from-center': [\n        NumberType,\n        [],\n        (ctx) => ctx.distanceFromCenter()\n    ],\n    'heatmap-density': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.heatmapDensity || 0\n    ],\n    'line-progress': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.lineProgress || 0\n    ],\n    'sky-radial-progress': [\n        NumberType,\n        [],\n        (ctx) => ctx.globals.skyRadialProgress || 0\n    ],\n    'accumulated': [\n        ValueType,\n        [],\n        (ctx) => ctx.globals.accumulated === undefined ? null : ctx.globals.accumulated\n    ],\n    '+': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => {\n            let result = 0;\n            for (const arg of args) {\n                result += arg.evaluate(ctx);\n            }\n            return result;\n        }\n    ],\n    '*': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => {\n            let result = 1;\n            for (const arg of args) {\n                result *= arg.evaluate(ctx);\n            }\n            return result;\n        }\n    ],\n    '-': {\n        type: NumberType,\n        overloads: [\n            [\n                [NumberType, NumberType],\n                (ctx, [a, b]) => a.evaluate(ctx) - b.evaluate(ctx)\n            ], [\n                [NumberType],\n                (ctx, [a]) => -a.evaluate(ctx)\n            ]\n        ]\n    },\n    '/': [\n        NumberType,\n        [NumberType, NumberType],\n        (ctx, [a, b]) => a.evaluate(ctx) / b.evaluate(ctx)\n    ],\n    '%': [\n        NumberType,\n        [NumberType, NumberType],\n        (ctx, [a, b]) => a.evaluate(ctx) % b.evaluate(ctx)\n    ],\n    'ln2': [\n        NumberType,\n        [],\n        () => Math.LN2\n    ],\n    'pi': [\n        NumberType,\n        [],\n        () => Math.PI\n    ],\n    'e': [\n        NumberType,\n        [],\n        () => Math.E\n    ],\n    '^': [\n        NumberType,\n        [NumberType, NumberType],\n        (ctx, [b, e]) => Math.pow(b.evaluate(ctx), e.evaluate(ctx))\n    ],\n    'sqrt': [\n        NumberType,\n        [NumberType],\n        (ctx, [x]) => Math.sqrt(x.evaluate(ctx))\n    ],\n    'log10': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN10\n    ],\n    'ln': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.log(n.evaluate(ctx))\n    ],\n    'log2': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.log(n.evaluate(ctx)) / Math.LN2\n    ],\n    'sin': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.sin(n.evaluate(ctx))\n    ],\n    'cos': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.cos(n.evaluate(ctx))\n    ],\n    'tan': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.tan(n.evaluate(ctx))\n    ],\n    'asin': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.asin(n.evaluate(ctx))\n    ],\n    'acos': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.acos(n.evaluate(ctx))\n    ],\n    'atan': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.atan(n.evaluate(ctx))\n    ],\n    'min': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => Math.min(...args.map(arg => arg.evaluate(ctx)))\n    ],\n    'max': [\n        NumberType,\n        varargs(NumberType),\n        (ctx, args) => Math.max(...args.map(arg => arg.evaluate(ctx)))\n    ],\n    'abs': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.abs(n.evaluate(ctx))\n    ],\n    'round': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => {\n            const v = n.evaluate(ctx);\n            // Javascript's Math.round() rounds towards +Infinity for halfway\n            // values, even when they're negative. It's more common to round\n            // away from 0 (e.g., this is what python and C++ do)\n            return v < 0 ? -Math.round(-v) : Math.round(v);\n        }\n    ],\n    'floor': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.floor(n.evaluate(ctx))\n    ],\n    'ceil': [\n        NumberType,\n        [NumberType],\n        (ctx, [n]) => Math.ceil(n.evaluate(ctx))\n    ],\n    'filter-==': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => ctx.properties()[(k: any).value] === (v: any).value\n    ],\n    'filter-id-==': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => ctx.id() === (v: any).value\n    ],\n    'filter-type-==': [\n        BooleanType,\n        [StringType],\n        (ctx, [v]) => ctx.geometryType() === (v: any).value\n    ],\n    'filter-<': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[(k: any).value];\n            const b = (v: any).value;\n            return typeof a === typeof b && a < b;\n        }\n    ],\n    'filter-id-<': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = (v: any).value;\n            return typeof a === typeof b && a < b;\n        }\n    ],\n    'filter->': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[(k: any).value];\n            const b = (v: any).value;\n            return typeof a === typeof b && a > b;\n        }\n    ],\n    'filter-id->': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = (v: any).value;\n            return typeof a === typeof b && a > b;\n        }\n    ],\n    'filter-<=': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[(k: any).value];\n            const b = (v: any).value;\n            return typeof a === typeof b && a <= b;\n        }\n    ],\n    'filter-id-<=': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = (v: any).value;\n            return typeof a === typeof b && a <= b;\n        }\n    ],\n    'filter->=': [\n        BooleanType,\n        [StringType, ValueType],\n        (ctx, [k, v]) => {\n            const a = ctx.properties()[(k: any).value];\n            const b = (v: any).value;\n            return typeof a === typeof b && a >= b;\n        }\n    ],\n    'filter-id->=': [\n        BooleanType,\n        [ValueType],\n        (ctx, [v]) => {\n            const a = ctx.id();\n            const b = (v: any).value;\n            return typeof a === typeof b && a >= b;\n        }\n    ],\n    'filter-has': [\n        BooleanType,\n        [ValueType],\n        (ctx, [k]) => (k: any).value in ctx.properties()\n    ],\n    'filter-has-id': [\n        BooleanType,\n        [],\n        (ctx) => (ctx.id() !== null && ctx.id() !== undefined)\n    ],\n    'filter-type-in': [\n        BooleanType,\n        [array(StringType)],\n        (ctx, [v]) => (v: any).value.indexOf(ctx.geometryType()) >= 0\n    ],\n    'filter-id-in': [\n        BooleanType,\n        [array(ValueType)],\n        (ctx, [v]) => (v: any).value.indexOf(ctx.id()) >= 0\n    ],\n    'filter-in-small': [\n        BooleanType,\n        [StringType, array(ValueType)],\n        // assumes v is an array literal\n        (ctx, [k, v]) => (v: any).value.indexOf(ctx.properties()[(k: any).value]) >= 0\n    ],\n    'filter-in-large': [\n        BooleanType,\n        [StringType, array(ValueType)],\n        // assumes v is a array literal with values sorted in ascending order and of a single type\n        (ctx, [k, v]) => binarySearch(ctx.properties()[(k: any).value], (v: any).value, 0, (v: any).value.length - 1)\n    ],\n    'all': {\n        type: BooleanType,\n        overloads: [\n            [\n                [BooleanType, BooleanType],\n                (ctx, [a, b]) => a.evaluate(ctx) && b.evaluate(ctx)\n            ],\n            [\n                varargs(BooleanType),\n                (ctx, args) => {\n                    for (const arg of args) {\n                        if (!arg.evaluate(ctx))\n                            return false;\n                    }\n                    return true;\n                }\n            ]\n        ]\n    },\n    'any': {\n        type: BooleanType,\n        overloads: [\n            [\n                [BooleanType, BooleanType],\n                (ctx, [a, b]) => a.evaluate(ctx) || b.evaluate(ctx)\n            ],\n            [\n                varargs(BooleanType),\n                (ctx, args) => {\n                    for (const arg of args) {\n                        if (arg.evaluate(ctx))\n                            return true;\n                    }\n                    return false;\n                }\n            ]\n        ]\n    },\n    '!': [\n        BooleanType,\n        [BooleanType],\n        (ctx, [b]) => !b.evaluate(ctx)\n    ],\n    'is-supported-script': [\n        BooleanType,\n        [StringType],\n        // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant\n        (ctx, [s]) => {\n            const isSupportedScript = ctx.globals && ctx.globals.isSupportedScript;\n            if (isSupportedScript) {\n                return isSupportedScript(s.evaluate(ctx));\n            }\n            return true;\n        }\n    ],\n    'upcase': [\n        StringType,\n        [StringType],\n        (ctx, [s]) => s.evaluate(ctx).toUpperCase()\n    ],\n    'downcase': [\n        StringType,\n        [StringType],\n        (ctx, [s]) => s.evaluate(ctx).toLowerCase()\n    ],\n    'concat': [\n        StringType,\n        varargs(ValueType),\n        (ctx, args) => args.map(arg => valueToString(arg.evaluate(ctx))).join('')\n    ],\n    'resolved-locale': [\n        StringType,\n        [CollatorType],\n        (ctx, [collator]) => collator.evaluate(ctx).resolvedLocale()\n    ]\n});\n\nexport default expressions;\n","// @flow\n\n/**\n * A type used for returning and propagating errors. The first element of the union\n * represents success and contains a value, and the second represents an error and\n * contains an error value.\n * @private\n */\nexport type Result<T, E> =\n    | {| result: 'success', value: T |}\n    | {| result: 'error', value: E |};\n\nexport function success<T, E>(value: T): Result<T, E> {\n    return {result: 'success', value};\n}\n\nexport function error<T, E>(value: E): Result<T, E> {\n    return {result: 'error', value};\n}\n","// @flow\n\nimport type {StylePropertySpecification} from '../style-spec.js';\n\nexport function supportsPropertyExpression(spec: StylePropertySpecification): boolean {\n    return spec['property-type'] === 'data-driven';\n}\n\nexport function supportsZoomExpression(spec: StylePropertySpecification): boolean {\n    return !!spec.expression && spec.expression.parameters.indexOf('zoom') > -1;\n}\n\nexport function supportsInterpolation(spec: StylePropertySpecification): boolean {\n    return !!spec.expression && spec.expression.interpolated;\n}\n","// @flow\n\nexport default function getType(val: mixed): string {\n    if (val instanceof Number) {\n        return 'number';\n    } else if (val instanceof String) {\n        return 'string';\n    } else if (val instanceof Boolean) {\n        return 'boolean';\n    } else if (Array.isArray(val)) {\n        return 'array';\n    } else if (val === null) {\n        return 'null';\n    } else {\n        return typeof val;\n    }\n}\n","\nimport * as colorSpaces from '../util/color_spaces.js';\nimport Color from '../util/color.js';\nimport extend from '../util/extend.js';\nimport getType from '../util/get_type.js';\nimport * as interpolate from '../util/interpolate.js';\nimport Interpolate from '../expression/definitions/interpolate.js';\nimport Formatted from '../expression/types/formatted.js';\nimport ResolvedImage from '../expression/types/resolved_image.js';\nimport {supportsInterpolation} from '../util/properties.js';\nimport {findStopLessThanOrEqualTo} from '../expression/stops.js';\n\nexport function isFunction(value) {\n    return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nfunction identityFunction(x) {\n    return x;\n}\n\nexport function createFunction(parameters, propertySpec) {\n    const isColor = propertySpec.type === 'color';\n    const zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';\n    const featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n    const zoomDependent = zoomAndFeatureDependent || !featureDependent;\n    const type = parameters.type || (supportsInterpolation(propertySpec) ? 'exponential' : 'interval');\n\n    if (isColor) {\n        parameters = extend({}, parameters);\n\n        if (parameters.stops) {\n            parameters.stops = parameters.stops.map((stop) => {\n                return [stop[0], Color.parse(stop[1])];\n            });\n        }\n\n        if (parameters.default) {\n            parameters.default = Color.parse(parameters.default);\n        } else {\n            parameters.default = Color.parse(propertySpec.default);\n        }\n    }\n\n    if (parameters.colorSpace && parameters.colorSpace !== 'rgb' && !colorSpaces[parameters.colorSpace]) { // eslint-disable-line import/namespace\n        throw new Error(`Unknown color space: ${parameters.colorSpace}`);\n    }\n\n    let innerFun;\n    let hashedStops;\n    let categoricalKeyType;\n    if (type === 'exponential') {\n        innerFun = evaluateExponentialFunction;\n    } else if (type === 'interval') {\n        innerFun = evaluateIntervalFunction;\n    } else if (type === 'categorical') {\n        innerFun = evaluateCategoricalFunction;\n\n        // For categorical functions, generate an Object as a hashmap of the stops for fast searching\n        hashedStops = Object.create(null);\n        for (const stop of parameters.stops) {\n            hashedStops[stop[0]] = stop[1];\n        }\n\n        // Infer key type based on first stop key-- used to encforce strict type checking later\n        categoricalKeyType = typeof parameters.stops[0][0];\n\n    } else if (type === 'identity') {\n        innerFun = evaluateIdentityFunction;\n    } else {\n        throw new Error(`Unknown function type \"${type}\"`);\n    }\n\n    if (zoomAndFeatureDependent) {\n        const featureFunctions = {};\n        const zoomStops = [];\n        for (let s = 0; s < parameters.stops.length; s++) {\n            const stop = parameters.stops[s];\n            const zoom = stop[0].zoom;\n            if (featureFunctions[zoom] === undefined) {\n                featureFunctions[zoom] = {\n                    zoom,\n                    type: parameters.type,\n                    property: parameters.property,\n                    default: parameters.default,\n                    stops: []\n                };\n                zoomStops.push(zoom);\n            }\n            featureFunctions[zoom].stops.push([stop[0].value, stop[1]]);\n        }\n\n        const featureFunctionStops = [];\n        for (const z of zoomStops) {\n            featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z], propertySpec)]);\n        }\n\n        const interpolationType = {name: 'linear'};\n        return {\n            kind: 'composite',\n            interpolationType,\n            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n            zoomStops: featureFunctionStops.map(s => s[0]),\n            evaluate({zoom}, properties) {\n                return evaluateExponentialFunction({\n                    stops: featureFunctionStops,\n                    base: parameters.base\n                }, propertySpec, zoom).evaluate(zoom, properties);\n            }\n        };\n    } else if (zoomDependent) {\n        const interpolationType = type === 'exponential' ?\n            {name: 'exponential', base: parameters.base !== undefined ? parameters.base : 1} : null;\n        return {\n            kind: 'camera',\n            interpolationType,\n            interpolationFactor: Interpolate.interpolationFactor.bind(undefined, interpolationType),\n            zoomStops: parameters.stops.map(s => s[0]),\n            evaluate: ({zoom}) => innerFun(parameters, propertySpec, zoom, hashedStops, categoricalKeyType)\n        };\n    } else {\n        return {\n            kind: 'source',\n            evaluate(_, feature) {\n                const value = feature && feature.properties ? feature.properties[parameters.property] : undefined;\n                if (value === undefined) {\n                    return coalesce(parameters.default, propertySpec.default);\n                }\n                return innerFun(parameters, propertySpec, value, hashedStops, categoricalKeyType);\n            }\n        };\n    }\n}\n\nfunction coalesce(a, b, c) {\n    if (a !== undefined) return a;\n    if (b !== undefined) return b;\n    if (c !== undefined) return c;\n}\n\nfunction evaluateCategoricalFunction(parameters, propertySpec, input, hashedStops, keyType) {\n    const evaluated = typeof input === keyType ? hashedStops[input] : undefined; // Enforce strict typing on input\n    return coalesce(evaluated, parameters.default, propertySpec.default);\n}\n\nfunction evaluateIntervalFunction(parameters, propertySpec, input) {\n    // Edge cases\n    if (getType(input) !== 'number') return coalesce(parameters.default, propertySpec.default);\n    const n = parameters.stops.length;\n    if (n === 1) return parameters.stops[0][1];\n    if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n    if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n\n    const index = findStopLessThanOrEqualTo(parameters.stops.map((stop) => stop[0]), input);\n\n    return parameters.stops[index][1];\n}\n\nfunction evaluateExponentialFunction(parameters, propertySpec, input) {\n    const base = parameters.base !== undefined ? parameters.base : 1;\n\n    // Edge cases\n    if (getType(input) !== 'number') return coalesce(parameters.default, propertySpec.default);\n    const n = parameters.stops.length;\n    if (n === 1) return parameters.stops[0][1];\n    if (input <= parameters.stops[0][0]) return parameters.stops[0][1];\n    if (input >= parameters.stops[n - 1][0]) return parameters.stops[n - 1][1];\n\n    const index = findStopLessThanOrEqualTo(parameters.stops.map((stop) => stop[0]), input);\n    const t = interpolationFactor(\n        input, base,\n        parameters.stops[index][0],\n        parameters.stops[index + 1][0]);\n\n    const outputLower = parameters.stops[index][1];\n    const outputUpper = parameters.stops[index + 1][1];\n    let interp = interpolate[propertySpec.type] || identityFunction; // eslint-disable-line import/namespace\n\n    if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {\n        const colorspace = colorSpaces[parameters.colorSpace]; // eslint-disable-line import/namespace\n        interp = (a, b) => colorspace.reverse(colorspace.interpolate(colorspace.forward(a), colorspace.forward(b), t));\n    }\n\n    if (typeof outputLower.evaluate === 'function') {\n        return {\n            evaluate(...args) {\n                const evaluatedLower = outputLower.evaluate.apply(undefined, args);\n                const evaluatedUpper = outputUpper.evaluate.apply(undefined, args);\n                // Special case for fill-outline-color, which has no spec default.\n                if (evaluatedLower === undefined || evaluatedUpper === undefined) {\n                    return undefined;\n                }\n                return interp(evaluatedLower, evaluatedUpper, t);\n            }\n        };\n    }\n\n    return interp(outputLower, outputUpper, t);\n}\n\nfunction evaluateIdentityFunction(parameters, propertySpec, input) {\n    if (propertySpec.type === 'color') {\n        input = Color.parse(input);\n    } else if (propertySpec.type === 'formatted') {\n        input = Formatted.fromString(input.toString());\n    } else if (propertySpec.type === 'resolvedImage') {\n        input = ResolvedImage.fromString(input.toString());\n    } else if (getType(input) !== propertySpec.type && (propertySpec.type !== 'enum' || !propertySpec.values[input])) {\n        input = undefined;\n    }\n    return coalesce(input, parameters.default, propertySpec.default);\n}\n\n/**\n * Returns a ratio that can be used to interpolate between exponential function\n * stops.\n *\n * How it works:\n * Two consecutive stop values define a (scaled and shifted) exponential\n * function `f(x) = a * base^x + b`, where `base` is the user-specified base,\n * and `a` and `b` are constants affording sufficient degrees of freedom to fit\n * the function to the given stops.\n *\n * Here's a bit of algebra that lets us compute `f(x)` directly from the stop\n * values without explicitly solving for `a` and `b`:\n *\n * First stop value: `f(x0) = y0 = a * base^x0 + b`\n * Second stop value: `f(x1) = y1 = a * base^x1 + b`\n * => `y1 - y0 = a(base^x1 - base^x0)`\n * => `a = (y1 - y0)/(base^x1 - base^x0)`\n *\n * Desired value: `f(x) = y = a * base^x + b`\n * => `f(x) = y0 + a * (base^x - base^x0)`\n *\n * From the above, we can replace the `a` in `a * (base^x - base^x0)` and do a\n * little algebra:\n * ```\n * a * (base^x - base^x0) = (y1 - y0)/(base^x1 - base^x0) * (base^x - base^x0)\n *                     = (y1 - y0) * (base^x - base^x0) / (base^x1 - base^x0)\n * ```\n *\n * If we let `(base^x - base^x0) / (base^x1 base^x0)`, then we have\n * `f(x) = y0 + (y1 - y0) * ratio`.  In other words, `ratio` may be treated as\n * an interpolation factor between the two stops' output values.\n *\n * (Note: a slightly different form for `ratio`,\n * `(base^(x-x0) - 1) / (base^(x1-x0) - 1) `, is equivalent, but requires fewer\n * expensive `Math.pow()` operations.)\n *\n * @private\n */\nfunction interpolationFactor(input, base, lowerValue, upperValue) {\n    const difference = upperValue - lowerValue;\n    const progress = input - lowerValue;\n\n    if (difference === 0) {\n        return 0;\n    } else if (base === 1) {\n        return progress / difference;\n    } else {\n        return (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);\n    }\n}\n","// @flow\n\nimport assert from 'assert';\n\nimport extend from '../util/extend.js';\nimport ParsingError from './parsing_error.js';\nimport ParsingContext from './parsing_context.js';\nimport EvaluationContext from './evaluation_context.js';\nimport CompoundExpression from './compound_expression.js';\nimport Step from './definitions/step.js';\nimport Interpolate from './definitions/interpolate.js';\nimport Coalesce from './definitions/coalesce.js';\nimport Let from './definitions/let.js';\nimport definitions from './definitions/index.js';\nimport * as isConstant from './is_constant.js';\nimport RuntimeError from './runtime_error.js';\nimport {success, error} from '../util/result.js';\nimport {supportsPropertyExpression, supportsZoomExpression, supportsInterpolation} from '../util/properties.js';\n\nimport type {Type, EvaluationKind} from './types.js';\nimport type {Value} from './values.js';\nimport type {Expression} from './expression.js';\nimport type {StylePropertySpecification} from '../style-spec.js';\nimport type {Result} from '../util/result.js';\nimport type {InterpolationType} from './definitions/interpolate.js';\nimport type {PropertyValueSpecification} from '../types.js';\nimport type {FormattedSection} from './types/formatted.js';\nimport type Point from '@mapbox/point-geometry';\nimport type {CanonicalTileID} from '../../source/tile_id.js';\nimport type {FeatureDistanceData} from '../feature_filter/index.js';\n\nexport type Feature = {\n    +type: 1 | 2 | 3 | 'Unknown' | 'Point' | 'LineString' | 'Polygon',\n    +id?: number | null,\n    +properties: {[_: string]: any},\n    +patterns?: {[_: string]: string},\n    +geometry?: Array<Array<Point>>\n};\n\nexport type FeatureState = {[_: string]: any};\n\nexport type GlobalProperties = $ReadOnly<{\n    zoom: number,\n    pitch?: number,\n    heatmapDensity?: number,\n    lineProgress?: number,\n    skyRadialProgress?: number,\n    isSupportedScript?: (_: string) => boolean,\n    accumulated?: Value\n}>;\n\nexport class StyleExpression {\n    expression: Expression;\n\n    _evaluator: EvaluationContext;\n    _defaultValue: Value;\n    _warningHistory: {[key: string]: boolean};\n    _enumValues: ?{[_: string]: any};\n\n    constructor(expression: Expression, propertySpec: ?StylePropertySpecification) {\n        this.expression = expression;\n        this._warningHistory = {};\n        this._evaluator = new EvaluationContext();\n        this._defaultValue = propertySpec ? getDefaultValue(propertySpec) : null;\n        this._enumValues = propertySpec && propertySpec.type === 'enum' ? propertySpec.values : null;\n    }\n\n    evaluateWithoutErrorHandling(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection, featureTileCoord?: Point, featureDistanceData?: FeatureDistanceData): any {\n        this._evaluator.globals = globals;\n        this._evaluator.feature = feature;\n        this._evaluator.featureState = featureState;\n        this._evaluator.canonical = canonical || null;\n        this._evaluator.availableImages = availableImages || null;\n        this._evaluator.formattedSection = formattedSection;\n        this._evaluator.featureTileCoord = featureTileCoord || null;\n        this._evaluator.featureDistanceData = featureDistanceData || null;\n\n        return this.expression.evaluate(this._evaluator);\n    }\n\n    evaluate(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection, featureTileCoord?: Point, featureDistanceData?: FeatureDistanceData): any {\n        this._evaluator.globals = globals;\n        this._evaluator.feature = feature || null;\n        this._evaluator.featureState = featureState || null;\n        this._evaluator.canonical = canonical || null;\n        this._evaluator.availableImages = availableImages || null;\n        this._evaluator.formattedSection = formattedSection || null;\n        this._evaluator.featureTileCoord = featureTileCoord || null;\n        this._evaluator.featureDistanceData = featureDistanceData || null;\n\n        try {\n            const val = this.expression.evaluate(this._evaluator);\n            // eslint-disable-next-line no-self-compare\n            if (val === null || val === undefined || (typeof val === 'number' && val !== val)) {\n                return this._defaultValue;\n            }\n            if (this._enumValues && !(val in this._enumValues)) {\n                throw new RuntimeError(`Expected value to be one of ${Object.keys(this._enumValues).map(v => JSON.stringify(v)).join(', ')}, but found ${JSON.stringify(val)} instead.`);\n            }\n            return val;\n        } catch (e) {\n            if (!this._warningHistory[e.message]) {\n                this._warningHistory[e.message] = true;\n                if (typeof console !== 'undefined') {\n                    console.warn(e.message);\n                }\n            }\n            return this._defaultValue;\n        }\n    }\n}\n\nexport function isExpression(expression: mixed): boolean {\n    return Array.isArray(expression) && expression.length > 0 &&\n        typeof expression[0] === 'string' && expression[0] in definitions;\n}\n\n/**\n * Parse and typecheck the given style spec JSON expression.  If\n * options.defaultValue is provided, then the resulting StyleExpression's\n * `evaluate()` method will handle errors by logging a warning (once per\n * message) and returning the default value.  Otherwise, it will throw\n * evaluation errors.\n *\n * @private\n */\nexport function createExpression(expression: mixed, propertySpec: ?StylePropertySpecification): Result<StyleExpression, Array<ParsingError>> {\n    const parser = new ParsingContext(definitions, [], propertySpec ? getExpectedType(propertySpec) : undefined);\n\n    // For string-valued properties, coerce to string at the top level rather than asserting.\n    const parsed = parser.parse(expression, undefined, undefined, undefined,\n        propertySpec && propertySpec.type === 'string' ? {typeAnnotation: 'coerce'} : undefined);\n\n    if (!parsed) {\n        assert(parser.errors.length > 0);\n        return error(parser.errors);\n    }\n\n    return success(new StyleExpression(parsed, propertySpec));\n}\n\nexport class ZoomConstantExpression<Kind: EvaluationKind> {\n    kind: Kind;\n    isStateDependent: boolean;\n    _styleExpression: StyleExpression;\n\n    constructor(kind: Kind, expression: StyleExpression) {\n        this.kind = kind;\n        this._styleExpression = expression;\n        this.isStateDependent = kind !== ('constant': EvaluationKind) && !isConstant.isStateConstant(expression.expression);\n    }\n\n    evaluateWithoutErrorHandling(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n\n    evaluate(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n}\n\nexport class ZoomDependentExpression<Kind: EvaluationKind> {\n    kind: Kind;\n    zoomStops: Array<number>;\n    isStateDependent: boolean;\n\n    _styleExpression: StyleExpression;\n    interpolationType: ?InterpolationType;\n\n    constructor(kind: Kind, expression: StyleExpression, zoomStops: Array<number>, interpolationType?: InterpolationType) {\n        this.kind = kind;\n        this.zoomStops = zoomStops;\n        this._styleExpression = expression;\n        this.isStateDependent = kind !== ('camera': EvaluationKind) && !isConstant.isStateConstant(expression.expression);\n        this.interpolationType = interpolationType;\n    }\n\n    evaluateWithoutErrorHandling(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluateWithoutErrorHandling(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n\n    evaluate(globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection): any {\n        return this._styleExpression.evaluate(globals, feature, featureState, canonical, availableImages, formattedSection);\n    }\n\n    interpolationFactor(input: number, lower: number, upper: number): number {\n        if (this.interpolationType) {\n            return Interpolate.interpolationFactor(this.interpolationType, input, lower, upper);\n        } else {\n            return 0;\n        }\n    }\n}\n\nexport type ConstantExpression = {\n    kind: 'constant',\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>) => any,\n}\n\nexport type SourceExpression = {\n    kind: 'source',\n    isStateDependent: boolean,\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection) => any,\n};\n\nexport type CameraExpression = {\n    kind: 'camera',\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>) => any,\n    +interpolationFactor: (input: number, lower: number, upper: number) => number,\n    zoomStops: Array<number>,\n    interpolationType: ?InterpolationType\n};\n\nexport type CompositeExpression = {\n    kind: 'composite',\n    isStateDependent: boolean,\n    +evaluate: (globals: GlobalProperties, feature?: Feature, featureState?: FeatureState, canonical?: CanonicalTileID, availableImages?: Array<string>, formattedSection?: FormattedSection) => any,\n    +interpolationFactor: (input: number, lower: number, upper: number) => number,\n    zoomStops: Array<number>,\n    interpolationType: ?InterpolationType\n};\n\nexport type StylePropertyExpression =\n    | ConstantExpression\n    | SourceExpression\n    | CameraExpression\n    | CompositeExpression;\n\nexport function createPropertyExpression(expression: mixed, propertySpec: StylePropertySpecification): Result<StylePropertyExpression, Array<ParsingError>> {\n    expression = createExpression(expression, propertySpec);\n    if (expression.result === 'error') {\n        return expression;\n    }\n\n    const parsed = expression.value.expression;\n\n    const isFeatureConstant = isConstant.isFeatureConstant(parsed);\n    if (!isFeatureConstant && !supportsPropertyExpression(propertySpec)) {\n        return error([new ParsingError('', 'data expressions not supported')]);\n    }\n\n    const isZoomConstant = isConstant.isGlobalPropertyConstant(parsed, ['zoom', 'pitch', 'distance-from-center']);\n    if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {\n        return error([new ParsingError('', 'zoom expressions not supported')]);\n    }\n\n    const zoomCurve = findZoomCurve(parsed);\n    if (!zoomCurve && !isZoomConstant) {\n        return error([new ParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.')]);\n    } else if (zoomCurve instanceof ParsingError) {\n        return error([zoomCurve]);\n    } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {\n        return error([new ParsingError('', '\"interpolate\" expressions cannot be used with this property')]);\n    }\n\n    if (!zoomCurve) {\n        return success(isFeatureConstant ?\n            (new ZoomConstantExpression('constant', expression.value): ConstantExpression) :\n            (new ZoomConstantExpression('source', expression.value): SourceExpression));\n    }\n\n    const interpolationType = zoomCurve instanceof Interpolate ? zoomCurve.interpolation : undefined;\n\n    return success(isFeatureConstant ?\n        (new ZoomDependentExpression('camera', expression.value, zoomCurve.labels, interpolationType): CameraExpression) :\n        (new ZoomDependentExpression('composite', expression.value, zoomCurve.labels, interpolationType): CompositeExpression));\n}\n\nimport {isFunction, createFunction} from '../function/index.js';\nimport {Color} from './values.js';\n\n// serialization wrapper for old-style stop functions normalized to the\n// expression interface\nexport class StylePropertyFunction<T> {\n    _parameters: PropertyValueSpecification<T>;\n    _specification: StylePropertySpecification;\n\n    kind: EvaluationKind;\n    evaluate: (globals: GlobalProperties, feature?: Feature) => any;\n    interpolationFactor: ?(input: number, lower: number, upper: number) => number;\n    zoomStops: ?Array<number>;\n\n    constructor(parameters: PropertyValueSpecification<T>, specification: StylePropertySpecification) {\n        this._parameters = parameters;\n        this._specification = specification;\n        extend(this, createFunction(this._parameters, this._specification));\n    }\n\n    static deserialize(serialized: {_parameters: PropertyValueSpecification<T>, _specification: StylePropertySpecification}): StylePropertyFunction<T> {\n        return new StylePropertyFunction(serialized._parameters, serialized._specification);\n    }\n\n    static serialize(input: StylePropertyFunction<T>): {_parameters: PropertyValueSpecification<T>, _specification: StylePropertySpecification} {\n        return {\n            _parameters: input._parameters,\n            _specification: input._specification\n        };\n    }\n}\n\nexport function normalizePropertyExpression<T>(value: PropertyValueSpecification<T>, specification: StylePropertySpecification): StylePropertyExpression {\n    if (isFunction(value)) {\n        return (new StylePropertyFunction(value, specification): any);\n\n    } else if (isExpression(value)) {\n        const expression = createPropertyExpression(value, specification);\n        if (expression.result === 'error') {\n            // this should have been caught in validation\n            throw new Error(expression.value.map(err => `${err.key}: ${err.message}`).join(', '));\n        }\n        return expression.value;\n\n    } else {\n        let constant: any = value;\n        if (typeof value === 'string' && specification.type === 'color') {\n            constant = Color.parse(value);\n        }\n        return {\n            kind: 'constant',\n            evaluate: () => constant\n        };\n    }\n}\n\n// Zoom-dependent expressions may only use [\"zoom\"] as the input to a top-level \"step\" or \"interpolate\"\n// expression (collectively referred to as a \"curve\"). The curve may be wrapped in one or more \"let\" or\n// \"coalesce\" expressions.\nfunction findZoomCurve(expression: Expression): Step | Interpolate | ParsingError | null {\n    let result = null;\n    if (expression instanceof Let) {\n        result = findZoomCurve(expression.result);\n\n    } else if (expression instanceof Coalesce) {\n        for (const arg of expression.args) {\n            result = findZoomCurve(arg);\n            if (result) {\n                break;\n            }\n        }\n\n    } else if ((expression instanceof Step || expression instanceof Interpolate) &&\n        expression.input instanceof CompoundExpression &&\n        expression.input.name === 'zoom') {\n\n        result = expression;\n    }\n\n    if (result instanceof ParsingError) {\n        return result;\n    }\n\n    expression.eachChild((child) => {\n        const childResult = findZoomCurve(child);\n        if (childResult instanceof ParsingError) {\n            result = childResult;\n        } else if (!result && childResult) {\n            result = new ParsingError('', '\"zoom\" expression may only be used as input to a top-level \"step\" or \"interpolate\" expression.');\n        } else if (result && childResult && result !== childResult) {\n            result = new ParsingError('', 'Only one zoom-based \"step\" or \"interpolate\" subexpression may be used in an expression.');\n        }\n    });\n\n    return result;\n}\n\nimport {ColorType, StringType, NumberType, BooleanType, ValueType, FormattedType, ResolvedImageType, array} from './types.js';\n\nfunction getExpectedType(spec: StylePropertySpecification): Type {\n    const types = {\n        color: ColorType,\n        string: StringType,\n        number: NumberType,\n        enum: StringType,\n        boolean: BooleanType,\n        formatted: FormattedType,\n        resolvedImage: ResolvedImageType\n    };\n\n    if (spec.type === 'array') {\n        return array(types[spec.value] || ValueType, spec.length);\n    }\n\n    return types[spec.type];\n}\n\nfunction getDefaultValue(spec: StylePropertySpecification): Value {\n    if (spec.type === 'color' && (isFunction(spec.default) || Array.isArray(spec.default))) {\n        // Special case for heatmap-color: it uses the 'default:' to define a\n        // default color ramp, but createExpression expects a simple value to fall\n        // back to in case of runtime errors\n        return new Color(0, 0, 0, 0);\n    } else if (spec.type === 'color') {\n        return Color.parse(spec.default) || null;\n    } else if (spec.default === undefined) {\n        return null;\n    } else {\n        return spec.default;\n    }\n}\n","// @flow\n\nimport assert from 'assert';\n\nimport type {StylePropertySpecification} from '../style-spec.js';\nimport type {ExpressionSpecification} from '../types.js';\n\nfunction convertLiteral(value) {\n    return typeof value === 'object' ? ['literal', value] : value;\n}\n\nexport default function convertFunction(parameters: any, propertySpec: StylePropertySpecification): ExpressionSpecification {\n    let stops = parameters.stops;\n    if (!stops) {\n        // identity function\n        return convertIdentityFunction(parameters, propertySpec);\n    }\n\n    const zoomAndFeatureDependent = stops && typeof stops[0][0] === 'object';\n    const featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;\n    const zoomDependent = zoomAndFeatureDependent || !featureDependent;\n\n    stops = stops.map((stop) => {\n        if (!featureDependent && propertySpec.tokens && typeof stop[1] === 'string') {\n            return [stop[0], convertTokenString(stop[1])];\n        }\n        return [stop[0], convertLiteral(stop[1])];\n    });\n\n    if (zoomAndFeatureDependent) {\n        return convertZoomAndPropertyFunction(parameters, propertySpec, stops);\n    } else if (zoomDependent) {\n        return convertZoomFunction(parameters, propertySpec, stops);\n    } else {\n        return convertPropertyFunction(parameters, propertySpec, stops);\n    }\n}\n\nfunction convertIdentityFunction(parameters, propertySpec): Array<mixed> {\n    const get = ['get', parameters.property];\n\n    if (parameters.default === undefined) {\n        // By default, expressions for string-valued properties get coerced. To preserve\n        // legacy function semantics, insert an explicit assertion instead.\n        return propertySpec.type === 'string' ? ['string', get] : get;\n    } else if (propertySpec.type === 'enum') {\n        return [\n            'match',\n            get,\n            Object.keys(propertySpec.values),\n            get,\n            parameters.default\n        ];\n    } else {\n        const expression = [propertySpec.type === 'color' ? 'to-color' : propertySpec.type, get, convertLiteral(parameters.default)];\n        if (propertySpec.type === 'array') {\n            expression.splice(1, 0, propertySpec.value, propertySpec.length || null);\n        }\n        return expression;\n    }\n}\n\nfunction getInterpolateOperator(parameters) {\n    switch (parameters.colorSpace) {\n    case 'hcl': return 'interpolate-hcl';\n    case 'lab': return 'interpolate-lab';\n    default: return 'interpolate';\n    }\n}\n\nfunction convertZoomAndPropertyFunction(parameters, propertySpec, stops) {\n    const featureFunctionParameters = {};\n    const featureFunctionStops = {};\n    const zoomStops = [];\n    for (let s = 0; s < stops.length; s++) {\n        const stop = stops[s];\n        const zoom = stop[0].zoom;\n        if (featureFunctionParameters[zoom] === undefined) {\n            featureFunctionParameters[zoom] = {\n                zoom,\n                type: parameters.type,\n                property: parameters.property,\n                default: parameters.default,\n            };\n            featureFunctionStops[zoom] = [];\n            zoomStops.push(zoom);\n        }\n        featureFunctionStops[zoom].push([stop[0].value, stop[1]]);\n    }\n\n    // the interpolation type for the zoom dimension of a zoom-and-property\n    // function is determined directly from the style property specification\n    // for which it's being used: linear for interpolatable properties, step\n    // otherwise.\n    const functionType = getFunctionType({}, propertySpec);\n    if (functionType === 'exponential') {\n        const expression = [getInterpolateOperator(parameters), ['linear'], ['zoom']];\n\n        for (const z of zoomStops) {\n            const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n            appendStopPair(expression, z, output, false);\n        }\n\n        return expression;\n    } else {\n        const expression = ['step', ['zoom']];\n\n        for (const z of zoomStops) {\n            const output = convertPropertyFunction(featureFunctionParameters[z], propertySpec, featureFunctionStops[z]);\n            appendStopPair(expression, z, output, true);\n        }\n\n        fixupDegenerateStepCurve(expression);\n\n        return expression;\n    }\n}\n\nfunction coalesce(a, b) {\n    if (a !== undefined) return a;\n    if (b !== undefined) return b;\n}\n\nfunction getFallback(parameters, propertySpec) {\n    const defaultValue = convertLiteral(coalesce(parameters.default, propertySpec.default));\n\n    /*\n     * Some fields with type: resolvedImage have an undefined default.\n     * Because undefined is an invalid value for resolvedImage, set fallback to\n     * an empty string instead of undefined to ensure output\n     * passes validation.\n     */\n    if (defaultValue === undefined && propertySpec.type === 'resolvedImage') {\n        return '';\n    }\n    return defaultValue;\n}\n\nfunction convertPropertyFunction(parameters, propertySpec, stops) {\n    const type = getFunctionType(parameters, propertySpec);\n    const get = ['get', parameters.property];\n    if (type === 'categorical' && typeof stops[0][0] === 'boolean') {\n        assert(parameters.stops.length > 0 && parameters.stops.length <= 2);\n        const expression = ['case'];\n        for (const stop of stops) {\n            expression.push(['==', get, stop[0]], stop[1]);\n        }\n\n        expression.push(getFallback(parameters, propertySpec));\n        return expression;\n    } else if (type === 'categorical') {\n        const expression = ['match', get];\n        for (const stop of stops) {\n            appendStopPair(expression, stop[0], stop[1], false);\n        }\n        expression.push(getFallback(parameters, propertySpec));\n        return expression;\n    } else if (type === 'interval') {\n        const expression = ['step', ['number', get]];\n        for (const stop of stops) {\n            appendStopPair(expression, stop[0], stop[1], true);\n        }\n        fixupDegenerateStepCurve(expression);\n        return parameters.default === undefined ? expression : [\n            'case',\n            ['==', ['typeof', get], 'number'],\n            expression,\n            convertLiteral(parameters.default)\n        ];\n    } else if (type === 'exponential') {\n        const base = parameters.base !== undefined ? parameters.base : 1;\n        const expression = [\n            getInterpolateOperator(parameters),\n            base === 1 ? [\"linear\"] : [\"exponential\", base],\n            [\"number\", get]\n        ];\n\n        for (const stop of stops) {\n            appendStopPair(expression, stop[0], stop[1], false);\n        }\n        return parameters.default === undefined ? expression : [\n            'case',\n            ['==', ['typeof', get], 'number'],\n            expression,\n            convertLiteral(parameters.default)\n        ];\n    } else {\n        throw new Error(`Unknown property function type ${type}`);\n    }\n}\n\nfunction convertZoomFunction(parameters, propertySpec, stops, input = ['zoom']) {\n    const type = getFunctionType(parameters, propertySpec);\n    let expression;\n    let isStep = false;\n    if (type === 'interval') {\n        expression = ['step', input];\n        isStep = true;\n    } else if (type === 'exponential') {\n        const base = parameters.base !== undefined ? parameters.base : 1;\n        expression = [getInterpolateOperator(parameters), base === 1 ? [\"linear\"] : [\"exponential\", base], input];\n\n    } else {\n        throw new Error(`Unknown zoom function type \"${type}\"`);\n    }\n\n    for (const stop of stops) {\n        appendStopPair(expression, stop[0], stop[1], isStep);\n    }\n\n    fixupDegenerateStepCurve(expression);\n\n    return expression;\n}\n\nfunction fixupDegenerateStepCurve(expression) {\n    // degenerate step curve (i.e. a constant function): add a noop stop\n    if (expression[0] === 'step' && expression.length === 3) {\n        expression.push(0);\n        expression.push(expression[3]);\n    }\n}\n\nfunction appendStopPair(curve, input, output, isStep) {\n    // Skip duplicate stop values. They were not validated for functions, but they are for expressions.\n    // https://github.com/mapbox/mapbox-gl-js/issues/4107\n    if (curve.length > 3 && input === curve[curve.length - 2]) {\n        return;\n    }\n    // step curves don't get the first input value, as it is redundant.\n    if (!(isStep && curve.length === 2)) {\n        curve.push(input);\n    }\n    curve.push(output);\n}\n\nfunction getFunctionType(parameters, propertySpec) {\n    if (parameters.type) {\n        return parameters.type;\n    } else {\n        assert(propertySpec.expression);\n        return (propertySpec.expression: any).interpolated ? 'exponential' : 'interval';\n    }\n}\n\n// \"String with {name} token\" => [\"concat\", \"String with \", [\"get\", \"name\"], \" token\"]\nexport function convertTokenString(s: string): string | ExpressionSpecification {\n    const result = ['concat'];\n    const re = /{([^{}]+)}/g;\n    let pos = 0;\n    for (let match = re.exec(s); match !== null; match = re.exec(s)) {\n        const literal = s.slice(pos, re.lastIndex - match[0].length);\n        pos = re.lastIndex;\n        if (literal.length > 0) result.push(literal);\n        result.push(['get', match[1]]);\n    }\n\n    if (result.length === 1) {\n        return s;\n    }\n\n    if (pos < s.length) {\n        result.push(s.slice(pos));\n    } else if (result.length === 2) {\n        return ['to-string', result[1]];\n    }\n\n    return result;\n}\n\n","// @flow\n\n// Turn jsonlint-lines-primitives objects into primitive objects\nexport function unbundle(value: mixed): mixed {\n    if (value instanceof Number || value instanceof String || value instanceof Boolean) {\n        return value.valueOf();\n    } else {\n        return value;\n    }\n}\n\nexport function deepUnbundle(value: mixed): mixed {\n    if (Array.isArray(value)) {\n        return value.map(deepUnbundle);\n    } else if (value instanceof Object && !(value instanceof Number || value instanceof String || value instanceof Boolean)) {\n        const unbundledValue: { [key: string]: mixed } = {};\n        for (const key in value) {\n            unbundledValue[key] = deepUnbundle(value[key]);\n        }\n        return unbundledValue;\n    }\n\n    return unbundle(value);\n}\n","// @flow\n\nimport {createExpression} from '../expression/index.js';\nimport {isFeatureConstant} from '../expression/is_constant.js';\nimport {deepUnbundle} from '../util/unbundle_jsonlint.js';\nimport latest from '../reference/latest.js';\nimport type {GlobalProperties, Feature} from '../expression/index.js';\nimport type {CanonicalTileID} from '../../source/tile_id.js';\nimport type Point from '@mapbox/point-geometry';\n\nexport type FeatureDistanceData = {bearing: [number, number], center: [number, number], scale: number};\nexport type FilterExpression = (globalProperties: GlobalProperties, feature: Feature, canonical?: CanonicalTileID, featureTileCoord?: Point, featureDistanceData?: FeatureDistanceData) => boolean;\nexport type FeatureFilter = {filter: FilterExpression, dynamicFilter?: FilterExpression, needGeometry: boolean, needFeature: boolean};\n\nexport default createFilter;\nexport {isExpressionFilter, isDynamicFilter, extractStaticFilter};\n\nfunction isExpressionFilter(filter: any): boolean {\n    if (filter === true || filter === false) {\n        return true;\n    }\n\n    if (!Array.isArray(filter) || filter.length === 0) {\n        return false;\n    }\n    switch (filter[0]) {\n    case 'has':\n        return filter.length >= 2 && filter[1] !== '$id' && filter[1] !== '$type';\n\n    case 'in':\n        return filter.length >= 3 && (typeof filter[1] !== 'string' || Array.isArray(filter[2]));\n\n    case '!in':\n    case '!has':\n    case 'none':\n        return false;\n\n    case '==':\n    case '!=':\n    case '>':\n    case '>=':\n    case '<':\n    case '<=':\n        return filter.length !== 3 || (Array.isArray(filter[1]) || Array.isArray(filter[2]));\n\n    case 'any':\n    case 'all':\n        for (const f of filter.slice(1)) {\n            if (!isExpressionFilter(f) && typeof f !== 'boolean') {\n                return false;\n            }\n        }\n        return true;\n\n    default:\n        return true;\n    }\n}\n\n/**\n * Given a filter expressed as nested arrays, return a new function\n * that evaluates whether a given feature (with a .properties or .tags property)\n * passes its test.\n *\n * @private\n * @param {Array} filter mapbox gl filter\n * @param {string} layerType the type of the layer this filter will be applied to.\n * @returns {Function} filter-evaluating function\n */\nfunction createFilter(filter: any, layerType?: string = 'fill'): FeatureFilter {\n    if (filter === null || filter === undefined) {\n        return {filter: () => true, needGeometry: false, needFeature: false};\n    }\n\n    if (!isExpressionFilter(filter)) {\n        filter = convertFilter(filter);\n    }\n    const filterExp = ((filter: any): string[] | string | boolean);\n\n    let staticFilter = true;\n    try {\n        staticFilter = extractStaticFilter(filterExp);\n    } catch (e) {\n        console.warn(\n`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.\nThis is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md\nand paste the contents of this message in the report.\nThank you!\nFilter Expression:\n${JSON.stringify(filterExp, null, 2)}\n        `);\n    }\n\n    // Compile the static component of the filter\n    const filterSpec = latest[`filter_${layerType}`];\n    const compiledStaticFilter = createExpression(staticFilter, filterSpec);\n\n    let filterFunc = null;\n    if (compiledStaticFilter.result === 'error') {\n        throw new Error(compiledStaticFilter.value.map(err => `${err.key}: ${err.message}`).join(', '));\n    } else {\n        filterFunc = (globalProperties: GlobalProperties, feature: Feature, canonical?: CanonicalTileID) => compiledStaticFilter.value.evaluate(globalProperties, feature, {}, canonical);\n    }\n\n    // If the static component is not equal to the entire filter then we have a dynamic component\n    // Compile the dynamic component separately\n    let dynamicFilterFunc = null;\n    let needFeature = null;\n    if (staticFilter !== filterExp) {\n        const compiledDynamicFilter = createExpression(filterExp, filterSpec);\n\n        if (compiledDynamicFilter.result === 'error') {\n            throw new Error(compiledDynamicFilter.value.map(err => `${err.key}: ${err.message}`).join(', '));\n        } else {\n            dynamicFilterFunc = (globalProperties: GlobalProperties, feature: Feature, canonical?: CanonicalTileID, featureTileCoord?: Point, featureDistanceData?: FeatureDistanceData) => compiledDynamicFilter.value.evaluate(globalProperties, feature, {}, canonical, undefined, undefined, featureTileCoord, featureDistanceData);\n            needFeature = !isFeatureConstant(compiledDynamicFilter.value.expression);\n        }\n    }\n\n    filterFunc = ((filterFunc: any): FilterExpression);\n    const needGeometry = geometryNeeded(staticFilter);\n\n    return {\n        filter: filterFunc,\n        dynamicFilter: dynamicFilterFunc ? dynamicFilterFunc : undefined,\n        needGeometry,\n        needFeature: !!needFeature\n    };\n}\n\nfunction extractStaticFilter(filter: any): any {\n    if (!isDynamicFilter(filter)) {\n        return filter;\n    }\n\n    // Shallow copy so we can replace expressions in-place\n    let result = deepUnbundle(filter);\n\n    // 1. Union branches\n    unionDynamicBranches(result);\n\n    // 2. Collapse dynamic conditions to  `true`\n    result = collapseDynamicBooleanExpressions(result);\n\n    return result;\n}\n\nfunction collapseDynamicBooleanExpressions(expression: any): any {\n    if (!Array.isArray(expression)) {\n        return expression;\n    }\n\n    const collapsed = collapsedExpression(expression);\n    if (collapsed === true) {\n        return collapsed;\n    } else {\n        return collapsed.map((subExpression) => collapseDynamicBooleanExpressions(subExpression));\n    }\n}\n\n/**\n * Traverses the expression and replaces all instances of branching on a\n * `dynamic` conditional (such as `['pitch']` or `['distance-from-center']`)\n * into an `any` expression.\n * This ensures that all possible outcomes of a `dynamic` branch are considered\n * when evaluating the expression upfront during filtering.\n *\n * @param {Array<any>} filter the filter expression mutated in-place.\n */\nfunction unionDynamicBranches(filter: any) {\n    let isBranchingDynamically = false;\n    const branches = [];\n\n    if (filter[0] === 'case') {\n        for (let i = 1; i < filter.length - 1; i += 2) {\n            isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[i]);\n            branches.push(filter[i + 1]);\n        }\n\n        branches.push(filter[filter.length - 1]);\n    } else if (filter[0] === 'match') {\n        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);\n\n        for (let i = 2; i < filter.length - 1; i += 2) {\n            branches.push(filter[i + 1]);\n        }\n        branches.push(filter[filter.length - 1]);\n    } else if (filter[0] === 'step') {\n        isBranchingDynamically = isBranchingDynamically || isDynamicFilter(filter[1]);\n\n        for (let i = 1; i < filter.length - 1; i += 2) {\n            branches.push(filter[i + 1]);\n        }\n    }\n\n    if (isBranchingDynamically) {\n        filter.length = 0;\n        filter.push('any', ...branches);\n    }\n\n    // traverse and recurse into children\n    for (let i = 1; i < filter.length; i++) {\n        unionDynamicBranches(filter[i]);\n    }\n}\n\nfunction isDynamicFilter(filter: any): boolean {\n    // Base Cases\n    if (!Array.isArray(filter)) {\n        return false;\n    }\n    if (isRootExpressionDynamic(filter[0])) {\n        return true;\n    }\n\n    for (let i = 1; i < filter.length; i++) {\n        const child = filter[i];\n        if (isDynamicFilter(child)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction isRootExpressionDynamic(expression: string): boolean {\n    return expression === 'pitch' ||\n        expression === 'distance-from-center';\n}\n\nconst dynamicConditionExpressions = new Set([\n    'in',\n    '==',\n    '!=',\n    '>',\n    '>=',\n    '<',\n    '<=',\n    'to-boolean'\n]);\n\nfunction collapsedExpression(expression: any): any {\n    if (dynamicConditionExpressions.has(expression[0])) {\n\n        for (let i = 1; i < expression.length; i++) {\n            const param = expression[i];\n            if (isDynamicFilter(param)) {\n                return true;\n            }\n        }\n    }\n    return expression;\n}\n\n// Comparison function to sort numbers and strings\nfunction compare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\nfunction geometryNeeded(filter) {\n    if (!Array.isArray(filter)) return false;\n    if (filter[0] === 'within') return true;\n    for (let index = 1; index < filter.length; index++) {\n        if (geometryNeeded(filter[index])) return true;\n    }\n    return false;\n}\n\nfunction convertFilter(filter: ?Array<any>): mixed {\n    if (!filter) return true;\n    const op = filter[0];\n    if (filter.length <= 1) return (op !== 'any');\n    const converted =\n        op === '==' ? convertComparisonOp(filter[1], filter[2], '==') :\n        op === '!=' ? convertNegation(convertComparisonOp(filter[1], filter[2], '==')) :\n        op === '<' ||\n        op === '>' ||\n        op === '<=' ||\n        op === '>=' ? convertComparisonOp(filter[1], filter[2], op) :\n        op === 'any' ? convertDisjunctionOp(filter.slice(1)) :\n        op === 'all' ? ['all'].concat(filter.slice(1).map(convertFilter)) :\n        op === 'none' ? ['all'].concat(filter.slice(1).map(convertFilter).map(convertNegation)) :\n        op === 'in' ? convertInOp(filter[1], filter.slice(2)) :\n        op === '!in' ? convertNegation(convertInOp(filter[1], filter.slice(2))) :\n        op === 'has' ? convertHasOp(filter[1]) :\n        op === '!has' ? convertNegation(convertHasOp(filter[1])) :\n        op === 'within' ? filter :\n        true;\n    return converted;\n}\n\nfunction convertComparisonOp(property: string, value: any, op: string) {\n    switch (property) {\n    case '$type':\n        return [`filter-type-${op}`, value];\n    case '$id':\n        return [`filter-id-${op}`, value];\n    default:\n        return [`filter-${op}`, property, value];\n    }\n}\n\nfunction convertDisjunctionOp(filters: Array<Array<any>>) {\n    return ['any'].concat(filters.map(convertFilter));\n}\n\nfunction convertInOp(property: string, values: Array<any>) {\n    if (values.length === 0) { return false; }\n    switch (property) {\n    case '$type':\n        return [`filter-type-in`, ['literal', values]];\n    case '$id':\n        return [`filter-id-in`, ['literal', values]];\n    default:\n        if (values.length > 200 && !values.some(v => typeof v !== typeof values[0])) {\n            return ['filter-in-large', property, ['literal', values.sort(compare)]];\n        } else {\n            return ['filter-in-small', property, ['literal', values]];\n        }\n    }\n}\n\nfunction convertHasOp(property: string) {\n    switch (property) {\n    case '$type':\n        return true;\n    case '$id':\n        return [`filter-has-id`];\n    default:\n        return [`filter-has`, property];\n    }\n}\n\nfunction convertNegation(filter: mixed) {\n    return ['!', filter];\n}\n","// @flow\n\nimport {isExpressionFilter} from './index.js';\n\nimport type {FilterSpecification} from '../types.js';\n\ntype ExpectedTypes = {[_: string]: 'string' | 'number' | 'boolean'};\n\n/**\n * Convert the given legacy filter to (the JSON representation of) an\n * equivalent expression\n * @private\n */\nexport default function convertFilter(filter: FilterSpecification): mixed {\n    return _convertFilter(filter, {});\n}\n\n/*\n * Convert the given filter to an expression, storing the expected types for\n * any feature properties referenced in expectedTypes.\n *\n * These expected types are needed in order to construct preflight type checks\n * needed for handling 'any' filters. A preflight type check is necessary in\n * order to mimic legacy filters' semantics around expected type mismatches.\n * For example, consider the legacy filter:\n *\n *     [\"any\", [\"all\", [\">\", \"y\", 0], [\">\", \"y\", 0]], [\">\", \"x\", 0]]\n *\n * Naively, we might convert this to the expression:\n *\n *     [\"any\", [\"all\", [\">\", [\"get\", \"y\"], 0], [\">\", [\"get\", \"z\"], 0]], [\">\", [\"get\", \"x\"], 0]]\n *\n * But if we tried to evaluate this against, say `{x: 1, y: null, z: 0}`, the\n * [\">\", [\"get\", \"y\"], 0] would cause an evaluation error, leading to the\n * entire filter returning false. Legacy filter semantics, though, ask for\n * [\">\", \"y\", 0] to simply return `false` when `y` is of the wrong type,\n * allowing the subsequent terms of the outer \"any\" expression to be evaluated\n * (resulting, in this case, in a `true` value, because x > 0).\n *\n * We account for this by inserting a preflight type-checking expression before\n * each \"any\" term, allowing us to avoid evaluating the actual converted filter\n * if any type mismatches would cause it to produce an evalaution error:\n *\n *     [\"any\",\n *       [\"case\",\n *         [\"all\", [\"==\", [\"typeof\", [\"get\", \"y\"]], \"number\"], [\"==\", [\"typeof\", [\"get\", \"z\"], \"number]],\n *         [\"all\", [\">\", [\"get\", \"y\"], 0], [\">\", [\"get\", \"z\"], 0]],\n *         false\n *       ],\n *       [\"case\",\n *         [\"==\", [\"typeof\", [\"get\", \"x\"], \"number\"]],\n *         [\">\", [\"get\", \"x\"], 0],\n *         false\n *       ]\n *     ]\n *\n * An alternative, possibly more direct approach would be to use type checks\n * in the conversion of each comparison operator, so that the converted version\n * of each individual ==, >=, etc. would mimic the legacy filter semantics. The\n * downside of this approach is that it can lead to many more type checks than\n * would otherwise be necessary: outside the context of an \"any\" expression,\n * bailing out due to a runtime type error (expression semantics) and returning\n * false (legacy filter semantics) are equivalent: they cause the filter to\n * produce a `false` result.\n */\nfunction _convertFilter(filter: FilterSpecification, expectedTypes: ExpectedTypes): mixed {\n    if (isExpressionFilter(filter)) { return filter; }\n\n    if (!filter) return true;\n    const op = filter[0];\n    if (filter.length <= 1) return (op !== 'any');\n\n    let converted;\n\n    if (\n        op === '==' ||\n        op === '!=' ||\n        op === '<' ||\n        op === '>' ||\n        op === '<=' ||\n        op === '>='\n    ) {\n        const [, property, value] = (filter: any);\n        converted = convertComparisonOp(property, value, op, expectedTypes);\n    } else if (op === 'any') {\n        const children = (filter: any).slice(1).map(f => {\n            const types = {};\n            const child = _convertFilter(f, types);\n            const typechecks = runtimeTypeChecks(types);\n            return typechecks === true ? child : ['case', typechecks, child, false];\n        });\n        return ['any'].concat(children);\n    } else if (op === 'all') {\n        const children = (filter: any).slice(1).map(f => _convertFilter(f, expectedTypes));\n        return children.length > 1 ? ['all'].concat(children) : [].concat(...children);\n    } else if (op === 'none') {\n        return ['!', _convertFilter(['any'].concat((filter: any).slice(1)), {})];\n    } else if (op === 'in') {\n        converted = convertInOp((filter[1]: any), filter.slice(2));\n    } else if (op === '!in') {\n        converted = convertInOp((filter[1]: any), filter.slice(2), true);\n    } else if (op === 'has') {\n        converted = convertHasOp((filter[1]: any));\n    } else if (op === '!has') {\n        converted = ['!', convertHasOp((filter[1]: any))];\n    } else {\n        converted = true;\n    }\n\n    return converted;\n}\n\n// Given a set of feature properties and an expected type for each one,\n// construct an boolean expression that tests whether each property has the\n// right type.\n// E.g.: for {name: 'string', population: 'number'}, return\n// [ 'all',\n//   ['==', ['typeof', ['get', 'name'], 'string']],\n//   ['==', ['typeof', ['get', 'population'], 'number]]\n// ]\nfunction runtimeTypeChecks(expectedTypes: ExpectedTypes) {\n    const conditions = [];\n    for (const property in expectedTypes) {\n        const get = property === '$id' ? ['id'] : ['get', property];\n        conditions.push(['==', ['typeof', get], expectedTypes[property]]);\n    }\n    if (conditions.length === 0) return true;\n    if (conditions.length === 1) return conditions[0];\n    return ['all'].concat(conditions);\n}\n\nfunction convertComparisonOp(property: string, value: any, op: string, expectedTypes: ?ExpectedTypes) {\n    let get;\n    if (property === '$type') {\n        return [op, ['geometry-type'], value];\n    } else if (property === '$id') {\n        get = ['id'];\n    } else {\n        get = ['get', property];\n    }\n\n    if (expectedTypes && value !== null) {\n        const type = ((typeof value): any);\n        expectedTypes[property] = type;\n    }\n\n    if (op === '==' && property !== '$id' && value === null) {\n        return [\n            'all',\n            ['has', property], // missing property != null for legacy filters\n            ['==', get, null]\n        ];\n    } else if (op === '!=' && property !== '$id' && value === null) {\n        return [\n            'any',\n            ['!', ['has', property]], // missing property != null for legacy filters\n            ['!=', get, null]\n        ];\n    }\n\n    return [op, get, value];\n}\n\nfunction convertInOp(property: string, values: Array<any>, negate = false) {\n    if (values.length === 0) return negate;\n\n    let get;\n    if (property === '$type') {\n        get = ['geometry-type'];\n    } else if (property === '$id') {\n        get = ['id'];\n    } else {\n        get = ['get', property];\n    }\n\n    // Determine if the list of values to be searched is homogenously typed.\n    // If so (and if the type is string or number), then we can use a\n    // [match, input, [...values], true, false] construction rather than a\n    // bunch of `==` tests.\n    let uniformTypes = true;\n    const type = typeof values[0];\n    for (const value of values) {\n        if (typeof value !== type) {\n            uniformTypes = false;\n            break;\n        }\n    }\n\n    if (uniformTypes && (type === 'string' || type === 'number')) {\n        // Match expressions must have unique values.\n        const uniqueValues = values.sort().filter((v, i) => i === 0 || values[i - 1] !== v);\n        return ['match', get, uniqueValues, !negate, negate];\n    }\n\n    return [ negate ? 'all' : 'any' ].concat(\n        values.map(v => [negate ? '!=' : '==', get, v])\n    );\n}\n\nfunction convertHasOp(property: string) {\n    if (property === '$type') {\n        return true;\n    } else if (property === '$id') {\n        return ['!=', ['id'], null];\n    } else {\n        return ['has', property];\n    }\n}\n","// @flow\n\nimport {\n    eachLayer,\n    eachProperty\n} from '../visit.js';\nimport {isExpression} from '../expression/index.js';\nimport convertFunction, {convertTokenString} from '../function/convert.js';\nimport convertFilter from '../feature_filter/convert.js';\n\nimport type {StyleSpecification} from '../types.js';\n\n/**\n * Migrate the given style object in place to use expressions. Specifically,\n * this will convert (a) \"stop\" functions, and (b) legacy filters to their\n * expression equivalents.\n */\nexport default function(style: StyleSpecification): StyleSpecification {\n    const converted = [];\n\n    eachLayer(style, (layer) => {\n        if (layer.filter) {\n            layer.filter = (convertFilter(layer.filter): any);\n        }\n    });\n\n    eachProperty(style, {paint: true, layout: true}, ({path, value, reference, set}) => {\n        if (isExpression(value)) return;\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            set(convertFunction(value, reference));\n            converted.push(path.join('.'));\n        } else if (reference.tokens && typeof value === 'string') {\n            set(convertTokenString(value));\n        }\n    });\n\n    return style;\n}\n\n","\nimport migrateToV8 from './migrate/v8.js';\nimport migrateToExpressions from './migrate/expressions.js';\n\n/**\n * Migrate a Mapbox GL Style to the latest version.\n *\n * @private\n * @alias migrate\n * @param {object} style a Mapbox GL Style\n * @returns {Object} a migrated style\n * @example\n * var fs = require('fs');\n * var migrate = require('mapbox-gl-style-spec').migrate;\n * var style = fs.readFileSync('./style.json', 'utf8');\n * fs.writeFileSync('./style.json', JSON.stringify(migrate(style)));\n */\nexport default function(style) {\n    let migrated = false;\n\n    if (style.version === 7) {\n        style = migrateToV8(style);\n        migrated = true;\n    }\n\n    if (style.version === 8) {\n        migrated = migrateToExpressions(style);\n        migrated = true;\n    }\n\n    if (!migrated) {\n        throw new Error('cannot migrate from', style.version);\n    }\n\n    return style;\n}\n","\nexport default function (style) {\n    const styleIDs = [];\n    const sourceIDs = [];\n    const compositedSourceLayers = [];\n\n    for (const id in style.sources) {\n        const source = style.sources[id];\n\n        if (source.type !== \"vector\")\n            continue;\n\n        const match = /^mapbox:\\/\\/(.*)/.exec(source.url);\n        if (!match)\n            continue;\n\n        styleIDs.push(id);\n        sourceIDs.push(match[1]);\n    }\n\n    if (styleIDs.length < 2)\n        return style;\n\n    styleIDs.forEach((id) => {\n        delete style.sources[id];\n    });\n\n    const compositeID = sourceIDs.join(\",\");\n\n    style.sources[compositeID] = {\n        \"type\": \"vector\",\n        \"url\": `mapbox://${compositeID}`\n    };\n\n    style.layers.forEach((layer) => {\n        if (styleIDs.indexOf(layer.source) >= 0) {\n            layer.source = compositeID;\n\n            if ('source-layer' in layer) {\n                if (compositedSourceLayers.indexOf(layer['source-layer']) >= 0) {\n                    throw new Error('Conflicting source layer names');\n                } else {\n                    compositedSourceLayers.push(layer['source-layer']);\n                }\n            }\n        }\n    });\n\n    return style;\n}\n","// @flow\nexport default ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];\n","// @flow\n\nimport refProperties from './util/ref_properties.js';\n\nimport type {LayerSpecification} from './types.js';\n\nfunction deref(layer: LayerSpecification, parent: LayerSpecification): LayerSpecification {\n    const result = {};\n\n    for (const k in layer) {\n        if (k !== 'ref') {\n            result[k] = layer[k];\n        }\n    }\n\n    refProperties.forEach((k) => {\n        if (k in parent) {\n            result[k] = (parent: any)[k];\n        }\n    });\n\n    return ((result: any): LayerSpecification);\n}\n\n/**\n * Given an array of layers, some of which may contain `ref` properties\n * whose value is the `id` of another property, return a new array where\n * such layers have been augmented with the 'type', 'source', etc. properties\n * from the parent layer, and the `ref` property has been removed.\n *\n * The input is not modified. The output may contain references to portions\n * of the input.\n *\n * @private\n * @param {Array<Layer>} layers\n * @returns {Array<Layer>}\n */\nexport default function derefLayers(layers: Array<LayerSpecification>): Array<LayerSpecification> {\n    layers = layers.slice();\n\n    const map = Object.create(null);\n    for (let i = 0; i < layers.length; i++) {\n        map[layers[i].id] = layers[i];\n    }\n\n    for (let i = 0; i < layers.length; i++) {\n        if ('ref' in layers[i]) {\n            layers[i] = deref(layers[i], map[(layers[i]: any).ref]);\n        }\n    }\n\n    return layers;\n}\n","// @flow\n\n/**\n * Deeply compares two object literals.\n *\n * @private\n */\nfunction deepEqual(a: ?mixed, b: ?mixed): boolean {\n    if (Array.isArray(a)) {\n        if (!Array.isArray(b) || a.length !== b.length) return false;\n        for (let i = 0; i < a.length; i++) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }\n        return true;\n    }\n    if (typeof a === 'object' && a !== null && b !== null) {\n        if (!(typeof b === 'object')) return false;\n        const keys = Object.keys(a);\n        if (keys.length !== Object.keys(b).length) return false;\n        for (const key in a) {\n            if (!deepEqual(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    return a === b;\n}\n\nexport default deepEqual;\n","// @flow\n\nimport isEqual from './util/deep_equal.js';\n\nimport type {StyleSpecification} from './types.js';\n\ntype Command = {\n    command: string;\n    args: Array<any>;\n};\n\nexport const operations: {[_: string]: string} = {\n\n    /*\n     * { command: 'setStyle', args: [stylesheet] }\n     */\n    setStyle: 'setStyle',\n\n    /*\n     * { command: 'addLayer', args: [layer, 'beforeLayerId'] }\n     */\n    addLayer: 'addLayer',\n\n    /*\n     * { command: 'removeLayer', args: ['layerId'] }\n     */\n    removeLayer: 'removeLayer',\n\n    /*\n     * { command: 'setPaintProperty', args: ['layerId', 'prop', value] }\n     */\n    setPaintProperty: 'setPaintProperty',\n\n    /*\n     * { command: 'setLayoutProperty', args: ['layerId', 'prop', value] }\n     */\n    setLayoutProperty: 'setLayoutProperty',\n\n    /*\n     * { command: 'setFilter', args: ['layerId', filter] }\n     */\n    setFilter: 'setFilter',\n\n    /*\n     * { command: 'addSource', args: ['sourceId', source] }\n     */\n    addSource: 'addSource',\n\n    /*\n     * { command: 'removeSource', args: ['sourceId'] }\n     */\n    removeSource: 'removeSource',\n\n    /*\n     * { command: 'setGeoJSONSourceData', args: ['sourceId', data] }\n     */\n    setGeoJSONSourceData: 'setGeoJSONSourceData',\n\n    /*\n     * { command: 'setLayerZoomRange', args: ['layerId', 0, 22] }\n     */\n    setLayerZoomRange: 'setLayerZoomRange',\n\n    /*\n     * { command: 'setLayerProperty', args: ['layerId', 'prop', value] }\n     */\n    setLayerProperty: 'setLayerProperty',\n\n    /*\n     * { command: 'setCenter', args: [[lon, lat]] }\n     */\n    setCenter: 'setCenter',\n\n    /*\n     * { command: 'setZoom', args: [zoom] }\n     */\n    setZoom: 'setZoom',\n\n    /*\n     * { command: 'setBearing', args: [bearing] }\n     */\n    setBearing: 'setBearing',\n\n    /*\n     * { command: 'setPitch', args: [pitch] }\n     */\n    setPitch: 'setPitch',\n\n    /*\n     * { command: 'setSprite', args: ['spriteUrl'] }\n     */\n    setSprite: 'setSprite',\n\n    /*\n     * { command: 'setGlyphs', args: ['glyphsUrl'] }\n     */\n    setGlyphs: 'setGlyphs',\n\n    /*\n     * { command: 'setTransition', args: [transition] }\n     */\n    setTransition: 'setTransition',\n\n    /*\n     * { command: 'setLighting', args: [lightProperties] }\n     */\n    setLight: 'setLight',\n\n    /*\n     * { command: 'setTerrain', args: [terrainProperties] }\n     */\n    setTerrain: 'setTerrain',\n\n    /*\n     *  { command: 'setFog', args: [fogProperties] }\n     */\n    setFog: 'setFog',\n\n    /*\n     *  { command: 'setProjection', args: [projectionProperties] }\n     */\n    setProjection: 'setProjection'\n};\n\nfunction addSource(sourceId, after, commands) {\n    commands.push({command: operations.addSource, args: [sourceId, after[sourceId]]});\n}\n\nfunction removeSource(sourceId, commands, sourcesRemoved) {\n    commands.push({command: operations.removeSource, args: [sourceId]});\n    sourcesRemoved[sourceId] = true;\n}\n\nfunction updateSource(sourceId, after, commands, sourcesRemoved) {\n    removeSource(sourceId, commands, sourcesRemoved);\n    addSource(sourceId, after, commands);\n}\n\nfunction canUpdateGeoJSON(before, after, sourceId) {\n    let prop;\n    for (prop in before[sourceId]) {\n        if (!before[sourceId].hasOwnProperty(prop)) continue;\n        if (prop !== 'data' && !isEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    for (prop in after[sourceId]) {\n        if (!after[sourceId].hasOwnProperty(prop)) continue;\n        if (prop !== 'data' && !isEqual(before[sourceId][prop], after[sourceId][prop])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction diffSources(before, after, commands, sourcesRemoved) {\n    before = before || {};\n    after = after || {};\n\n    let sourceId;\n\n    // look for sources to remove\n    for (sourceId in before) {\n        if (!before.hasOwnProperty(sourceId)) continue;\n        if (!after.hasOwnProperty(sourceId)) {\n            removeSource(sourceId, commands, sourcesRemoved);\n        }\n    }\n\n    // look for sources to add/update\n    for (sourceId in after) {\n        if (!after.hasOwnProperty(sourceId)) continue;\n        if (!before.hasOwnProperty(sourceId)) {\n            addSource(sourceId, after, commands);\n        } else if (!isEqual(before[sourceId], after[sourceId])) {\n            if (before[sourceId].type === 'geojson' && after[sourceId].type === 'geojson' && canUpdateGeoJSON(before, after, sourceId)) {\n                commands.push({command: operations.setGeoJSONSourceData, args: [sourceId, after[sourceId].data]});\n            } else {\n                // no update command, must remove then add\n                updateSource(sourceId, after, commands, sourcesRemoved);\n            }\n        }\n    }\n}\n\nfunction diffLayerPropertyChanges(before, after, commands, layerId, klass, command) {\n    before = before || {};\n    after = after || {};\n\n    let prop;\n\n    for (prop in before) {\n        if (!before.hasOwnProperty(prop)) continue;\n        if (!isEqual(before[prop], after[prop])) {\n            commands.push({command, args: [layerId, prop, after[prop], klass]});\n        }\n    }\n    for (prop in after) {\n        if (!after.hasOwnProperty(prop) || before.hasOwnProperty(prop)) continue;\n        if (!isEqual(before[prop], after[prop])) {\n            commands.push({command, args: [layerId, prop, after[prop], klass]});\n        }\n    }\n}\n\nfunction pluckId(layer) {\n    return layer.id;\n}\nfunction indexById(group, layer) {\n    group[layer.id] = layer;\n    return group;\n}\n\nfunction diffLayers(before, after, commands) {\n    before = before || [];\n    after = after || [];\n\n    // order of layers by id\n    const beforeOrder = before.map(pluckId);\n    const afterOrder = after.map(pluckId);\n\n    // index of layer by id\n    const beforeIndex = before.reduce(indexById, {});\n    const afterIndex = after.reduce(indexById, {});\n\n    // track order of layers as if they have been mutated\n    const tracker = beforeOrder.slice();\n\n    // layers that have been added do not need to be diffed\n    const clean = Object.create(null);\n\n    let i, d, layerId, beforeLayer, afterLayer, insertBeforeLayerId, prop;\n\n    // remove layers\n    for (i = 0, d = 0; i < beforeOrder.length; i++) {\n        layerId = beforeOrder[i];\n        if (!afterIndex.hasOwnProperty(layerId)) {\n            commands.push({command: operations.removeLayer, args: [layerId]});\n            tracker.splice(tracker.indexOf(layerId, d), 1);\n        } else {\n            // limit where in tracker we need to look for a match\n            d++;\n        }\n    }\n\n    // add/reorder layers\n    for (i = 0, d = 0; i < afterOrder.length; i++) {\n        // work backwards as insert is before an existing layer\n        layerId = afterOrder[afterOrder.length - 1 - i];\n\n        if (tracker[tracker.length - 1 - i] === layerId) continue;\n\n        if (beforeIndex.hasOwnProperty(layerId)) {\n            // remove the layer before we insert at the correct position\n            commands.push({command: operations.removeLayer, args: [layerId]});\n            tracker.splice(tracker.lastIndexOf(layerId, tracker.length - d), 1);\n        } else {\n            // limit where in tracker we need to look for a match\n            d++;\n        }\n\n        // add layer at correct position\n        insertBeforeLayerId = tracker[tracker.length - i];\n        commands.push({command: operations.addLayer, args: [afterIndex[layerId], insertBeforeLayerId]});\n        tracker.splice(tracker.length - i, 0, layerId);\n        clean[layerId] = true;\n    }\n\n    // update layers\n    for (i = 0; i < afterOrder.length; i++) {\n        layerId = afterOrder[i];\n        beforeLayer = beforeIndex[layerId];\n        afterLayer = afterIndex[layerId];\n\n        // no need to update if previously added (new or moved)\n        if (clean[layerId] || isEqual(beforeLayer, afterLayer)) continue;\n\n        // If source, source-layer, or type have changes, then remove the layer\n        // and add it back 'from scratch'.\n        if (!isEqual(beforeLayer.source, afterLayer.source) || !isEqual(beforeLayer['source-layer'], afterLayer['source-layer']) || !isEqual(beforeLayer.type, afterLayer.type)) {\n            commands.push({command: operations.removeLayer, args: [layerId]});\n            // we add the layer back at the same position it was already in, so\n            // there's no need to update the `tracker`\n            insertBeforeLayerId = tracker[tracker.lastIndexOf(layerId) + 1];\n            commands.push({command: operations.addLayer, args: [afterLayer, insertBeforeLayerId]});\n            continue;\n        }\n\n        // layout, paint, filter, minzoom, maxzoom\n        diffLayerPropertyChanges(beforeLayer.layout, afterLayer.layout, commands, layerId, null, operations.setLayoutProperty);\n        diffLayerPropertyChanges(beforeLayer.paint, afterLayer.paint, commands, layerId, null, operations.setPaintProperty);\n        if (!isEqual(beforeLayer.filter, afterLayer.filter)) {\n            commands.push({command: operations.setFilter, args: [layerId, afterLayer.filter]});\n        }\n        if (!isEqual(beforeLayer.minzoom, afterLayer.minzoom) || !isEqual(beforeLayer.maxzoom, afterLayer.maxzoom)) {\n            commands.push({command: operations.setLayerZoomRange, args: [layerId, afterLayer.minzoom, afterLayer.maxzoom]});\n        }\n\n        // handle all other layer props, including paint.*\n        for (prop in beforeLayer) {\n            if (!beforeLayer.hasOwnProperty(prop)) continue;\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||\n                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n            } else if (!isEqual(beforeLayer[prop], afterLayer[prop])) {\n                commands.push({command: operations.setLayerProperty, args: [layerId, prop, afterLayer[prop]]});\n            }\n        }\n        for (prop in afterLayer) {\n            if (!afterLayer.hasOwnProperty(prop) || beforeLayer.hasOwnProperty(prop)) continue;\n            if (prop === 'layout' || prop === 'paint' || prop === 'filter' ||\n                prop === 'metadata' || prop === 'minzoom' || prop === 'maxzoom') continue;\n            if (prop.indexOf('paint.') === 0) {\n                diffLayerPropertyChanges(beforeLayer[prop], afterLayer[prop], commands, layerId, prop.slice(6), operations.setPaintProperty);\n            } else if (!isEqual(beforeLayer[prop], afterLayer[prop])) {\n                commands.push({command: operations.setLayerProperty, args: [layerId, prop, afterLayer[prop]]});\n            }\n        }\n    }\n}\n\n/**\n * Diff two stylesheet\n *\n * Creates semanticly aware diffs that can easily be applied at runtime.\n * Operations produced by the diff closely resemble the mapbox-gl-js API. Any\n * error creating the diff will fall back to the 'setStyle' operation.\n *\n * Example diff:\n * [\n *     { command: 'setConstant', args: ['@water', '#0000FF'] },\n *     { command: 'setPaintProperty', args: ['background', 'background-color', 'black'] }\n * ]\n *\n * @private\n * @param {*} [before] stylesheet to compare from\n * @param {*} after stylesheet to compare to\n * @returns Array list of changes\n */\nexport default function diffStyles(before: StyleSpecification, after: StyleSpecification): Array<Command> {\n    if (!before) return [{command: operations.setStyle, args: [after]}];\n\n    let commands = [];\n\n    try {\n        // Handle changes to top-level properties\n        if (!isEqual(before.version, after.version)) {\n            return [{command: operations.setStyle, args: [after]}];\n        }\n        if (!isEqual(before.center, after.center)) {\n            commands.push({command: operations.setCenter, args: [after.center]});\n        }\n        if (!isEqual(before.zoom, after.zoom)) {\n            commands.push({command: operations.setZoom, args: [after.zoom]});\n        }\n        if (!isEqual(before.bearing, after.bearing)) {\n            commands.push({command: operations.setBearing, args: [after.bearing]});\n        }\n        if (!isEqual(before.pitch, after.pitch)) {\n            commands.push({command: operations.setPitch, args: [after.pitch]});\n        }\n        if (!isEqual(before.sprite, after.sprite)) {\n            commands.push({command: operations.setSprite, args: [after.sprite]});\n        }\n        if (!isEqual(before.glyphs, after.glyphs)) {\n            commands.push({command: operations.setGlyphs, args: [after.glyphs]});\n        }\n        if (!isEqual(before.transition, after.transition)) {\n            commands.push({command: operations.setTransition, args: [after.transition]});\n        }\n        if (!isEqual(before.light, after.light)) {\n            commands.push({command: operations.setLight, args: [after.light]});\n        }\n        if (!isEqual(before.fog, after.fog)) {\n            commands.push({command: operations.setFog, args: [after.fog]});\n        }\n        if (!isEqual(before.projection, after.projection)) {\n            commands.push({command: operations.setProjection, args: [after.projection]});\n        }\n\n        // Handle changes to `sources`\n        // If a source is to be removed, we also--before the removeSource\n        // command--need to remove all the style layers that depend on it.\n        const sourcesRemoved = {};\n\n        // First collect the {add,remove}Source commands\n        const removeOrAddSourceCommands = [];\n        diffSources(before.sources, after.sources, removeOrAddSourceCommands, sourcesRemoved);\n\n        // Push a removeLayer command for each style layer that depends on a\n        // source that's being removed.\n        // Also, exclude any such layers them from the input to `diffLayers`\n        // below, so that diffLayers produces the appropriate `addLayers`\n        // command\n        const beforeLayers = [];\n        if (before.layers) {\n            before.layers.forEach((layer) => {\n                if (layer.source && sourcesRemoved[layer.source]) {\n                    commands.push({command: operations.removeLayer, args: [layer.id]});\n                } else {\n                    beforeLayers.push(layer);\n                }\n            });\n        }\n\n        // Remove the terrain if the source for that terrain is being removed\n        let beforeTerrain = before.terrain;\n        if (beforeTerrain) {\n            if (sourcesRemoved[beforeTerrain.source]) {\n                commands.push({command: operations.setTerrain, args: [undefined]});\n                beforeTerrain = undefined;\n            }\n        }\n\n        commands = commands.concat(removeOrAddSourceCommands);\n\n        // Even though terrain is a top-level property\n        // Its like a layer in the sense that it depends on a source being present.\n        if (!isEqual(beforeTerrain, after.terrain)) {\n            commands.push({command: operations.setTerrain, args: [after.terrain]});\n        }\n\n        // Handle changes to `layers`\n        diffLayers(beforeLayers, after.layers, commands);\n\n    } catch (e) {\n        // fall back to setStyle\n        console.warn('Unable to compute style diff:', e);\n        commands = [{command: operations.setStyle, args: [after]}];\n    }\n\n    return commands;\n}\n","// @flow\n\n// Note: Do not inherit from Error. It breaks when transpiling to ES5.\n\nexport default class ValidationError {\n    message: string;\n    identifier: ?string;\n    line: ?number;\n\n    constructor(key: ?string, value: ?{ __line__: number }, message: string, identifier: ?string) {\n        this.message = (key ? `${key}: ` : '') + message;\n        if (identifier) this.identifier = identifier;\n\n        if (value !== null && value !== undefined && value.__line__) {\n            this.line = value.__line__;\n        }\n    }\n}\n","// @flow\n\n// Note: Do not inherit from Error. It breaks when transpiling to ES5.\n\nexport default class ParsingError {\n    message: string;\n    error: Error;\n    line: number;\n\n    constructor(error: Error) {\n        this.error = error;\n        this.message = error.message;\n        const match = error.message.match(/line (\\d+)/);\n        this.line = match ? parseInt(match[1], 10) : 0;\n    }\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport getType from '../util/get_type.js';\nimport validateSpec from './validate.js';\n\nimport type {ValidationOptions} from './validate.js';\n\ntype Options = ValidationOptions & {\n    objectElementValidators?: Function;\n};\n\nexport default function validateObject(options: Options): Array<ValidationError> {\n    const key = options.key;\n    const object = options.value;\n    const elementSpecs = options.valueSpec || {};\n    const elementValidators = options.objectElementValidators || {};\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    let errors = [];\n\n    const type = getType(object);\n    if (type !== 'object') {\n        return [new ValidationError(key, object, `object expected, ${type} found`)];\n    }\n\n    for (const objectKey in object) {\n        const elementSpecKey = objectKey.split('.')[0]; // treat 'paint.*' as 'paint'\n        const elementSpec = elementSpecs[elementSpecKey] || elementSpecs['*'];\n\n        let validateElement;\n        if (elementValidators[elementSpecKey]) {\n            validateElement = elementValidators[elementSpecKey];\n        } else if (elementSpecs[elementSpecKey]) {\n            validateElement = validateSpec;\n        } else if (elementValidators['*']) {\n            validateElement = elementValidators['*'];\n        } else if (elementSpecs['*']) {\n            validateElement = validateSpec;\n        }\n\n        if (!validateElement) {\n            errors.push(new ValidationError(key, object[objectKey], `unknown property \"${objectKey}\"`));\n            continue;\n        }\n\n        errors = errors.concat(validateElement({\n            key: (key ? `${key}.` : key) + objectKey,\n            value: object[objectKey],\n            valueSpec: elementSpec,\n            style,\n            styleSpec,\n            object,\n            objectKey\n        // $FlowFixMe[extra-arg]\n        }, object));\n    }\n\n    for (const elementSpecKey in elementSpecs) {\n        // Don't check `required` when there's a custom validator for that property.\n        if (elementValidators[elementSpecKey]) {\n            continue;\n        }\n\n        if (elementSpecs[elementSpecKey].required && elementSpecs[elementSpecKey]['default'] === undefined && object[elementSpecKey] === undefined) {\n            errors.push(new ValidationError(key, object, `missing required property \"${elementSpecKey}\"`));\n        }\n    }\n\n    return errors;\n}\n","// @flow\n\nimport getType from '../util/get_type.js';\nimport validate from './validate.js';\nimport ValidationError from '../error/validation_error.js';\n\nimport type {ValidationOptions} from './validate.js';\n\ntype Options = ValidationOptions & {\n    arrayElementValidator: Function;\n};\n\nexport default function validateArray(options: Options): Array<ValidationError> {\n    const array = options.value;\n    const arraySpec = options.valueSpec;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const key = options.key;\n    const validateArrayElement = options.arrayElementValidator || validate;\n\n    if (getType(array) !== 'array') {\n        return [new ValidationError(key, array, `array expected, ${getType(array)} found`)];\n    }\n\n    if (arraySpec.length && array.length !== arraySpec.length) {\n        return [new ValidationError(key, array, `array length ${arraySpec.length} expected, length ${array.length} found`)];\n    }\n\n    if (arraySpec['min-length'] && array.length < arraySpec['min-length']) {\n        return [new ValidationError(key, array, `array length at least ${arraySpec['min-length']} expected, length ${array.length} found`)];\n    }\n\n    let arrayElementSpec = {\n        \"type\": arraySpec.value,\n        \"values\": arraySpec.values,\n        \"minimum\": arraySpec.minimum,\n        \"maximum\": arraySpec.maximum,\n        function: undefined\n    };\n\n    if (styleSpec.$version < 7) {\n        arrayElementSpec.function = arraySpec.function;\n    }\n\n    if (getType(arraySpec.value) === 'object') {\n        arrayElementSpec = arraySpec.value;\n    }\n\n    let errors = [];\n    for (let i = 0; i < array.length; i++) {\n        errors = errors.concat(validateArrayElement({\n            array,\n            arrayIndex: i,\n            value: array[i],\n            valueSpec: arrayElementSpec,\n            style,\n            styleSpec,\n            key: `${key}[${i}]`\n        }));\n    }\n    return errors;\n}\n","// @flow\n\nimport getType from '../util/get_type.js';\nimport ValidationError from '../error/validation_error.js';\n\nimport type {ValidationOptions} from './validate.js';\n\ntype Options = ValidationOptions & {\n    arrayIndex: number;\n}\n\nexport default function validateNumber(options: Options): Array<ValidationError> {\n    const key = options.key;\n    const value = options.value;\n    const valueSpec = options.valueSpec;\n    let type = getType(value);\n\n    // eslint-disable-next-line no-self-compare\n    if (type === 'number' && value !== value) {\n        type = 'NaN';\n    }\n\n    if (type !== 'number') {\n        return [new ValidationError(key, value, `number expected, ${type} found`)];\n    }\n\n    if ('minimum' in valueSpec) {\n        let specMin = valueSpec.minimum;\n        if (getType(valueSpec.minimum) === 'array') {\n            const i = options.arrayIndex;\n            specMin = valueSpec.minimum[i];\n        }\n        if (value < specMin) {\n            return [new ValidationError(key, value, `${value} is less than the minimum value ${specMin}`)];\n        }\n    }\n\n    if ('maximum' in valueSpec) {\n        let specMax = valueSpec.maximum;\n        if (getType(valueSpec.maximum) === 'array') {\n            const i = options.arrayIndex;\n            specMax = valueSpec.maximum[i];\n        }\n        if (value > specMax) {\n            return [new ValidationError(key, value, `${value} is greater than the maximum value ${specMax}`)];\n        }\n    }\n\n    return [];\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport getType from '../util/get_type.js';\nimport validate from './validate.js';\nimport validateObject from './validate_object.js';\nimport validateArray from './validate_array.js';\nimport validateNumber from './validate_number.js';\nimport {isExpression} from '../expression/index.js';\nimport {unbundle, deepUnbundle} from '../util/unbundle_jsonlint.js';\nimport {\n    supportsPropertyExpression,\n    supportsZoomExpression,\n    supportsInterpolation\n} from '../util/properties.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateFunction(options: ValidationOptions): any {\n    const functionValueSpec = options.valueSpec;\n    const functionType = unbundle(options.value.type);\n    let stopKeyType;\n    let stopDomainValues: {[string | number]: boolean} = {};\n    let previousStopDomainValue;\n    let previousStopDomainZoom;\n\n    const isZoomFunction = functionType !== 'categorical' && options.value.property === undefined;\n    const isPropertyFunction = !isZoomFunction;\n    const isZoomAndPropertyFunction =\n        getType(options.value.stops) === 'array' &&\n        getType(options.value.stops[0]) === 'array' &&\n        getType(options.value.stops[0][0]) === 'object';\n\n    const errors = validateObject({\n        key: options.key,\n        value: options.value,\n        valueSpec: options.styleSpec.function,\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n            stops: validateFunctionStops,\n            default: validateFunctionDefault\n        }\n    });\n\n    if (functionType === 'identity' && isZoomFunction) {\n        errors.push(new ValidationError(options.key, options.value, 'missing required property \"property\"'));\n    }\n\n    if (functionType !== 'identity' && !options.value.stops) {\n        errors.push(new ValidationError(options.key, options.value, 'missing required property \"stops\"'));\n    }\n\n    if (functionType === 'exponential' && options.valueSpec.expression && !supportsInterpolation(options.valueSpec)) {\n        errors.push(new ValidationError(options.key, options.value, 'exponential functions not supported'));\n    }\n\n    if (options.styleSpec.$version >= 8) {\n        if (isPropertyFunction && !supportsPropertyExpression(options.valueSpec)) {\n            errors.push(new ValidationError(options.key, options.value, 'property functions not supported'));\n        } else if (isZoomFunction && !supportsZoomExpression(options.valueSpec)) {\n            errors.push(new ValidationError(options.key, options.value, 'zoom functions not supported'));\n        }\n    }\n\n    if ((functionType === 'categorical' || isZoomAndPropertyFunction) && options.value.property === undefined) {\n        errors.push(new ValidationError(options.key, options.value, '\"property\" property is required'));\n    }\n\n    return errors;\n\n    function validateFunctionStops(options: ValidationOptions) {\n        if (functionType === 'identity') {\n            return [new ValidationError(options.key, options.value, 'identity function may not have a \"stops\" property')];\n        }\n\n        let errors = [];\n        const value = options.value;\n\n        errors = errors.concat(validateArray({\n            key: options.key,\n            value,\n            valueSpec: options.valueSpec,\n            style: options.style,\n            styleSpec: options.styleSpec,\n            arrayElementValidator: validateFunctionStop\n        }));\n\n        if (getType(value) === 'array' && value.length === 0) {\n            errors.push(new ValidationError(options.key, value, 'array must have at least one stop'));\n        }\n\n        return errors;\n    }\n\n    function validateFunctionStop(options: ValidationOptions) {\n        let errors = [];\n        const value = options.value;\n        const key = options.key;\n\n        if (getType(value) !== 'array') {\n            return [new ValidationError(key, value, `array expected, ${getType(value)} found`)];\n        }\n\n        if (value.length !== 2) {\n            return [new ValidationError(key, value, `array length 2 expected, length ${value.length} found`)];\n        }\n\n        if (isZoomAndPropertyFunction) {\n            if (getType(value[0]) !== 'object') {\n                return [new ValidationError(key, value, `object expected, ${getType(value[0])} found`)];\n            }\n            if (value[0].zoom === undefined) {\n                return [new ValidationError(key, value, 'object stop key must have zoom')];\n            }\n            if (value[0].value === undefined) {\n                return [new ValidationError(key, value, 'object stop key must have value')];\n            }\n\n            const nextStopDomainZoom = unbundle(value[0].zoom);\n            if (typeof nextStopDomainZoom !== 'number') {\n                return [new ValidationError(key, value[0].zoom, 'stop zoom values must be numbers')];\n            }\n\n            if (previousStopDomainZoom && previousStopDomainZoom > nextStopDomainZoom) {\n                return [new ValidationError(key, value[0].zoom, 'stop zoom values must appear in ascending order')];\n            }\n            if (nextStopDomainZoom !== previousStopDomainZoom) {\n                previousStopDomainZoom = nextStopDomainZoom;\n                previousStopDomainValue = undefined;\n                stopDomainValues = {};\n            }\n            errors = errors.concat(validateObject({\n                key: `${key}[0]`,\n                value: value[0],\n                valueSpec: {zoom: {}},\n                style: options.style,\n                styleSpec: options.styleSpec,\n                objectElementValidators: {zoom: validateNumber, value: validateStopDomainValue}\n            }));\n        } else {\n            errors = errors.concat(validateStopDomainValue({\n                key: `${key}[0]`,\n                value: value[0],\n                valueSpec: {},\n                style: options.style,\n                styleSpec: options.styleSpec\n            }, value));\n        }\n\n        if (isExpression(deepUnbundle(value[1]))) {\n            return errors.concat([new ValidationError(`${key}[1]`, value[1], 'expressions are not allowed in function stops.')]);\n        }\n\n        return errors.concat(validate({\n            key: `${key}[1]`,\n            value: value[1],\n            valueSpec: functionValueSpec,\n            style: options.style,\n            styleSpec: options.styleSpec\n        }));\n    }\n\n    function validateStopDomainValue(options: ValidationOptions, stop) {\n        const type = getType(options.value);\n        const value = unbundle(options.value);\n\n        const reportValue = options.value !== null ? options.value : stop;\n\n        if (!stopKeyType) {\n            stopKeyType = type;\n        } else if (type !== stopKeyType) {\n            return [new ValidationError(options.key, reportValue, `${type} stop domain type must match previous stop domain type ${stopKeyType}`)];\n        }\n\n        if (type !== 'number' && type !== 'string' && type !== 'boolean' && typeof value !== 'number' && typeof value !== 'string' && typeof value !== 'boolean') {\n            return [new ValidationError(options.key, reportValue, 'stop domain value must be a number, string, or boolean')];\n        }\n\n        if (type !== 'number' && functionType !== 'categorical') {\n            let message = `number expected, ${type} found`;\n            if (supportsPropertyExpression(functionValueSpec) && functionType === undefined) {\n                message += '\\nIf you intended to use a categorical function, specify `\"type\": \"categorical\"`.';\n            }\n            return [new ValidationError(options.key, reportValue, message)];\n        }\n\n        if (functionType === 'categorical' && type === 'number' && (typeof value !== 'number' || !isFinite(value) || Math.floor(value) !== value)) {\n            return [new ValidationError(options.key, reportValue, `integer expected, found ${String(value)}`)];\n        }\n\n        if (functionType !== 'categorical' && type === 'number' && typeof value === 'number' && typeof previousStopDomainValue === 'number' && previousStopDomainValue !== undefined && value < previousStopDomainValue) {\n            return [new ValidationError(options.key, reportValue, 'stop domain values must appear in ascending order')];\n        } else {\n            previousStopDomainValue = value;\n        }\n\n        if (functionType === 'categorical' && (value: any) in stopDomainValues) {\n            return [new ValidationError(options.key, reportValue, 'stop domain values must be unique')];\n        } else {\n            stopDomainValues[(value: any)] = true;\n        }\n\n        return [];\n    }\n\n    function validateFunctionDefault(options: ValidationOptions) {\n        return validate({\n            key: options.key,\n            value: options.value,\n            valueSpec: functionValueSpec,\n            style: options.style,\n            styleSpec: options.styleSpec\n        });\n    }\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\n\nimport {createExpression, createPropertyExpression} from '../expression/index.js';\nimport {deepUnbundle} from '../util/unbundle_jsonlint.js';\nimport {isStateConstant, isGlobalPropertyConstant, isFeatureConstant} from '../expression/is_constant.js';\nimport CompoundExpression from '../expression/compound_expression.js';\n\nimport type {Expression} from '../expression/expression.js';\n\nexport default function validateExpression(options: any): Array<ValidationError> {\n    const expression = (options.expressionContext === 'property' ? createPropertyExpression : createExpression)(deepUnbundle(options.value), options.valueSpec);\n    if (expression.result === 'error') {\n        return expression.value.map((error) => {\n            return new ValidationError(`${options.key}${error.key}`, options.value, error.message);\n        });\n    }\n\n    const expressionObj = (expression.value: any).expression || (expression.value: any)._styleExpression.expression;\n\n    if (options.expressionContext === 'property' && (options.propertyKey === 'text-font') &&\n        !expressionObj.outputDefined()) {\n        return [new ValidationError(options.key, options.value, `Invalid data expression for \"${options.propertyKey}\". Output values must be contained as literals within the expression.`)];\n    }\n\n    if (options.expressionContext === 'property' && options.propertyType === 'layout' &&\n        (!isStateConstant(expressionObj))) {\n        return [new ValidationError(options.key, options.value, '\"feature-state\" data expressions are not supported with layout properties.')];\n    }\n\n    if (options.expressionContext === 'filter') {\n        return disallowedFilterParameters(expressionObj, options);\n    }\n\n    if (options.expressionContext && options.expressionContext.indexOf('cluster') === 0) {\n        if (!isGlobalPropertyConstant(expressionObj, ['zoom', 'feature-state'])) {\n            return [new ValidationError(options.key, options.value, '\"zoom\" and \"feature-state\" expressions are not supported with cluster properties.')];\n        }\n        if (options.expressionContext === 'cluster-initial' && !isFeatureConstant(expressionObj)) {\n            return [new ValidationError(options.key, options.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];\n        }\n    }\n\n    return [];\n}\n\nexport function disallowedFilterParameters(e: Expression, options: any): Array<ValidationError> {\n    const disallowedParameters = new Set([\n        'zoom',\n        'feature-state',\n        'pitch',\n        'distance-from-center'\n    ]);\n\n    if (options.valueSpec && options.valueSpec.expression) {\n        for (const param of options.valueSpec.expression.parameters) {\n            disallowedParameters.delete(param);\n        }\n    }\n\n    if (disallowedParameters.size === 0) {\n        return [];\n    }\n    const errors = [];\n\n    if (e instanceof CompoundExpression) {\n        if (disallowedParameters.has(e.name)) {\n            return [new ValidationError(options.key, options.value, `[\"${e.name}\"] expression is not supported in a filter for a ${options.object.type} layer with id: ${options.object.id}`)];\n        }\n    }\n    e.eachChild((arg) => {\n        errors.push(...disallowedFilterParameters(arg, options));\n    });\n\n    return errors;\n}\n","// @flow\n\nimport getType from '../util/get_type.js';\nimport ValidationError from '../error/validation_error.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateBoolean(options: ValidationOptions): Array<ValidationError> {\n    const value = options.value;\n    const key = options.key;\n    const type = getType(value);\n\n    if (type !== 'boolean') {\n        return [new ValidationError(key, value, `boolean expected, ${type} found`)];\n    }\n\n    return [];\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport getType from '../util/get_type.js';\nimport {parseCSSColor} from 'csscolorparser';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateColor(options: ValidationOptions): Array<ValidationError> {\n    const key = options.key;\n    const value = options.value;\n    const type = getType(value);\n\n    if (type !== 'string') {\n        return [new ValidationError(key, value, `color expected, ${type} found`)];\n    }\n\n    if (parseCSSColor(value) === null) {\n        return [new ValidationError(key, value, `color expected, \"${value}\" found`)];\n    }\n\n    return [];\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport {unbundle} from '../util/unbundle_jsonlint.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateEnum(options: ValidationOptions): Array<ValidationError> {\n    const key = options.key;\n    const value = options.value;\n    const valueSpec = options.valueSpec;\n    const errors = [];\n\n    if (Array.isArray(valueSpec.values)) { // <=v7\n        if (valueSpec.values.indexOf(unbundle(value)) === -1) {\n            errors.push(new ValidationError(key, value, `expected one of [${valueSpec.values.join(', ')}], ${JSON.stringify(value)} found`));\n        }\n    } else { // >=v8\n        if (Object.keys(valueSpec.values).indexOf(unbundle(value)) === -1) {\n            errors.push(new ValidationError(key, value, `expected one of [${Object.keys(valueSpec.values).join(', ')}], ${JSON.stringify(value)} found`));\n        }\n    }\n    return errors;\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport validateExpression from './validate_expression.js';\nimport validateEnum from './validate_enum.js';\nimport getType from '../util/get_type.js';\nimport {unbundle, deepUnbundle} from '../util/unbundle_jsonlint.js';\nimport extend from '../util/extend.js';\nimport {isExpressionFilter} from '../feature_filter/index.js';\n\nimport type {ValidationOptions} from './validate.js';\n\ntype Options = ValidationOptions & {\n    layerType: string;\n}\n\nexport default function validateFilter(options: Options): Array<ValidationError> {\n    if (isExpressionFilter(deepUnbundle(options.value))) {\n        // We default to a layerType of `fill` because that points to a non-dynamic filter definition within the style-spec.\n        const layerType = options.layerType || 'fill';\n\n        return validateExpression(extend({}, options, {\n            expressionContext: 'filter',\n            valueSpec: options.styleSpec[`filter_${layerType}`]\n        }));\n    } else {\n        return validateNonExpressionFilter(options);\n    }\n}\n\nfunction validateNonExpressionFilter(options) {\n    const value = options.value;\n    const key = options.key;\n\n    if (getType(value) !== 'array') {\n        return [new ValidationError(key, value, `array expected, ${getType(value)} found`)];\n    }\n\n    const styleSpec = options.styleSpec;\n    let type;\n\n    let errors = [];\n\n    if (value.length < 1) {\n        return [new ValidationError(key, value, 'filter array must have at least 1 element')];\n    }\n\n    errors = errors.concat(validateEnum({\n        key: `${key}[0]`,\n        value: value[0],\n        valueSpec: styleSpec.filter_operator,\n        style: options.style,\n        styleSpec: options.styleSpec\n    }));\n\n    switch (unbundle(value[0])) {\n    case '<':\n    case '<=':\n    case '>':\n    case '>=':\n        if (value.length >= 2 && unbundle(value[1]) === '$type') {\n            errors.push(new ValidationError(key, value, `\"$type\" cannot be use with operator \"${value[0]}\"`));\n        }\n        /* falls through */\n    case '==':\n    case '!=':\n        if (value.length !== 3) {\n            errors.push(new ValidationError(key, value, `filter array for operator \"${value[0]}\" must have 3 elements`));\n        }\n        /* falls through */\n    case 'in':\n    case '!in':\n        if (value.length >= 2) {\n            type = getType(value[1]);\n            if (type !== 'string') {\n                errors.push(new ValidationError(`${key}[1]`, value[1], `string expected, ${type} found`));\n            }\n        }\n        for (let i = 2; i < value.length; i++) {\n            type = getType(value[i]);\n            if (unbundle(value[1]) === '$type') {\n                errors = errors.concat(validateEnum({\n                    key: `${key}[${i}]`,\n                    value: value[i],\n                    valueSpec: styleSpec.geometry_type,\n                    style: options.style,\n                    styleSpec: options.styleSpec\n                }));\n            } else if (type !== 'string' && type !== 'number' && type !== 'boolean') {\n                errors.push(new ValidationError(`${key}[${i}]`, value[i], `string, number, or boolean expected, ${type} found`));\n            }\n        }\n        break;\n\n    case 'any':\n    case 'all':\n    case 'none':\n        for (let i = 1; i < value.length; i++) {\n            errors = errors.concat(validateNonExpressionFilter({\n                key: `${key}[${i}]`,\n                value: value[i],\n                style: options.style,\n                styleSpec: options.styleSpec\n            }));\n        }\n        break;\n\n    case 'has':\n    case '!has':\n        type = getType(value[1]);\n        if (value.length !== 2) {\n            errors.push(new ValidationError(key, value, `filter array for \"${value[0]}\" operator must have 2 elements`));\n        } else if (type !== 'string') {\n            errors.push(new ValidationError(`${key}[1]`, value[1], `string expected, ${type} found`));\n        }\n        break;\n    case 'within':\n        type = getType(value[1]);\n        if (value.length !== 2) {\n            errors.push(new ValidationError(key, value, `filter array for \"${value[0]}\" operator must have 2 elements`));\n        } else if (type !== 'object') {\n            errors.push(new ValidationError(`${key}[1]`, value[1], `object expected, ${type} found`));\n        }\n        break;\n    }\n    return errors;\n}\n","// @flow\n\nimport validate from './validate.js';\nimport ValidationError from '../error/validation_error.js';\nimport getType from '../util/get_type.js';\nimport {isFunction} from '../function/index.js';\nimport {unbundle, deepUnbundle} from '../util/unbundle_jsonlint.js';\nimport {supportsPropertyExpression} from '../util/properties.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport type PropertyValidationOptions = ValidationOptions & {\n    objectKey: string;\n    layerType: string;\n}\n\nexport default function validateProperty(options: PropertyValidationOptions, propertyType: string): Array<ValidationError> {\n    const key = options.key;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const value = options.value;\n    const propertyKey = options.objectKey;\n    const layerSpec = styleSpec[`${propertyType}_${options.layerType}`];\n\n    if (!layerSpec) return [];\n\n    const transitionMatch = propertyKey.match(/^(.*)-transition$/);\n    if (propertyType === 'paint' && transitionMatch && layerSpec[transitionMatch[1]] && layerSpec[transitionMatch[1]].transition) {\n        return validate({\n            key,\n            value,\n            valueSpec: styleSpec.transition,\n            style,\n            styleSpec\n        });\n    }\n\n    const valueSpec = options.valueSpec || layerSpec[propertyKey];\n    if (!valueSpec) {\n        return [new ValidationError(key, value, `unknown property \"${propertyKey}\"`)];\n    }\n\n    let tokenMatch;\n    if (getType(value) === 'string' && supportsPropertyExpression(valueSpec) && !valueSpec.tokens && (tokenMatch = /^{([^}]+)}$/.exec(value))) {\n        return [new ValidationError(\n            key, value,\n            `\"${propertyKey}\" does not support interpolation syntax\\n` +\n                `Use an identity property function instead: \\`{ \"type\": \"identity\", \"property\": ${JSON.stringify(tokenMatch[1])} }\\`.`)];\n    }\n\n    const errors = [];\n\n    if (options.layerType === 'symbol') {\n        if (propertyKey === 'text-field' && style && !style.glyphs) {\n            errors.push(new ValidationError(key, value, 'use of \"text-field\" requires a style \"glyphs\" property'));\n        }\n        if (propertyKey === 'text-font' && isFunction(deepUnbundle(value)) && unbundle(value.type) === 'identity') {\n            errors.push(new ValidationError(key, value, '\"text-font\" does not support identity functions'));\n        }\n    }\n\n    return errors.concat(validate({\n        key: options.key,\n        value,\n        valueSpec,\n        style,\n        styleSpec,\n        expressionContext: 'property',\n        propertyType,\n        propertyKey\n    }));\n}\n","// @flow\n\nimport validateProperty from './validate_property.js';\n\nimport type ValidationError from '../error/validation_error.js';\nimport type {PropertyValidationOptions} from './validate_property.js';\n\nexport default function validatePaintProperty(options: PropertyValidationOptions): Array<ValidationError> {\n    return validateProperty(options, 'paint');\n}\n","// @flow\n\nimport validateProperty from './validate_property.js';\n\nimport type ValidationError from '../error/validation_error.js';\nimport type {PropertyValidationOptions} from './validate_property.js';\n\nexport default function validateLayoutProperty(options: PropertyValidationOptions): Array<ValidationError> {\n    return validateProperty(options, 'layout');\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport {unbundle} from '../util/unbundle_jsonlint.js';\nimport validateObject from './validate_object.js';\nimport validateFilter from './validate_filter.js';\nimport validatePaintProperty from './validate_paint_property.js';\nimport validateLayoutProperty from './validate_layout_property.js';\nimport validateSpec from './validate.js';\nimport extend from '../util/extend.js';\n\nimport type {ValidationOptions} from './validate.js';\nimport type {LayerSpecification} from '../types.js';\n\ntype Options = ValidationOptions & {\n    value: LayerSpecification;\n    arrayIndex: number;\n}\n\nexport default function validateLayer(options: Options): Array<ValidationError> {\n    let errors = [];\n\n    const layer = options.value;\n    const key = options.key;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n\n    if (!layer.type && !layer.ref) {\n        errors.push(new ValidationError(key, layer, 'either \"type\" or \"ref\" is required'));\n    }\n    let type = unbundle(layer.type);\n    const ref = unbundle(layer.ref);\n\n    if (layer.id) {\n        const layerId = unbundle(layer.id);\n        for (let i = 0; i < options.arrayIndex; i++) {\n            const otherLayer = style.layers[i];\n            if (unbundle(otherLayer.id) === layerId) {\n                // $FlowFixMe[prop-missing] - id.__line__ is added dynamically during the readStyle step\n                errors.push(new ValidationError(key, layer.id, `duplicate layer id \"${layer.id}\", previously used at line ${otherLayer.id.__line__}`));\n            }\n        }\n    }\n\n    if ('ref' in layer) {\n        ['type', 'source', 'source-layer', 'filter', 'layout'].forEach((p) => {\n            if (p in layer) {\n                errors.push(new ValidationError(key, layer[p], `\"${p}\" is prohibited for ref layers`));\n            }\n        });\n\n        let parent;\n\n        style.layers.forEach((layer) => {\n            if (unbundle(layer.id) === ref) parent = layer;\n        });\n\n        if (!parent) {\n            if (typeof ref === 'string')\n                errors.push(new ValidationError(key, layer.ref, `ref layer \"${ref}\" not found`));\n        } else if (parent.ref) {\n            errors.push(new ValidationError(key, layer.ref, 'ref cannot reference another ref layer'));\n        } else {\n            type = unbundle(parent.type);\n        }\n    } else if (!(type === 'background' || type === 'sky')) {\n        if (!layer.source) {\n            errors.push(new ValidationError(key, layer, 'missing required property \"source\"'));\n        } else {\n            const source = style.sources && style.sources[layer.source];\n            const sourceType = source && unbundle(source.type);\n            if (!source) {\n                errors.push(new ValidationError(key, layer.source, `source \"${layer.source}\" not found`));\n            } else if (sourceType === 'vector' && type === 'raster') {\n                errors.push(new ValidationError(key, layer.source, `layer \"${layer.id}\" requires a raster source`));\n            } else if (sourceType === 'raster' && type !== 'raster') {\n                errors.push(new ValidationError(key, layer.source, `layer \"${layer.id}\" requires a vector source`));\n            } else if (sourceType === 'vector' && !layer['source-layer']) {\n                errors.push(new ValidationError(key, layer, `layer \"${layer.id}\" must specify a \"source-layer\"`));\n            } else if (sourceType === 'raster-dem' && type !== 'hillshade') {\n                errors.push(new ValidationError(key, layer.source, 'raster-dem source can only be used with layer type \\'hillshade\\'.'));\n            } else if (type === 'line' && layer.paint && (layer.paint['line-gradient'] || layer.paint['line-trim-offset']) &&\n                       (sourceType !== 'geojson' || !source.lineMetrics)) {\n                errors.push(new ValidationError(key, layer, `layer \"${layer.id}\" specifies a line-gradient, which requires a GeoJSON source with \\`lineMetrics\\` enabled.`));\n            }\n        }\n    }\n\n    errors = errors.concat(validateObject({\n        key,\n        value: layer,\n        valueSpec: styleSpec.layer,\n        style: options.style,\n        styleSpec: options.styleSpec,\n        objectElementValidators: {\n            '*'() {\n                return [];\n            },\n            // We don't want to enforce the spec's `\"requires\": true` for backward compatibility with refs;\n            // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.\n            type() {\n                return validateSpec({\n                    key: `${key}.type`,\n                    value: layer.type,\n                    valueSpec: styleSpec.layer.type,\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    object: layer,\n                    objectKey: 'type'\n                });\n            },\n            filter(options) {\n                return validateFilter(extend({layerType: type}, options));\n            },\n            layout(options) {\n                return validateObject({\n                    layer,\n                    key: options.key,\n                    value: options.value,\n                    valueSpec: {},\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    objectElementValidators: {\n                        '*'(options) {\n                            return validateLayoutProperty(extend({layerType: type}, options));\n                        }\n                    }\n                });\n            },\n            paint(options) {\n                return validateObject({\n                    layer,\n                    key: options.key,\n                    value: options.value,\n                    valueSpec: {},\n                    style: options.style,\n                    styleSpec: options.styleSpec,\n                    objectElementValidators: {\n                        '*'(options) {\n                            return validatePaintProperty(extend({layerType: type}, options));\n                        }\n                    }\n                });\n            }\n        }\n    }));\n\n    return errors;\n}\n","// @flow\n\nimport getType from '../util/get_type.js';\nimport ValidationError from '../error/validation_error.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateString(options: $Shape<ValidationOptions>): Array<ValidationError> {\n    const value = options.value;\n    const key = options.key;\n    const type = getType(value);\n\n    if (type !== 'string') {\n        return [new ValidationError(key, value, `string expected, ${type} found`)];\n    }\n\n    return [];\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport {unbundle} from '../util/unbundle_jsonlint.js';\nimport validateObject from './validate_object.js';\nimport validateEnum from './validate_enum.js';\nimport validateExpression from './validate_expression.js';\nimport validateString from './validate_string.js';\nimport getType from '../util/get_type.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nconst objectElementValidators = {\n    promoteId: validatePromoteId\n};\n\nexport default function validateSource(options: ValidationOptions): Array<ValidationError> {\n    const value = options.value;\n    const key = options.key;\n    const styleSpec = options.styleSpec;\n    const style = options.style;\n\n    if (!value.type) {\n        return [new ValidationError(key, value, '\"type\" is required')];\n    }\n\n    const type = unbundle(value.type);\n    let errors;\n\n    switch (type) {\n    case 'vector':\n    case 'raster':\n    case 'raster-dem':\n        errors = validateObject({\n            key,\n            value,\n            valueSpec: styleSpec[`source_${type.replace('-', '_')}`],\n            style: options.style,\n            styleSpec,\n            objectElementValidators\n        });\n        return errors;\n\n    case 'geojson':\n        errors = validateObject({\n            key,\n            value,\n            valueSpec: styleSpec.source_geojson,\n            style,\n            styleSpec,\n            objectElementValidators\n        });\n        if (value.cluster) {\n            for (const prop in value.clusterProperties) {\n                const [operator, mapExpr] = value.clusterProperties[prop];\n                const reduceExpr = typeof operator === 'string' ? [operator, ['accumulated'], ['get', prop]] : operator;\n\n                errors.push(...validateExpression({\n                    key: `${key}.${prop}.map`,\n                    value: mapExpr,\n                    expressionContext: 'cluster-map'\n                }));\n                errors.push(...validateExpression({\n                    key: `${key}.${prop}.reduce`,\n                    value: reduceExpr,\n                    expressionContext: 'cluster-reduce'\n                }));\n            }\n        }\n        return errors;\n\n    case 'video':\n        return validateObject({\n            key,\n            value,\n            valueSpec: styleSpec.source_video,\n            style,\n            styleSpec\n        });\n\n    case 'image':\n        return validateObject({\n            key,\n            value,\n            valueSpec: styleSpec.source_image,\n            style,\n            styleSpec\n        });\n\n    case 'canvas':\n        return [new ValidationError(key, null, `Please use runtime APIs to add canvas sources, rather than including them in stylesheets.`, 'source.canvas')];\n\n    default:\n        return validateEnum({\n            key: `${key}.type`,\n            value: value.type,\n            valueSpec: {values: getSourceTypeValues(styleSpec)},\n            style,\n            styleSpec\n        });\n    }\n}\n\nfunction getSourceTypeValues(styleSpec) {\n    return styleSpec.source.reduce((memo, source) => {\n        const sourceType = styleSpec[source];\n        if (sourceType.type.type === 'enum') {\n            memo = memo.concat(Object.keys(sourceType.type.values));\n        }\n        return memo;\n    }, []);\n}\n\nfunction validatePromoteId({key, value}) {\n    if (getType(value) === 'string') {\n        return validateString({key, value});\n    } else {\n        const errors = [];\n        for (const prop in value) {\n            errors.push(...validateString({key: `${key}.${prop}`, value: value[prop]}));\n        }\n        return errors;\n    }\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport getType from '../util/get_type.js';\nimport validate from './validate.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateLight(options: ValidationOptions): Array<ValidationError> {\n    const light = options.value;\n    const styleSpec = options.styleSpec;\n    const lightSpec = styleSpec.light;\n    const style = options.style;\n\n    let errors = [];\n\n    const rootType = getType(light);\n    if (light === undefined) {\n        return errors;\n    } else if (rootType !== 'object') {\n        errors = errors.concat([new ValidationError('light', light, `object expected, ${rootType} found`)]);\n        return errors;\n    }\n\n    for (const key in light) {\n        const transitionMatch = key.match(/^(.*)-transition$/);\n\n        if (transitionMatch && lightSpec[transitionMatch[1]] && lightSpec[transitionMatch[1]].transition) {\n            errors = errors.concat(validate({\n                key,\n                value: light[key],\n                valueSpec: styleSpec.transition,\n                style,\n                styleSpec\n            }));\n        } else if (lightSpec[key]) {\n            errors = errors.concat(validate({\n                key,\n                value: light[key],\n                valueSpec: lightSpec[key],\n                style,\n                styleSpec\n            }));\n        } else {\n            errors = errors.concat([new ValidationError(key, light[key], `unknown property \"${key}\"`)]);\n        }\n    }\n\n    return errors;\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport validate from './validate.js';\nimport getType from '../util/get_type.js';\nimport {unbundle} from '../util/unbundle_jsonlint.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateTerrain(options: ValidationOptions): Array<ValidationError> {\n    const terrain = options.value;\n    const key = options.key;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const terrainSpec = styleSpec.terrain;\n    let errors = [];\n\n    const rootType = getType(terrain);\n    if (terrain === undefined) {\n        return errors;\n    } else if (rootType !== 'object') {\n        errors = errors.concat([new ValidationError('terrain', terrain, `object expected, ${rootType} found`)]);\n        return errors;\n    }\n\n    for (const key in terrain) {\n        const transitionMatch = key.match(/^(.*)-transition$/);\n\n        if (transitionMatch && terrainSpec[transitionMatch[1]] && terrainSpec[transitionMatch[1]].transition) {\n            errors = errors.concat(validate({\n                key,\n                value: terrain[key],\n                valueSpec: styleSpec.transition,\n                style,\n                styleSpec\n            }));\n        } else if (terrainSpec[key]) {\n            errors = errors.concat(validate({\n                key,\n                value: terrain[key],\n                valueSpec: terrainSpec[key],\n                style,\n                styleSpec\n            }));\n        } else {\n            errors = errors.concat([new ValidationError(key, terrain[key], `unknown property \"${key}\"`)]);\n        }\n    }\n\n    if (!terrain.source) {\n        errors.push(new ValidationError(key, terrain, `terrain is missing required property \"source\"`));\n    } else {\n        const source = style.sources && style.sources[terrain.source];\n        const sourceType = source && unbundle(source.type);\n        if (!source) {\n            errors.push(new ValidationError(key, terrain.source, `source \"${terrain.source}\" not found`));\n        } else if (sourceType !== 'raster-dem') {\n            errors.push(new ValidationError(key, terrain.source, `terrain cannot be used with a source of type ${String(sourceType)}, it only be used with a \"raster-dem\" source type`));\n        }\n    }\n\n    return errors;\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport validate from './validate.js';\nimport getType from '../util/get_type.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateFog(options: ValidationOptions): Array<ValidationError> {\n    const fog = options.value;\n    const style = options.style;\n    const styleSpec = options.styleSpec;\n    const fogSpec = styleSpec.fog;\n    let errors = [];\n\n    const rootType = getType(fog);\n    if (fog === undefined) {\n        return errors;\n    } else if (rootType !== 'object') {\n        errors = errors.concat([new ValidationError('fog', fog, `object expected, ${rootType} found`)]);\n        return errors;\n    }\n\n    for (const key in fog) {\n        const transitionMatch = key.match(/^(.*)-transition$/);\n\n        if (transitionMatch && fogSpec[transitionMatch[1]] && fogSpec[transitionMatch[1]].transition) {\n            errors = errors.concat(validate({\n                key,\n                value: fog[key],\n                valueSpec: styleSpec.transition,\n                style,\n                styleSpec\n            }));\n        } else if (fogSpec[key]) {\n            errors = errors.concat(validate({\n                key,\n                value: fog[key],\n                valueSpec: fogSpec[key],\n                style,\n                styleSpec\n            }));\n        } else {\n            errors = errors.concat([new ValidationError(key, fog[key], `unknown property \"${key}\"`)]);\n        }\n    }\n\n    return errors;\n}\n","// @flow\n\nimport validateExpression from './validate_expression.js';\nimport validateString from './validate_string.js';\n\nimport type {ValidationOptions} from './validate.js';\nimport type ValidationError from '../error/validation_error.js';\n\nexport default function validateFormatted(options: ValidationOptions): Array<ValidationError> {\n    if (validateString(options).length === 0) {\n        return [];\n    }\n\n    return validateExpression(options);\n}\n","// @flow\n\nimport validateExpression from './validate_expression.js';\nimport validateString from './validate_string.js';\n\nimport type {ValidationOptions} from './validate.js';\nimport type ValidationError from '../error/validation_error.js';\n\nexport default function validateImage(options: ValidationOptions): Array<ValidationError> {\n    if (validateString(options).length === 0) {\n        return [];\n    }\n\n    return validateExpression(options);\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport getType from '../util/get_type.js';\nimport validate from './validate.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function validateProjection(options: ValidationOptions): Array<ValidationError> {\n    const projection = options.value;\n    const styleSpec = options.styleSpec;\n    const projectionSpec = styleSpec.projection;\n    const style = options.style;\n\n    let errors = [];\n\n    const rootType = getType(projection);\n\n    if (rootType === 'object') {\n        for (const key in projection) {\n            errors = errors.concat(validate({\n                key,\n                value: projection[key],\n                valueSpec: projectionSpec[key],\n                style,\n                styleSpec\n            }));\n        }\n    } else if (rootType !== 'string') {\n        errors = errors.concat([new ValidationError('projection', projection, `object or string expected, ${rootType} found`)]);\n    }\n\n    return errors;\n}\n","// @flow\n\nimport extend from '../util/extend.js';\nimport {unbundle, deepUnbundle} from '../util/unbundle_jsonlint.js';\nimport {isExpression} from '../expression/index.js';\nimport {isFunction} from '../function/index.js';\n\nimport validateFunction from './validate_function.js';\nimport validateExpression from './validate_expression.js';\nimport validateObject from './validate_object.js';\nimport validateArray from './validate_array.js';\nimport validateBoolean from './validate_boolean.js';\nimport validateNumber from './validate_number.js';\nimport validateColor from './validate_color.js';\nimport validateEnum from './validate_enum.js';\nimport validateFilter from './validate_filter.js';\nimport validateLayer from './validate_layer.js';\nimport validateSource from './validate_source.js';\nimport validateLight from './validate_light.js';\nimport validateTerrain from './validate_terrain.js';\nimport validateFog from './validate_fog.js';\nimport validateString from './validate_string.js';\nimport validateFormatted from './validate_formatted.js';\nimport validateImage from './validate_image.js';\nimport validateProjection from './validate_projection.js';\n\nimport type {StyleReference} from '../reference/latest.js';\nimport type {StyleSpecification} from '../types.js';\nimport type ValidationError from '../error/validation_error.js';\n\nconst VALIDATORS = {\n    '*'() {\n        return [];\n    },\n    'array': validateArray,\n    'boolean': validateBoolean,\n    'number': validateNumber,\n    'color': validateColor,\n    'enum': validateEnum,\n    'filter': validateFilter,\n    'function': validateFunction,\n    'layer': validateLayer,\n    'object': validateObject,\n    'source': validateSource,\n    'light': validateLight,\n    'terrain': validateTerrain,\n    'fog': validateFog,\n    'string': validateString,\n    'formatted': validateFormatted,\n    'resolvedImage': validateImage,\n    'projection': validateProjection\n};\n\n// Main recursive validation function. Tracks:\n//\n// - key: string representing location of validation in style tree. Used only\n//   for more informative error reporting.\n// - value: current value from style being evaluated. May be anything from a\n//   high level object that needs to be descended into deeper or a simple\n//   scalar value.\n// - valueSpec: current spec being evaluated. Tracks value.\n// - styleSpec: current full spec being evaluated.\nexport type ValidationOptions = {\n    key: string;\n    value: Object;\n    valueSpec: Object;\n    style: $Shape<StyleSpecification>;\n    styleSpec: StyleReference;\n}\n\nexport default function validate(options: ValidationOptions): Array<ValidationError> {\n    const value = options.value;\n    const valueSpec = options.valueSpec;\n    const styleSpec = options.styleSpec;\n\n    if (valueSpec.expression && isFunction(unbundle(value))) {\n        return validateFunction(options);\n\n    } else if (valueSpec.expression && isExpression(deepUnbundle(value))) {\n        return validateExpression(options);\n\n    } else if (valueSpec.type && VALIDATORS[valueSpec.type]) {\n        return VALIDATORS[valueSpec.type](options);\n\n    } else {\n        const valid = validateObject(extend({}, options, {\n            valueSpec: valueSpec.type ? styleSpec[valueSpec.type] : valueSpec\n        }));\n        return valid;\n    }\n}\n","// @flow\n\nimport ValidationError from '../error/validation_error.js';\nimport validateString from './validate_string.js';\n\nimport type {ValidationOptions} from './validate.js';\n\nexport default function(options: ValidationOptions): Array<ValidationError> {\n    const value = options.value;\n    const key = options.key;\n\n    const errors = validateString(options);\n    if (errors.length) return errors;\n\n    if (value.indexOf('{fontstack}') === -1) {\n        errors.push(new ValidationError(key, value, '\"glyphs\" url must include a \"{fontstack}\" token'));\n    }\n\n    if (value.indexOf('{range}') === -1) {\n        errors.push(new ValidationError(key, value, '\"glyphs\" url must include a \"{range}\" token'));\n    }\n\n    return errors;\n}\n","// @flow\nimport validate from './validate/validate.js';\nimport latestStyleSpec from './reference/latest.js';\nimport validateGlyphsURL from './validate/validate_glyphs_url.js';\n\nimport _validateSource from './validate/validate_source.js';\nimport _validateLight from './validate/validate_light.js';\nimport _validateTerrain from './validate/validate_terrain.js';\nimport _validateFog from './validate/validate_fog.js';\nimport _validateLayer from './validate/validate_layer.js';\nimport _validateFilter from './validate/validate_filter.js';\nimport _validatePaintProperty from './validate/validate_paint_property.js';\nimport _validateLayoutProperty from './validate/validate_layout_property.js';\n\nimport type {StyleSpecification} from './types.js';\n\nexport type ValidationError = {\n    message: string;\n    identifier?: ?string;\n    line?: ?number;\n};\nexport type ValidationErrors = $ReadOnlyArray<ValidationError>;\nexport type Validator = (Object) => ValidationErrors;\n\n/**\n * Validate a Mapbox GL style against the style specification. This entrypoint,\n * `mapbox-gl-style-spec/lib/validate_style.min`, is designed to produce as\n * small a browserify bundle as possible by omitting unnecessary functionality\n * and legacy style specifications.\n *\n * @private\n * @param {Object} style The style to be validated.\n * @param {Object} [styleSpec] The style specification to validate against.\n *     If omitted, the latest style spec is used.\n * @returns {Array<ValidationError>}\n * @example\n *   var validate = require('mapbox-gl-style-spec/lib/validate_style.min');\n *   var errors = validate(style);\n */\nexport function validateStyle(style: StyleSpecification, styleSpec: Object = latestStyleSpec): ValidationErrors {\n\n    const errors = validate({\n        key: '',\n        value: style,\n        valueSpec: styleSpec.$root,\n        styleSpec,\n        style,\n        objectElementValidators: {\n            glyphs: validateGlyphsURL,\n            '*': () => []\n        }\n    });\n    return sortErrors(errors);\n}\n\nexport const validateSource: Validator = opts => sortErrors(_validateSource(opts));\nexport const validateLight: Validator = opts => sortErrors(_validateLight(opts));\nexport const validateTerrain: Validator = opts => sortErrors(_validateTerrain(opts));\nexport const validateFog: Validator = opts => sortErrors(_validateFog(opts));\nexport const validateLayer: Validator = opts => sortErrors(_validateLayer(opts));\nexport const validateFilter: Validator = opts => sortErrors(_validateFilter(opts));\nexport const validatePaintProperty: Validator = opts => sortErrors(_validatePaintProperty(opts));\nexport const validateLayoutProperty: Validator = opts => sortErrors(_validateLayoutProperty(opts));\n\nfunction sortErrors(errors) {\n    return errors.slice().sort((a, b) => a.line && b.line ? a.line - b.line : 0);\n}\n","/* parser generated by jison 0.4.15 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,12],$V1=[1,13],$V2=[1,9],$V3=[1,10],$V4=[1,11],$V5=[1,14],$V6=[1,15],$V7=[14,18,22,24],$V8=[18,22],$V9=[22,24];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"JSONString\":3,\"STRING\":4,\"JSONNumber\":5,\"NUMBER\":6,\"JSONNullLiteral\":7,\"NULL\":8,\"JSONBooleanLiteral\":9,\"TRUE\":10,\"FALSE\":11,\"JSONText\":12,\"JSONValue\":13,\"EOF\":14,\"JSONObject\":15,\"JSONArray\":16,\"{\":17,\"}\":18,\"JSONMemberList\":19,\"JSONMember\":20,\":\":21,\",\":22,\"[\":23,\"]\":24,\"JSONElementList\":25,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",4:\"STRING\",6:\"NUMBER\",8:\"NULL\",10:\"TRUE\",11:\"FALSE\",14:\"EOF\",17:\"{\",18:\"}\",21:\":\",22:\",\",23:\"[\",24:\"]\"},\nproductions_: [0,[3,1],[5,1],[7,1],[9,1],[9,1],[12,2],[13,1],[13,1],[13,1],[13,1],[13,1],[13,1],[15,2],[15,3],[20,3],[19,1],[19,3],[16,2],[16,3],[25,1],[25,3]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\n // replace escaped characters with actual character\n          this.$ = new String(yytext.replace(/\\\\(\\\\|\")/g, \"$\"+\"1\")\n                     .replace(/\\\\n/g,'\\n')\n                     .replace(/\\\\r/g,'\\r')\n                     .replace(/\\\\t/g,'\\t')\n                     .replace(/\\\\v/g,'\\v')\n                     .replace(/\\\\f/g,'\\f')\n                     .replace(/\\\\b/g,'\\b'));\n          this.$.__line__ =  this._$.first_line;\n        \nbreak;\ncase 2:\n\n            this.$ = new Number(yytext);\n            this.$.__line__ =  this._$.first_line;\n        \nbreak;\ncase 3:\n\n            this.$ = null;\n        \nbreak;\ncase 4:\n\n            this.$ = new Boolean(true);\n            this.$.__line__ = this._$.first_line;\n        \nbreak;\ncase 5:\n\n            this.$ = new Boolean(false);\n            this.$.__line__ = this._$.first_line;\n        \nbreak;\ncase 6:\nreturn this.$ = $$[$0-1];\nbreak;\ncase 13:\nthis.$ = {}; Object.defineProperty(this.$, '__line__', {\n            value: this._$.first_line,\n            enumerable: false\n        })\nbreak;\ncase 14: case 19:\nthis.$ = $$[$0-1]; Object.defineProperty(this.$, '__line__', {\n            value: this._$.first_line,\n            enumerable: false\n        })\nbreak;\ncase 15:\nthis.$ = [$$[$0-2], $$[$0]];\nbreak;\ncase 16:\nthis.$ = {}; this.$[$$[$0][0]] = $$[$0][1];\nbreak;\ncase 17:\nthis.$ = $$[$0-2]; $$[$0-2][$$[$0][0]] = $$[$0][1];\nbreak;\ncase 18:\nthis.$ = []; Object.defineProperty(this.$, '__line__', {\n            value: this._$.first_line,\n            enumerable: false\n        })\nbreak;\ncase 20:\nthis.$ = [$$[$0]];\nbreak;\ncase 21:\nthis.$ = $$[$0-2]; $$[$0-2].push($$[$0]);\nbreak;\n}\n},\ntable: [{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,12:1,13:2,15:7,16:8,17:$V5,23:$V6},{1:[3]},{14:[1,16]},o($V7,[2,7]),o($V7,[2,8]),o($V7,[2,9]),o($V7,[2,10]),o($V7,[2,11]),o($V7,[2,12]),o($V7,[2,3]),o($V7,[2,4]),o($V7,[2,5]),o([14,18,21,22,24],[2,1]),o($V7,[2,2]),{3:20,4:$V0,18:[1,17],19:18,20:19},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:23,15:7,16:8,17:$V5,23:$V6,24:[1,21],25:22},{1:[2,6]},o($V7,[2,13]),{18:[1,24],22:[1,25]},o($V8,[2,16]),{21:[1,26]},o($V7,[2,18]),{22:[1,28],24:[1,27]},o($V9,[2,20]),o($V7,[2,14]),{3:20,4:$V0,20:29},{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:30,15:7,16:8,17:$V5,23:$V6},o($V7,[2,19]),{3:5,4:$V0,5:6,6:$V1,7:3,8:$V2,9:4,10:$V3,11:$V4,13:31,15:7,16:8,17:$V5,23:$V6},o($V8,[2,17]),o($V8,[2,15]),o($V9,[2,21])],\ndefaultActions: {16:[2,6]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        throw new Error(str);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        function lex() {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 6\nbreak;\ncase 2:yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2); return 4\nbreak;\ncase 3:return 17\nbreak;\ncase 4:return 18\nbreak;\ncase 5:return 23\nbreak;\ncase 6:return 24\nbreak;\ncase 7:return 22\nbreak;\ncase 8:return 21\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 11\nbreak;\ncase 11:return 8\nbreak;\ncase 12:return 14\nbreak;\ncase 13:return 'INVALID'\nbreak;\n}\n},\nrules: [/^(?:\\s+)/,/^(?:(-?([0-9]|[1-9][0-9]+))(\\.[0-9]+)?([eE][-+]?[0-9]+)?\\b)/,/^(?:\"(?:\\\\[\\\\\"bfnrt/]|\\\\u[a-fA-F0-9]{4}|[^\\\\\\0-\\x09\\x0a-\\x1f\"])*\")/,/^(?:\\{)/,/^(?:\\})/,/^(?:\\[)/,/^(?:\\])/,/^(?:,)/,/^(?::)/,/^(?:true\\b)/,/^(?:false\\b)/,/^(?:null\\b)/,/^(?:$)/,/^(?:.)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\n}\n","import ParsingError from './error/parsing_error.js';\nimport jsonlint from '@mapbox/jsonlint-lines-primitives';\n\nexport default function readStyle(style) {\n    if (style instanceof String || typeof style === 'string' || style instanceof Buffer) {\n        try {\n            return jsonlint.parse(style.toString());\n        } catch (e) {\n            throw new ParsingError(e);\n        }\n    }\n\n    return style;\n}\n","// @flow\nimport {validateStyle as validateStyleMin} from './validate_style.min.js';\nimport {v8} from './style-spec.js';\nimport readStyle from './read_style.js';\n\nimport type {ValidationErrors} from './validate_style.min.js';\nimport type {StyleSpecification} from './types.js';\n\n/**\n * Validate a Mapbox GL style against the style specification.\n *\n * @private\n * @alias validate\n * @param {Object|String|Buffer} style The style to be validated. If a `String`\n *     or `Buffer` is provided, the returned errors will contain line numbers.\n * @param {Object} [styleSpec] The style specification to validate against.\n *     If omitted, the spec version is inferred from the stylesheet.\n * @returns {Array<ValidationError|ParsingError>}\n * @example\n *   var validate = require('mapbox-gl-style-spec').validate;\n *   var style = fs.readFileSync('./style.json', 'utf8');\n *   var errors = validate(style);\n */\n\nexport default function validateStyle(style: StyleSpecification | string | Buffer, styleSpec: Object = v8): ValidationErrors {\n    let s = style;\n\n    try {\n        s = readStyle(s);\n    } catch (e) {\n        return [e];\n    }\n\n    return validateStyleMin(s, styleSpec);\n}\n\nexport {\n    validateSource as source,\n    validateLight as light,\n    validateLayer as layer,\n    validateFilter as filter,\n    validatePaintProperty as paintProperty,\n    validateLayoutProperty as layoutProperty\n} from './validate_style.min.js';\n","// @flow\n\nimport {validateStyle} from './validate_style.min.js';\nimport {v8} from './style-spec.js';\nimport readStyle from './read_style.js';\nimport ValidationError from './error/validation_error.js';\nimport getType from './util/get_type.js';\n\nimport type {ValidationErrors} from './validate_style.min.js';\n\nconst SUPPORTED_SPEC_VERSION = 8;\nconst MAX_SOURCES_IN_STYLE = 15;\n\nfunction isValid(value: ?string, regex: RegExp): boolean {\n    if (!value || getType(value) !== 'string') return true;\n    return !!value.match(regex);\n}\n\nfunction getSourceCount(source: Object): number {\n    if (source.url) {\n        return source.url.split(',').length;\n    } else {\n        return 0;\n    }\n}\n\nfunction getAllowedKeyErrors(obj: Object, keys: Array<*>, path: ?string): Array<ValidationError> {\n    const allowed = new Set(keys);\n    const errors = [];\n    Object.keys(obj).forEach(k => {\n        if (!allowed.has(k)) {\n            const prop = path ? `${path}.${k}` : null;\n            errors.push(new ValidationError(prop, obj[k], `Unsupported property \"${k}\"`));\n        }\n    });\n    return errors;\n}\n\nconst acceptedSourceTypes = new Set([\"vector\", \"raster\", \"raster-dem\"]);\nfunction getSourceErrors(source: Object, i: number): Array<ValidationError> {\n    const errors = [];\n\n    /*\n     * Inlined sources are not supported by the Mapbox Styles API, so only\n     * \"type\", \"url\", and \"tileSize\" properties are valid\n     */\n    const sourceKeys = ['type', 'url', 'tileSize'];\n    errors.push(...getAllowedKeyErrors(source, sourceKeys, 'source'));\n\n    /*\n     * \"type\" is required and must be one of \"vector\", \"raster\", \"raster-dem\"\n     */\n    if (!acceptedSourceTypes.has(String(source.type))) {\n        errors.push(new ValidationError(`sources[${i}].type`, source.type, `Expected one of [${Array.from(acceptedSourceTypes).join(\", \")}]`));\n    }\n\n    /*\n     * \"source\" is required. Valid examples:\n     * mapbox://mapbox.abcd1234\n     * mapbox://penny.abcd1234\n     * mapbox://mapbox.abcd1234,penny.abcd1234\n     */\n    const sourceUrlPattern = /^mapbox:\\/\\/([^/]*)$/;\n    if (!source.url || !isValid(source.url, sourceUrlPattern)) {\n        errors.push(new ValidationError(`sources[${i}].url`, source.url, 'Expected a valid Mapbox tileset url'));\n    }\n\n    return errors;\n}\n\nfunction getSourcesErrors(sources: Object): Array<ValidationError> {\n    const errors = [];\n    let count = 0;\n\n    Object.keys(sources).forEach((s: string, i: number) => {\n        const sourceErrors = getSourceErrors(sources[s], i);\n\n        // If source has errors, skip counting\n        if (!sourceErrors.length) {\n            count = count + getSourceCount(sources[s]);\n        }\n\n        errors.push(...sourceErrors);\n    });\n\n    if (count > MAX_SOURCES_IN_STYLE) {\n        errors.push(new ValidationError('sources', null, `Styles must contain ${MAX_SOURCES_IN_STYLE} or fewer sources`));\n    }\n\n    return errors;\n}\n\nfunction getRootErrors(style: Object, specKeys: Array<any>): Array<ValidationError> {\n    const errors = [];\n\n    /*\n     * The following keys are optional but fully managed by the Mapbox Styles\n     * API. Values on stylesheet on POST or PATCH will be ignored: \"owner\",\n     * \"id\", \"cacheControl\", \"draft\", \"created\", \"modified\", \"protected\"\n     *\n     * The following keys are optional. The Mapbox Styles API respects value on\n     * stylesheet on PATCH, but ignores the value on POST: \"visibility\"\n     */\n    const optionalRootProperties = [\n        'owner',\n        'id',\n        'cacheControl',\n        'draft',\n        'created',\n        'modified',\n        'visibility',\n        'protected'\n    ];\n\n    const allowedKeyErrors = getAllowedKeyErrors(style, [...specKeys, ...optionalRootProperties]);\n    errors.push(...allowedKeyErrors);\n\n    if (style.version > SUPPORTED_SPEC_VERSION || style.version < SUPPORTED_SPEC_VERSION) {\n        errors.push(new ValidationError('version', style.version, `Style version must be ${SUPPORTED_SPEC_VERSION}`));\n    }\n\n    /*\n     * \"glyphs\" is optional. If present, valid examples:\n     * mapbox://fonts/penny/{fontstack}/{range}.pbf\n     * mapbox://fonts/mapbox/{fontstack}/{range}.pbf\n     */\n    const glyphUrlPattern = /^mapbox:\\/\\/fonts\\/([^/]*)\\/{fontstack}\\/{range}.pbf$/;\n    if (!isValid(style.glyphs, glyphUrlPattern)) {\n        errors.push(new ValidationError('glyphs', style.glyphs, 'Styles must reference glyphs hosted by Mapbox'));\n    }\n\n    /*\n     * \"sprite\" is optional. If present, valid examples:\n     * mapbox://sprites/penny/abcd1234\n     * mapbox://sprites/mapbox/abcd1234/draft\n     * mapbox://sprites/cyrus/abcd1234/abcd1234\n     */\n    const spriteUrlPattern = /^mapbox:\\/\\/sprites\\/([^/]*)\\/([^/]*)\\/?([^/]*)?$/;\n    if (!isValid(style.sprite, spriteUrlPattern)) {\n        errors.push(new ValidationError('sprite', style.sprite, 'Styles must reference sprites hosted by Mapbox'));\n    }\n\n    /*\n     * \"visibility\" is optional. If present, valid examples:\n     * \"private\"\n     * \"public\"\n     */\n    const visibilityPattern = /^(public|private)$/;\n    if (!isValid(style.visibility, visibilityPattern)) {\n        errors.push(new ValidationError('visibility', style.visibility, 'Style visibility must be public or private'));\n    }\n\n    if (style.protected !== undefined && getType(style.protected) !== 'boolean') {\n        errors.push(new ValidationError('protected', style.protected, 'Style protection must be true or false'));\n    }\n\n    return errors;\n}\n\n/**\n * Validate a Mapbox GL style against the style specification and check for\n * compatibility with the Mapbox Styles API.\n *\n * @param {Object} style The style to be validated.\n * @returns {Array<ValidationError>}\n * @example\n *   var validateMapboxApiSupported = require('mapbox-gl-style-spec/lib/validate_style_mapbox_api_supported.js');\n *   var errors = validateMapboxApiSupported(style);\n */\nexport default function validateMapboxApiSupported(style: Object, styleSpec: Object = v8): ValidationErrors {\n    let s = style;\n    try {\n        s = readStyle(s);\n    } catch (e) {\n        return [e];\n    }\n\n    let errors = validateStyle(s, styleSpec)\n        .concat(getRootErrors(s, Object.keys(v8.$root)));\n\n    if (s.sources) {\n        errors = errors.concat(getSourcesErrors(s.sources));\n    }\n\n    return errors;\n}\n\n","import LegendSymbol from \"@watergis/legend-symbol\";\n\nconst sprite = \"map.getStyle()\";\nconst zoom = \"style.layers[2]\";\nconst layer = \"style.sprite\";\nvar test = LegendSymbol({ sprite, zoom, layer });\n","export default function Circle (props) {\n  const {expr, layer} = props;\n\n  const radius = Math.min(\n    expr(layer, \"paint\", \"circle-radius\"),\n    8\n  );\n  const strokeWidth = Math.min(\n    expr(layer, \"paint\", \"circle-stroke-width\"),\n    4\n  );\n  const fillColor = expr(layer, \"paint\", \"circle-color\");\n  const fillOpacity = expr(layer, \"paint\", \"circle-opacity\");\n  const strokeColor = expr(layer, \"paint\", \"circle-stroke-color\");\n  const strokeOpacity = expr(layer, \"paint\", \"circle-stroke-opacity\");\n  const blur = expr(layer, \"paint\", \"circle-blur\");\n\n  const innerRadius = radius-strokeWidth/2;\n\n  return {\n    element: \"svg\",\n    attributes: {\n      viewBox: \"0 0 20 20\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      style: {\n        filter: `blur(${blur*innerRadius}px)`\n      }\n    },\n    children: [\n      {\n        element: \"circle\",\n        attributes: {\n          key: \"l1\",\n          cx: 10,\n          cy: 10,\n          fill: fillColor,\n          opacity: fillOpacity,\n          r: innerRadius,\n        },\n      },\n      {\n        element: \"circle\",\n        attributes: {\n          key: \"l2\",\n          cx: 10,\n          cy: 10,\n          fill: \"transparent\",\n          opacity: strokeOpacity,\n          r: radius,\n          \"stroke-width\": strokeWidth,\n          stroke: strokeColor,\n        },\n      },\n    ]\n  }\n}\n\n","export default function Fill (props) {\n  const {image, expr, layer} = props;\n  const dataUrl = image(\n    expr(layer, \"paint\", \"fill-pattern\")\n  );\n\n  const style = {\n    width: \"100%\",\n    height: \"100%\",\n    backgroundImage: `url(${dataUrl})`,\n    backgroundColor: expr(layer, \"paint\", \"fill-color\"),\n    opacity: expr(layer, \"paint\", \"fill-opacity\"),\n    backgroundSize: \"66% 66%\",\n    backgroundPosition: \"center\",\n  };\n\n  return {\n    element: \"div\",\n    attributes: {\n      style,\n    }\n  };\n}\n","export default function Line (props) {\n  const {layer, image, expr} = props;\n  const linePatternDataUrl = image(\n    expr(layer, \"paint\", \"line-pattern\")\n  );\n\n  const style = {\n    stroke: linePatternDataUrl ? `url(#img1)` : expr(layer, \"paint\", \"line-color\"),\n    strokeWidth: Math.max(2, Math.min(\n      expr(layer, \"paint\", \"line-width\"),\n      8\n    )),\n    strokeOpacity: expr(layer, \"paint\", \"line-opacity\"),\n    strokeDasharray: expr(layer, \"paint\", \"line-dasharray\"),\n  };\n  const sw = style.strokeWidth;\n  let cssStyle = `stroke: ${style.stroke};`\n  if (style.strokeOpacity) {\n    cssStyle += `stroke-opacity: ${style.strokeOpacity};`\n  }\n  if (style.strokeDasharray) {\n    cssStyle += `stroke-dasharray: ${style.strokeDasharray};`;\n  }\n\n  return {\n    element: \"svg\",\n    attributes: {\n      viewBox: \"0 0 20 20\",\n      xmlns: \"http://www.w3.org/2000/svg\"\n    },\n    children: [\n      {\n        element: \"defs\",\n        attributes: {\n          key: \"defs\",\n        },\n        children: [\n          {\n            element: \"pattern\",\n            attributes: {\n              key: \"pattern\",\n              id: \"img1\",\n              x: 0,\n              y: 0,\n              width: style.strokeWidth,\n              height: style.strokeWidth,\n              patternUnits: \"userSpaceOnUse\",\n              patternTransform: `translate(${-(sw/2)} ${-(sw/2)}) rotate(45)`\n            },\n            children: [\n              {\n                element: \"image\",\n                attributes: {\n                  key: \"img\",\n                  xlinkHref: linePatternDataUrl,\n                  x: 0,\n                  y: 0,\n                  width: style.strokeWidth,\n                  height: style.strokeWidth,\n                }\n              }\n            ]\n          }\n        ]\n      },\n      {\n        element: \"path\",\n        attributes: {\n          key: \"path\",\n          style: cssStyle,\n          d: \"M0 20 L 20 0\",\n        }\n      }\n    ]\n  };\n}\n","function renderIconSymbol ({expr, layer, image}) {\n  const imgKey = expr(layer, \"layout\", \"icon-image\");\n\n  if (!imgKey) {\n    return null;\n  }\n  const dataUrl = image(imgKey);\n  if (dataUrl) {\n    return {\n      element: \"div\",\n      attributes: {\n        style: {\n          backgroundImage: `url(${dataUrl})`,\n          backgroundSize: \"contain\",\n          backgroundPosition: \"center\",\n          backgroundRepeat: \"no-repeat\",\n          width: \"100%\",\n          height: \"100%\",\n        }\n      },\n    };\n  }\n  else {\n    return null;\n  }\n}\n\nfunction renderTextSymbol ({expr, layer}) {\n  const textColor = expr(\n    layer, \"paint\", \"text-color\"\n  );\n  const textOpacity = expr(\n    layer, \"paint\", \"text-opacity\"\n  );\n  const textHaloColor = expr(\n    layer, \"paint\", \"text-halo-color\"\n  );\n  const textHaloWidth = expr(\n    layer, \"paint\", \"text-halo-width\"\n  );\n\n  // A \"T\" shape to signify text\n  const d = \"M 4,4 L 16,4 L 16,7 L 11.5 7 L 11.5 16 L 8.5 16 L 8.5 7 L 4 7 Z\";\n\n  return {\n    element: \"svg\",\n    attributes: {\n      viewBox: \"0 0 20 20\",\n      xmlns: \"http://www.w3.org/2000/svg\"\n    },\n    children: [\n      {\n        element: \"path\",\n        attributes: {\n          key: \"l1\",\n          d: d,\n          stroke: textHaloColor,\n          \"stroke-width\": textHaloWidth*2,\n          fill: \"transparent\",\n          \"stroke-linejoin\": \"round\",\n        }\n      },\n      {\n        element: \"path\",\n        attributes: {\n          key: \"l2\",\n          d: d,\n          fill: \"white\",\n        }\n      },\n      {\n        element: \"path\",\n        attributes: {\n          key: \"l3\",\n          d: d,\n          fill: textColor,\n          opacity: textOpacity,\n        }\n      },\n    ]\n  };\n}\n\nexport default function Symbol (props) {\n  return renderIconSymbol(props) || renderTextSymbol(props);\n}\n","import {\n  expression,\n  latest,\n  function as styleFunction\n} from '@mapbox/mapbox-gl-style-spec';\n\n\nconst PROP_MAP = [\n  [\"background\"],\n  [\"circle\"],\n  [\"fill-extrusion\"],\n  [\"fill\"],\n  [\"heatmap\"],\n  [\"hillshade\"],\n  [\"line\"],\n  [\"raster\"],\n  [\"icon\", \"symbol\"],\n  [\"text\", \"symbol\"],\n];\n\nexport function exprHandler ({zoom}) {\n  function prefixFromProp (prop) {\n    const out = PROP_MAP.find(def => {\n      const type = def[0];\n      return prop.startsWith(type);\n    });\n    return out ? (out[1] || out[0]) : null;\n  }\n\n  return function (layer, type, prop) {\n    const prefix = prefixFromProp(prop);\n    const specItem = latest[`${type}_${prefix}`][prop];\n    const dflt = specItem.default;\n\n    if (!layer[type]) {\n      return  dflt;\n    }\n\n    const input = layer[type][prop];\n\n    const objType = typeof(input);\n    // Is it an expression...\n    if (objType === \"undefined\") {\n      return specItem.default;\n    }\n    else if (typeof(input) === \"object\") {\n      let expr;\n      if (Array.isArray(input)) {\n        if (specItem.type === \"array\") {\n          // Special case: some properties are arrays, which should not be mistaken for expressions. It should be treated as a literal value.\n          return input;\n        }\n        else {\n          expr = expression.createExpression(input).value;\n        }\n      }\n      else {\n        expr = styleFunction.createFunction(input, specItem);\n      }\n      if (!expr.evaluate) {\n        return null;\n      }\n\n      const result = expr.evaluate({zoom}, {});\n      if (result) {\n        // Because it can be a resolved image.\n        return (result.name || result);\n      }\n      else {\n        return null;\n      }\n    }\n    else {\n      return input;\n    }\n  }\n}\n\n\n\nexport function mapImageToDataURL (map, icon) {\n  if (!icon) {\n    return undefined;\n  }\n\n  const image = map.style.imageManager.images[icon];\n  if (!image) {\n    return undefined;\n  }\n\n  const canvasEl = document.createElement(\"canvas\");\n  canvasEl.width = image.data.width;\n  canvasEl.height = image.data.height;\n  const ctx = canvasEl.getContext(\"2d\");\n  ctx.putImageData(\n    new ImageData(\n      Uint8ClampedArray.from(image.data.data),\n      image.data.width, image.data.height\n    ),\n    0, 0\n  );\n\n  // Not toBlob() because toDataURL is faster and synchronous.\n  return canvasEl.toDataURL();\n}\n\n\nconst dataStore = new Map();\nexport const cache = {\n  add: (key, value) => {\n    if (dataStore.has(key)) {\n      throw new Error(`Cache already contains '${key}'`);\n    }\n    dataStore.set(key, {\n      value,\n      count: 1\n    });\n  },\n  fetch: (key) => {\n    const cacheObj = dataStore.get(key);\n    if(cacheObj) {\n      cacheObj.count++;\n      return cacheObj.value;\n    }\n  },\n  release: (key) => {\n    const cacheObj = dataStore.get(key);\n    if(!cacheObj) {\n      throw new Error(`No such key in cache '${key}'`);\n    }\n    cacheObj.count--;\n\n    if (cacheObj.count === 0) {\n      dataStore.delete(key);\n    }\n  },\n};\n\nfunction loadImageViaTag (url) {\n  let cancelled = false;\n  const promise = new Promise((resolve, reject) => {\n    const img = new Image();\n    img.crossOrigin = \"Anonymous\";\n    img.onload = () => {\n      if (!cancelled) resolve(img);\n    }\n    img.onerror = e => {\n      if (!cancelled) reject(e);\n    };\n    img.src = url;\n  });\n  promise.cancel = () => {\n    cancelled = true;\n  }\n  return promise;\n}\n\nfunction removeUrl (obj) {\n  obj = {...obj};\n  delete obj['url'];\n  return obj;\n}\n\nfunction loadImageViaFetch (url, init) {\n  return fetch(url, init)\n    .then(res => res.blob())\n    .then(blob => URL.createObjectURL(blob))\n    .then(url => loadImageViaTag(url));\n}\n\nexport function loadImage (url, {transformRequest}) {\n  const fetchObj = {...transformRequest(url)};\n\n  if (fetchObj.headers) {\n    return loadImageViaFetch(url, removeUrl(fetchObj));\n  }\n  else {\n    return loadImageViaTag(url);\n  }\n}\n\nexport function loadJson (url, {transformRequest}) {\n  const fetchObj = {...transformRequest(url)};\n  return fetch(fetchObj.url, removeUrl(fetchObj)).then(res => res.json());\n}\n\n","import LegendSymbol from \"@watergis/legend-symbol\";\n\nconst sprite = \"map.getStyle()\";\nconst zoom = \"style.layers[2]\";\nconst layer = \"style.sprite\";\nvar test = LegendSymbol({ sprite, zoom, layer });\n"]}